<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Earth & Satellite - TSL</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.webgpu.min.js",
      "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.webgpu.min.js",
      "three/tsl": "https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.tsl.min.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three/webgpu';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import {
      Fn, vec3, vec4, float, uniform, time,
      positionLocal, normalWorld, normalLocal, uv,
      mix, pow, dot, normalize, max, sin, cos,
      cameraPosition, positionWorld, texture, attribute
    } from 'three/tsl';

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 3, 10);

    const renderer = new THREE.WebGPURenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 1);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 2);
    sunLight.position.set(5, 3, 5);
    scene.add(sunLight);

    // Realistic stars background with twinkling effect
    const starsGeometry = new THREE.BufferGeometry();
    const starCount = 8000;
    const positions = new Float32Array(starCount * 3);
    const sizes = new Float32Array(starCount);
    const colors = new Float32Array(starCount * 3);
    const randomValues = new Float32Array(starCount); // For twinkling animation

    for (let i = 0; i < starCount; i++) {
      const radius = 100 + Math.random() * 400;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;

      positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      positions[i * 3 + 2] = radius * Math.cos(phi);

      // Variable star sizes (most small, some larger)
      sizes[i] = Math.random() < 0.9 ? 1.5 + Math.random() * 2 : 3 + Math.random() * 3;

      // Star colors - mostly white/blue-white, some yellow/orange/red
      const colorType = Math.random();
      if (colorType < 0.7) {
        // Blue-white stars (most common)
        colors[i * 3] = 0.9 + Math.random() * 0.1;
        colors[i * 3 + 1] = 0.9 + Math.random() * 0.1;
        colors[i * 3 + 2] = 1.0;
      } else if (colorType < 0.9) {
        // Yellow-white stars
        colors[i * 3] = 1.0;
        colors[i * 3 + 1] = 0.9 + Math.random() * 0.1;
        colors[i * 3 + 2] = 0.7 + Math.random() * 0.2;
      } else {
        // Orange-red stars (rare)
        colors[i * 3] = 1.0;
        colors[i * 3 + 1] = 0.6 + Math.random() * 0.3;
        colors[i * 3 + 2] = 0.4 + Math.random() * 0.2;
      }

      // Random offset for twinkling phase
      randomValues[i] = Math.random() * 100;
    }

    starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    starsGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    starsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    starsGeometry.setAttribute('randomValue', new THREE.BufferAttribute(randomValues, 1));

    const starsMaterial = new THREE.PointsNodeMaterial({
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    // Twinkling star animation using TSL
    const starSize = attribute('size');
    const starColor = attribute('color', 'vec3');
    const randomValue = attribute('randomValue');

    starsMaterial.sizeNode = Fn(() => {
      const baseSize = starSize;
      const random = randomValue;
      // Create more pronounced twinkling effect with different speeds for each star
      const twinkle = sin(time.mul(3.0).add(random)).mul(0.6).add(1.0);
      return baseSize.mul(twinkle);
    })();

    starsMaterial.colorNode = Fn(() => {
      const baseColor = starColor;
      const random = randomValue;
      // More dramatic brightness variation for twinkling
      const brightness = sin(time.mul(2.5).add(random)).mul(0.5).add(0.8);
      const alpha = sin(time.mul(3.0).add(random)).mul(0.5).add(0.5);
      return vec4(baseColor.mul(brightness), alpha);
    })();

    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    // Load textures
    const textureLoader = new THREE.TextureLoader();

    // Earth textures from NASA
    const earthDayTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg');
    const earthNightTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_lights_2048.png');
    const earthSpecularTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_specular_2048.jpg');
    const earthCloudsTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png');

    // Earth
    const earthGeometry = new THREE.SphereGeometry(2, 128, 128);
    const earthMaterial = new THREE.MeshStandardNodeMaterial();

    // Day/night Earth with specular oceans
    const earthDayMap = texture(earthDayTexture);
    const earthNightMap = texture(earthNightTexture);
    const earthSpecMap = texture(earthSpecularTexture);

    earthMaterial.colorNode = earthDayMap;
    earthMaterial.roughnessNode = float(0.9);
    earthMaterial.metalnessNode = float(0.0);

    // Ocean specularity - water reflects more
    earthMaterial.roughnessNode = Fn(() => {
      const spec = earthSpecMap.r;
      // Where there's water (specular map is bright), make it smoother
      return mix(float(0.9), float(0.3), spec);
    })();

    // Night lights on dark side
    earthMaterial.emissiveNode = Fn(() => {
      // Fresnel atmosphere glow
      const viewDir = normalize(cameraPosition.sub(positionWorld));
      const NdotV = max(dot(normalWorld, viewDir), 0.0);
      const fresnel = pow(float(1.0).sub(NdotV), 3.0);
      const atmosphereColor = vec3(0.3, 0.6, 1.0);
      const atmosphere = atmosphereColor.mul(fresnel).mul(0.2);

      // Night lights based on lighting
      const sunDir = normalize(vec3(5, 3, 5));
      const NdotL = dot(normalWorld, sunDir);
      const nightSide = float(1.0).sub(NdotL.mul(0.5).add(0.5)).pow(3.0);
      const nightLights = earthNightMap.rgb.mul(nightSide).mul(1.5);

      return atmosphere.add(nightLights);
    })();

    const earth = new THREE.Mesh(earthGeometry, earthMaterial);
    scene.add(earth);

    // Clouds layer
    const cloudsGeometry = new THREE.SphereGeometry(2.01, 64, 64);
    const cloudsMaterial = new THREE.MeshStandardNodeMaterial({
      transparent: true
    });

    const earthCloudsMap = texture(earthCloudsTexture);
    cloudsMaterial.colorNode = vec4(1, 1, 1, 1);
    cloudsMaterial.opacityNode = earthCloudsMap.a.mul(0.4);
    cloudsMaterial.roughnessNode = float(1.0);
    cloudsMaterial.metalnessNode = float(0.0);

    const clouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
    scene.add(clouds);

    // Animation loop
    async function init() {
      await renderer.init();
      animate();
    }

    function animate() {
      requestAnimationFrame(animate);

      const t = performance.now() * 0.001;

      // Rotate Earth
      earth.rotation.y = t * 0.1;

      // Rotate clouds slightly faster for realism
      clouds.rotation.y = t * 0.12;

      controls.update();
      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
  </script>
</body>
</html>
