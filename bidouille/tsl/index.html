<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Earth & Satellite - TSL</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.webgpu.min.js",
      "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.webgpu.min.js",
      "three/tsl": "https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.tsl.min.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three/webgpu';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import {
      Fn, vec3, vec4, float, uniform, time,
      positionLocal, normalWorld, normalLocal, uv,
      mix, pow, dot, normalize, max, min, sin, cos,
      cameraPosition, positionWorld, texture, attribute, clamp, step
    } from 'three/tsl';

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 2, 6); // Much closer to Earth

    const renderer = new THREE.WebGPURenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 1);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 2);
    sunLight.position.set(-5, 2, -8); // Behind the Earth for rim lighting effect
    scene.add(sunLight);

    // Realistic stars background with twinkling effect
    const starsGeometry = new THREE.BufferGeometry();
    const starCount = 8000;
    const positions = new Float32Array(starCount * 3);
    const sizes = new Float32Array(starCount);
    const colors = new Float32Array(starCount * 3);
    const randomValues = new Float32Array(starCount); // For twinkling animation

    for (let i = 0; i < starCount; i++) {
      const radius = 100 + Math.random() * 400;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;

      positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      positions[i * 3 + 2] = radius * Math.cos(phi);

      // Variable star sizes (most small, some larger)
      sizes[i] = Math.random() < 0.9 ? 1.5 + Math.random() * 2 : 3 + Math.random() * 3;

      // Star colors - mostly white/blue-white, some yellow/orange/red
      const colorType = Math.random();
      if (colorType < 0.7) {
        // Blue-white stars (most common)
        colors[i * 3] = 0.9 + Math.random() * 0.1;
        colors[i * 3 + 1] = 0.9 + Math.random() * 0.1;
        colors[i * 3 + 2] = 1.0;
      } else if (colorType < 0.9) {
        // Yellow-white stars
        colors[i * 3] = 1.0;
        colors[i * 3 + 1] = 0.9 + Math.random() * 0.1;
        colors[i * 3 + 2] = 0.7 + Math.random() * 0.2;
      } else {
        // Orange-red stars (rare)
        colors[i * 3] = 1.0;
        colors[i * 3 + 1] = 0.6 + Math.random() * 0.3;
        colors[i * 3 + 2] = 0.4 + Math.random() * 0.2;
      }

      // Random offset for twinkling phase
      randomValues[i] = Math.random() * 100;
    }

    starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    starsGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    starsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    starsGeometry.setAttribute('randomValue', new THREE.BufferAttribute(randomValues, 1));

    const starsMaterial = new THREE.PointsNodeMaterial({
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    // Twinkling star animation using TSL
    const starSize = attribute('size');
    const starColor = attribute('color', 'vec3');
    const randomValue = attribute('randomValue');

    starsMaterial.sizeNode = Fn(() => {
      const baseSize = starSize;
      const random = randomValue;
      // Create more pronounced twinkling effect with different speeds for each star
      const twinkle = sin(time.mul(3.0).add(random)).mul(0.6).add(1.0);
      return baseSize.mul(twinkle);
    })();

    starsMaterial.colorNode = Fn(() => {
      const baseColor = starColor;
      const random = randomValue;
      // More dramatic brightness variation for twinkling
      const brightness = sin(time.mul(2.5).add(random)).mul(0.5).add(0.8);
      const alpha = sin(time.mul(3.0).add(random)).mul(0.5).add(0.5);
      return vec4(baseColor.mul(brightness), alpha);
    })();

    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    // Load textures
    const textureLoader = new THREE.TextureLoader();

    // Earth textures from NASA
    const earthDayTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg');
    const earthNightTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_lights_2048.png');
    const earthSpecularTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_specular_2048.jpg');
    const earthCloudsTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png');

    // Function to load image as a Promise
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    // Function to create city lights based on texture sampling - ONLY on continents
    function createCityLights(image) {

      // Create canvas to read pixel data
      const canvas = document.createElement('canvas');
      canvas.width = image.width;
      canvas.height = image.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      // Geometry and attributes setup
      const cityLightsGeometry = new THREE.BufferGeometry();
      const lightCount = 200000; // High target with probability-based placement
      const positions = new Float32Array(lightCount * 3);
      const sizes = new Float32Array(lightCount);
      const colors = new Float32Array(lightCount * 3);
      const phaseOffsets = new Float32Array(lightCount);
      const pulsationSpeeds = new Float32Array(lightCount);

      let placed = 0;
      const maxAttempts = lightCount * 10;

      // Rejection sampling: only place lights on continents (bright pixels in night lights map)
      for (let attempt = 0; attempt < maxAttempts && placed < lightCount; attempt++) {
        // Random UV coordinates
        const u = Math.random();
        const v = Math.random();

        // Sample texture at UV position
        const x = Math.floor(u * canvas.width);
        const y = Math.floor(v * canvas.height);
        const idx = (y * canvas.width + x) * 4;
        const brightness = (imageData.data[idx] + imageData.data[idx + 1] + imageData.data[idx + 2]) / (3 * 255);

        // First filter: eliminate oceans completely (brightness < 0.08 = ocean)
        if (brightness > 0.08) {
          // Then use brightness as probability for realistic city density
          const placementProbability = Math.pow(brightness, 1.5) * 3.0;
          if (Math.random() < placementProbability) {
          // Convert UV to spherical coordinates
          const phi = v * Math.PI;
          const theta = u * Math.PI * 2;
          const r = 2.001; // Right at Earth surface for building lights

          // Convert spherical to Cartesian
          positions[placed * 3] = r * Math.sin(phi) * Math.cos(theta);
          positions[placed * 3 + 1] = r * Math.cos(phi);
          positions[placed * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);

          // Medium-sized visible lights (3.0-6.0 pixels)
          sizes[placed] = 3.0 + Math.random() * 3.0;

          // Warm color palette
          const colorType = Math.random();
          if (colorType < 0.8) {
            // Warm amber 80% (sodium vapor street lights)
            colors[placed * 3] = 1.0;
            colors[placed * 3 + 1] = 0.85;
            colors[placed * 3 + 2] = 0.6;
          } else if (colorType < 0.95) {
            // Warm yellow 15% (incandescent)
            colors[placed * 3] = 1.0;
            colors[placed * 3 + 1] = 0.92;
            colors[placed * 3 + 2] = 0.7;
          } else {
            // Cool white 5% (modern LED)
            colors[placed * 3] = 0.95;
            colors[placed * 3 + 1] = 0.98;
            colors[placed * 3 + 2] = 1.0;
          }

          // Random phase offset for desynchronized pulsation
          phaseOffsets[placed] = Math.random() * 100;

          // Extremely varied speeds for chaotic blinking
          pulsationSpeeds[placed] = 0.5 + Math.random() * 4.5; // 0.5-5.0 (very varied)

          placed++;
          }
        }
      }

      // Set attributes
      cityLightsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      cityLightsGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      cityLightsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      cityLightsGeometry.setAttribute('phaseOffset', new THREE.BufferAttribute(phaseOffsets, 1));
      cityLightsGeometry.setAttribute('pulsationSpeed', new THREE.BufferAttribute(pulsationSpeeds, 1));

      // Material with TSL animation - visible city lights
      const cityLightsMaterial = new THREE.PointsNodeMaterial({
        transparent: true,
        blending: THREE.AdditiveBlending, // Additive for visible glow
        depthWrite: false,
        depthTest: true // Hidden behind Earth
      });

      // TSL attributes
      const lightSize = attribute('size');
      const lightColor = attribute('color', 'vec3');
      const phaseOffset = attribute('phaseOffset');
      const pulsationSpeed = attribute('pulsationSpeed');

      // Size animation (soft pulsation)
      cityLightsMaterial.sizeNode = Fn(() => {
        const baseSize = lightSize;
        const phase = phaseOffset;
        const speed = pulsationSpeed;

        // Gentle sine wave pulsation (85%-100% of size)
        const pulse = sin(time.mul(speed).add(phase)).mul(0.15).add(0.85);

        return baseSize.mul(pulse);
      })();

      // Random blinking - each light randomly turns ON or OFF
      cityLightsMaterial.colorNode = Fn(() => {
        const baseColor = lightColor;
        const phase = phaseOffset;
        const speed = pulsationSpeed;

        // Create chaotic random pattern for each light
        // Using multiple sin waves with very different frequencies for chaotic blinking
        const random1 = sin(time.mul(speed.mul(8.0)).add(phase));
        const random2 = sin(time.mul(speed.mul(15.3)).add(phase.mul(4.2)));
        const random3 = sin(time.mul(speed.mul(5.7)).add(phase.mul(6.8)));

        // Combine for maximum randomness
        const randomValue = random1.mul(0.5).add(random2.mul(0.3)).add(random3.mul(0.2));

        // Sharp threshold - convert to binary ON (1.0) or OFF (0.0)
        // step(0.0, randomValue) gives true 50/50 random blinking for maximum variation
        const onOffValue = step(float(0.0), randomValue);

        // Day/night fade
        const sunDir = normalize(vec3(-5, 2, -8)); // Match the sun light position
        const lightNormal = normalize(positionLocal);
        const NdotL = dot(lightNormal, sunDir);
        const nightSide = float(1.0).sub(NdotL.mul(0.5).add(0.5)).pow(2.0);

        // Final brightness - visible city lights with good contrast
        const finalBrightness = onOffValue.mul(nightSide).mul(5.0);

        return vec4(baseColor.mul(finalBrightness), finalBrightness);
      })();

      // Create Points object and add to Earth
      const cityLights = new THREE.Points(cityLightsGeometry, cityLightsMaterial);
      earth.add(cityLights); // Parent to Earth for automatic rotation

      console.log(`City lights created: ${placed} lights on continents only`);
    }

    // Earth
    const earthGeometry = new THREE.SphereGeometry(2, 128, 128);
    const earthMaterial = new THREE.MeshStandardNodeMaterial();

    // Day/night Earth with specular oceans
    const earthDayMap = texture(earthDayTexture);
    const earthNightMap = texture(earthNightTexture);
    const earthSpecMap = texture(earthSpecularTexture);

    earthMaterial.colorNode = earthDayMap;
    earthMaterial.roughnessNode = float(0.9);
    earthMaterial.metalnessNode = float(0.0);

    // Ocean specularity - water reflects more
    earthMaterial.roughnessNode = Fn(() => {
      const spec = earthSpecMap.r;
      // Where there's water (specular map is bright), make it smoother
      return mix(float(0.9), float(0.3), spec);
    })();

    // Night lights on dark side
    earthMaterial.emissiveNode = Fn(() => {
      // Fresnel atmosphere glow
      const viewDir = normalize(cameraPosition.sub(positionWorld));
      const NdotV = max(dot(normalWorld, viewDir), 0.0);
      const fresnel = pow(float(1.0).sub(NdotV), 3.0);
      const atmosphereColor = vec3(0.3, 0.6, 1.0);
      const atmosphere = atmosphereColor.mul(fresnel).mul(0.2);

      // Night lights disabled - only dynamic blinking lights will be visible
      // const sunDir = normalize(vec3(-5, 2, -8));
      // const NdotL = dot(normalWorld, sunDir);
      // const nightSide = float(1.0).sub(NdotL.mul(0.5).add(0.5)).pow(3.0);
      // const nightLights = earthNightMap.rgb.mul(nightSide).mul(1.5);

      return atmosphere; // Only atmosphere glow, no static city lights
    })();

    const earth = new THREE.Mesh(earthGeometry, earthMaterial);
    earth.rotation.y = 0.5; // Initial rotation to show Europe/Africa/Asia with dense city lights
    scene.add(earth);

    // Clouds layer
    const cloudsGeometry = new THREE.SphereGeometry(2.01, 64, 64);
    const cloudsMaterial = new THREE.MeshStandardNodeMaterial({
      transparent: true
    });

    const earthCloudsMap = texture(earthCloudsTexture);
    cloudsMaterial.colorNode = vec4(1, 1, 1, 1);
    cloudsMaterial.opacityNode = earthCloudsMap.a.mul(0.4);
    cloudsMaterial.roughnessNode = float(1.0);
    cloudsMaterial.metalnessNode = float(0.0);

    const clouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
    clouds.rotation.y = 0.5; // Match Earth's initial rotation
    scene.add(clouds);

    // Animation loop
    async function init() {
      await renderer.init();

      // Load the night lights texture and create city lights BEFORE starting animation
      console.log('Loading night lights texture...');
      const nightLightsImage = await loadImage('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_lights_2048.png');
      console.log('Night lights texture loaded, creating city lights...');
      createCityLights(nightLightsImage);
      console.log('City lights ready, starting animation');

      animate();
    }

    function animate() {
      requestAnimationFrame(animate);

      const t = performance.now() * 0.001;

      // Rotate Earth
      earth.rotation.y = t * 0.1;

      // Rotate clouds slightly faster for realism
      clouds.rotation.y = t * 0.12;

      controls.update();
      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
  </script>
</body>
</html>
