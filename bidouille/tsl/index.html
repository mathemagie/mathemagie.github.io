<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Earth & Satellite - TSL</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.webgpu.min.js",
      "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.webgpu.min.js",
      "three/tsl": "https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.tsl.min.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three/webgpu';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import {
      Fn, vec3, vec4, float, uniform, time,
      positionLocal, normalWorld, normalLocal, uv,
      mix, pow, dot, normalize, max, sin, cos,
      cameraPosition, positionWorld, texture
    } from 'three/tsl';

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 5, 15);

    const renderer = new THREE.WebGPURenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 1);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 2);
    sunLight.position.set(5, 3, 5);
    scene.add(sunLight);

    // Stars background
    const starsGeometry = new THREE.BufferGeometry();
    const starCount = 5000;
    const positions = new Float32Array(starCount * 3);

    for (let i = 0; i < starCount * 3; i += 3) {
      const radius = 100 + Math.random() * 400;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;

      positions[i] = radius * Math.sin(phi) * Math.cos(theta);
      positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
      positions[i + 2] = radius * Math.cos(phi);
    }

    starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    const starsMaterial = new THREE.PointsNodeMaterial({
      colorNode: vec4(1, 1, 1, 1),
      sizeNode: float(2),
      transparent: true
    });

    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    // Load textures
    const textureLoader = new THREE.TextureLoader();

    // Earth textures from NASA
    const earthDayTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg');
    const earthNightTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_lights_2048.png');
    const earthSpecularTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_specular_2048.jpg');
    const earthCloudsTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png');

    // Earth
    const earthGeometry = new THREE.SphereGeometry(2, 128, 128);
    const earthMaterial = new THREE.MeshStandardNodeMaterial();

    // Day/night Earth with specular oceans
    const earthDayMap = texture(earthDayTexture);
    const earthNightMap = texture(earthNightTexture);
    const earthSpecMap = texture(earthSpecularTexture);

    earthMaterial.colorNode = earthDayMap;
    earthMaterial.roughnessNode = float(0.9);
    earthMaterial.metalnessNode = float(0.0);

    // Ocean specularity - water reflects more
    earthMaterial.roughnessNode = Fn(() => {
      const spec = earthSpecMap.r;
      // Where there's water (specular map is bright), make it smoother
      return mix(float(0.9), float(0.3), spec);
    })();

    // Night lights on dark side
    earthMaterial.emissiveNode = Fn(() => {
      // Fresnel atmosphere glow
      const viewDir = normalize(cameraPosition.sub(positionWorld));
      const NdotV = max(dot(normalWorld, viewDir), 0.0);
      const fresnel = pow(float(1.0).sub(NdotV), 3.0);
      const atmosphereColor = vec3(0.3, 0.6, 1.0);
      const atmosphere = atmosphereColor.mul(fresnel).mul(0.2);

      // Night lights based on lighting
      const sunDir = normalize(vec3(5, 3, 5));
      const NdotL = dot(normalWorld, sunDir);
      const nightSide = float(1.0).sub(NdotL.mul(0.5).add(0.5)).pow(3.0);
      const nightLights = earthNightMap.rgb.mul(nightSide).mul(1.5);

      return atmosphere.add(nightLights);
    })();

    const earth = new THREE.Mesh(earthGeometry, earthMaterial);
    scene.add(earth);

    // Clouds layer
    const cloudsGeometry = new THREE.SphereGeometry(2.01, 64, 64);
    const cloudsMaterial = new THREE.MeshStandardNodeMaterial({
      transparent: true
    });

    const earthCloudsMap = texture(earthCloudsTexture);
    cloudsMaterial.colorNode = vec4(1, 1, 1, 1);
    cloudsMaterial.opacityNode = earthCloudsMap.a.mul(0.4);
    cloudsMaterial.roughnessNode = float(1.0);
    cloudsMaterial.metalnessNode = float(0.0);

    const clouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
    scene.add(clouds);

    // ISS Satellite (using sprite so it always faces camera)
    const issTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/sprite0.png');

    const issNodeMaterial = new THREE.SpriteNodeMaterial();
    issNodeMaterial.colorNode = Fn(() => {
      const issMap = texture(issTexture, uv());
      return issMap;
    })();

    // Add slight pulsing glow
    issNodeMaterial.emissiveNode = Fn(() => {
      const pulse = sin(time.mul(2.0)).mul(0.3).add(0.7);
      return vec3(1.0, 1.0, 1.0).mul(pulse).mul(0.1);
    })();

    const satellite = new THREE.Sprite(issNodeMaterial);
    satellite.scale.set(0.8, 0.8, 1);
    scene.add(satellite);

    // Satellite orbit parameters
    const orbitRadius = 4.5;
    const orbitSpeed = 0.5;
    const orbitTilt = 0.3; // radians

    // Orbit visualization
    const orbitPoints = [];
    const orbitSegments = 128;
    for (let i = 0; i <= orbitSegments; i++) {
      const angle = (i / orbitSegments) * Math.PI * 2;
      const x = Math.cos(angle) * orbitRadius;
      const y = Math.sin(angle) * orbitRadius * Math.sin(orbitTilt);
      const z = Math.sin(angle) * orbitRadius * Math.cos(orbitTilt);
      orbitPoints.push(new THREE.Vector3(x, y, z));
    }

    const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
    const orbitMaterial = new THREE.LineBasicNodeMaterial({
      colorNode: vec4(0.5, 0.5, 0.8, 0.3),
      transparent: true
    });
    const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
    scene.add(orbitLine);

    // Animation loop
    async function init() {
      await renderer.init();
      animate();
    }

    function animate() {
      requestAnimationFrame(animate);

      const t = performance.now() * 0.001;

      // Rotate Earth
      earth.rotation.y = t * 0.1;

      // Rotate clouds slightly faster for realism
      clouds.rotation.y = t * 0.12;

      // Move satellite in orbit
      const orbitAngle = t * orbitSpeed;
      satellite.position.x = Math.cos(orbitAngle) * orbitRadius;
      satellite.position.y = Math.sin(orbitAngle) * orbitRadius * Math.sin(orbitTilt);
      satellite.position.z = Math.sin(orbitAngle) * orbitRadius * Math.cos(orbitTilt);

      controls.update();
      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
  </script>
</body>
</html>
