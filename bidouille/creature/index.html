<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>lueur des abysses</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #000;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<script>
let t = 0;
let cx, cy;
let vx = 0, vy = 0;
let heading = 0;
let speed = 0;
let targetSpeed = 1.2;
let noiseOff = 0;
let pauseTimer = 0;
let creatureRadius = 200;
let margin;
let swayOffset = 0;

// --- Paysage sonore abyssal du cténophore ---
let audioCtx, audioStarted = false;
let masterGain;
// Eau profonde — ambiance hydrophone abyssale
let deepNoiseNode, deepNoiseGain, deepFilter;
// Pulsation des cils — battement rythmique filtré
let ciliaNoiseNode, ciliaGain, ciliaFilter;
// Résonance corporelle — vibration de la masse gélatineuse
let bodyOsc, bodyGain;
// Clics organiques — micro-impulsions biologiques
let clickTimer = 0;

function createNoiseBuffer() {
  let bufferSize = audioCtx.sampleRate * 2;
  let buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  let data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = Math.random() * 2 - 1;
  }
  return buffer;
}

function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.15;
  masterGain.connect(audioCtx.destination);

  let noiseBuf = createNoiseBuffer();

  // --- Eau profonde : bruit très grave, filtré passe-bas ---
  // Simule l'ambiance hydrophone des abysses (~5-80 Hz)
  deepNoiseNode = audioCtx.createBufferSource();
  deepNoiseNode.buffer = noiseBuf;
  deepNoiseNode.loop = true;
  deepFilter = audioCtx.createBiquadFilter();
  deepFilter.type = 'lowpass';
  deepFilter.frequency.value = 60;
  deepFilter.Q.value = 3;
  deepNoiseGain = audioCtx.createGain();
  deepNoiseGain.gain.value = 0.5;
  deepNoiseNode.connect(deepFilter);
  deepFilter.connect(deepNoiseGain);
  deepNoiseGain.connect(masterGain);
  deepNoiseNode.start();

  // --- Pulsation des cils : bruit bandpass pulsé ---
  // Simule le battement des 8 rangées de cils du cténophore
  ciliaNoiseNode = audioCtx.createBufferSource();
  ciliaNoiseNode.buffer = noiseBuf;
  ciliaNoiseNode.loop = true;
  ciliaFilter = audioCtx.createBiquadFilter();
  ciliaFilter.type = 'bandpass';
  ciliaFilter.frequency.value = 300;
  ciliaFilter.Q.value = 8;
  ciliaGain = audioCtx.createGain();
  ciliaGain.gain.value = 0;
  ciliaNoiseNode.connect(ciliaFilter);
  ciliaFilter.connect(ciliaGain);
  ciliaGain.connect(masterGain);
  ciliaNoiseNode.start();

  // --- Résonance corporelle : sinusoïde très grave ---
  // Vibration de la masse gélatineuse, suit le mouvement
  bodyOsc = audioCtx.createOscillator();
  bodyOsc.type = 'sine';
  bodyOsc.frequency.value = 38;
  bodyGain = audioCtx.createGain();
  bodyGain.gain.value = 0;
  bodyOsc.connect(bodyGain);
  bodyGain.connect(masterGain);
  bodyOsc.start();

  audioStarted = true;
}

function triggerClick() {
  // Micro-impulsion : simule les clics biologiques sous-marins
  // (crevettes pistolet, craquements organiques captés par hydrophone)
  let clickOsc = audioCtx.createOscillator();
  clickOsc.type = 'sine';
  clickOsc.frequency.value = 800 + Math.random() * 2000;
  let clickGain = audioCtx.createGain();
  let clickFilter = audioCtx.createBiquadFilter();
  clickFilter.type = 'bandpass';
  clickFilter.frequency.value = 1200 + Math.random() * 800;
  clickFilter.Q.value = 15;
  clickOsc.connect(clickFilter);
  clickFilter.connect(clickGain);
  clickGain.connect(masterGain);

  let now = audioCtx.currentTime;
  clickGain.gain.setValueAtTime(0, now);
  clickGain.gain.linearRampToValueAtTime(0.06 + Math.random() * 0.04, now + 0.002);
  clickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.03 + Math.random() * 0.04);

  clickOsc.start(now);
  clickOsc.stop(now + 0.08);
}

function updateAudio(pulse, spd) {
  if (!audioStarted) return;
  let now = audioCtx.currentTime;

  // Eau profonde — le filtre s'ouvre légèrement quand la créature bouge
  let deepFreq = 50 + spd * 30 + Math.sin(t * 0.08) * 15;
  deepFilter.frequency.linearRampToValueAtTime(deepFreq, now + 0.2);
  deepNoiseGain.gain.linearRampToValueAtTime(0.35 + Math.sin(t * 0.12) * 0.1, now + 0.2);

  // Pulsation des cils — gain modulé par la respiration de la créature
  // Le son apparait et disparait rythmiquement, comme les battements de cils
  let ciliaPulse = Math.pow(Math.max(0, Math.sin(t * 0.8)), 3) * 0.25;
  ciliaGain.gain.linearRampToValueAtTime(ciliaPulse, now + 0.05);
  // La fréquence des cils varie avec la vitesse
  ciliaFilter.frequency.linearRampToValueAtTime(250 + spd * 200, now + 0.1);

  // Résonance corporelle — suit le mouvement, pulse avec la respiration
  let bodyVol = (0.08 + spd * 0.12) * pulse;
  bodyGain.gain.linearRampToValueAtTime(bodyVol, now + 0.15);
  // Fréquence dérive très lentement (masse gélatineuse qui vibre)
  bodyOsc.frequency.linearRampToValueAtTime(35 + Math.sin(t * 0.1) * 6 + spd * 8, now + 0.2);

  // Clics organiques — déclenchés aléatoirement, plus fréquents quand la créature bouge
  clickTimer--;
  if (clickTimer <= 0) {
    triggerClick();
    // Intervalle aléatoire : 15-90 frames (plus fréquent si rapide)
    clickTimer = Math.floor(15 + Math.random() * 75 * (1 - Math.min(spd, 1.5) / 2));
  }
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 255);
  cx = random(creatureRadius, width - creatureRadius);
  cy = random(creatureRadius, height - creatureRadius);
  heading = random(TWO_PI);
  margin = creatureRadius + 40;
}

function organism(x, y, pulse) {
  let k = 5 * cos(x / 14) * cos(y / 30);
  let e = y / 8 - 13;

  let d = pow(mag(k, e), 2) / 59 + 4;

  let angleTerm = atan2(k, e);
  let q = 60 - 3 * sin(angleTerm * e);

  let wave = k * (3 + 4 / d * sin(d * d - t * 2));

  let c = d / 2 + e / 99 - t / 18;

  let s = 2;
  let xCoord = (q + wave) * s * sin(c) + cx;
  let yCoord = (q + d * 9) * s * cos(c) + cy;

  // Couleur organique — varie selon la profondeur, position et temps
  // Cœur chaud (vert-doré ~90°) vers périphérie froide (bleu profond ~210°)
  let baseHue = map(d, 4, 15, 100, 210);
  // Variation Perlin par zone — chaque partie pulse sa propre teinte
  let hueNoise = noise(x * 0.05, y * 0.05, t * 0.02) * 40 - 20;
  // Ondulation temporelle lente
  let hueWave = 15 * sin(t * 0.3 + d * 0.5 + c * 0.2);
  let hue = baseHue + hueNoise + hueWave;

  // Saturation plus riche au cœur, plus pâle aux extrémités
  let sat = map(d, 4, 15, 60, 90);
  let brightness = map(d, 4, 15, 100, 55);
  let a = pulse * map(d, 4, 15, 180, 50);

  stroke(hue, sat, brightness, a);
  point(xCoord, yCoord);
}

function mousePressed() {
  if (!audioStarted) initAudio();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function draw() {
  t += PI / 20;
  noiseOff += 0.003;

  // Pause — la créature ralentit mais dérive encore (jamais immobile)
  if (pauseTimer > 0) {
    pauseTimer--;
    targetSpeed = 0.15; // dérive lente au lieu d'arrêt total
    if (pauseTimer <= 0) {
      targetSpeed = random(0.6, 1.8);
    }
  } else if (random() < 0.002) {
    pauseTimer = floor(random(60, 180));
  }

  // Vitesse — Perlin noise pour des accélérations/décélérations organiques
  let speedNoise = noise(noiseOff * 1.5 + 100);
  let desiredSpeed = targetSpeed * map(speedNoise, 0, 1, 0.4, 1.4);
  speed = lerp(speed, desiredSpeed, 0.015);

  // Direction — deux couches de Perlin à fréquences différentes
  // Couche lente : grandes courbes (comme suivre un courant)
  let slowTurn = (noise(noiseOff * 0.7) - 0.5) * 0.04;
  // Couche rapide : micro-corrections (comme des nageoires)
  let fastTurn = (noise(noiseOff * 3 + 50) - 0.5) * 0.03;
  heading += slowTurn + fastTurn;

  // Ondulation latérale — la créature oscille perpendiculairement à sa direction
  swayOffset = sin(t * 0.6) * 0.8 + sin(t * 1.1) * 0.3;
  let swayX = cos(heading + HALF_PI) * swayOffset;
  let swayY = sin(heading + HALF_PI) * swayOffset;

  // Courant ambiant — un champ de force Perlin global pousse doucement
  let currentAngle = noise(cx * 0.001, cy * 0.001, t * 0.01) * TWO_PI * 2;
  let currentStrength = 0.15;

  // Vélocité = direction + ondulation + courant
  vx = cos(heading) * speed + swayX + cos(currentAngle) * currentStrength;
  vy = sin(heading) * speed + swayY + sin(currentAngle) * currentStrength;
  cx += vx;
  cy += vy;

  // Bords — force de répulsion progressive (pas de lerp sur angles)
  let repelForce = 0;
  let repelAngle = 0;
  let centerX = width / 2;
  let centerY = height / 2;

  if (cx < margin) { repelForce = map(cx, 0, margin, 0.12, 0); repelAngle = 0; }
  if (cx > width - margin) { repelForce = map(cx, width, width - margin, 0.12, 0); repelAngle = PI; }
  if (cy < margin) { repelForce = max(repelForce, map(cy, 0, margin, 0.12, 0)); repelAngle = HALF_PI; }
  if (cy > height - margin) { repelForce = max(repelForce, map(cy, height, height - margin, 0.12, 0)); repelAngle = -HALF_PI; }

  if (repelForce > 0) {
    // Appliquer la force directement sur la vélocité (pas sur l'angle)
    cx += cos(repelAngle) * repelForce * 3;
    cy += sin(repelAngle) * repelForce * 3;
    // Tourner doucement vers le centre
    let toCenter = atan2(centerY - cy, centerX - cx);
    let angleDiff = toCenter - heading;
    // Normaliser l'angle pour toujours prendre le chemin le plus court
    angleDiff = atan2(sin(angleDiff), cos(angleDiff));
    heading += angleDiff * repelForce;
    speed *= (1 - repelForce * 0.5);
  }

  // Sécurité : ne jamais sortir de l'écran
  cx = constrain(cx, creatureRadius, width - creatureRadius);
  cy = constrain(cy, creatureRadius, height - creatureRadius);

  // Traînée lumineuse avec blend normal
  blendMode(BLEND);
  noStroke();
  fill(0, 0, 0, 40);
  rect(0, 0, width, height);

  // Pulse de luminosité — respiration lumineuse
  let pulse = map(sin(t * 0.4), -1, 1, 0.7, 1.0);

  // Une seule passe — blendMode(ADD) crée le glow naturellement :
  // les zones denses s'additionnent et brillent plus fort
  blendMode(ADD);
  strokeWeight(1.5);
  for (let i = 0; i < 10000; i++) {
    let x = i % 80;
    let y = i / 43;
    organism(x, y, pulse);
  }
  blendMode(BLEND);

  // Synchroniser le son avec l'état de la créature
  updateAudio(pulse, speed);
}
</script>
</body>
</html>
