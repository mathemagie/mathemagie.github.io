<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>créature</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #000;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<script>
let t = 0;
let cx, cy;
let vx = 0, vy = 0;
let heading = 0;
let speed = 0;
let targetSpeed = 1.2;
let noiseOff = 0;
let pauseTimer = 0;
let creatureRadius = 200;
let margin;
let swayOffset = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 255);
  cx = random(creatureRadius, width - creatureRadius);
  cy = random(creatureRadius, height - creatureRadius);
  heading = random(TWO_PI);
  margin = creatureRadius + 40;
}

function organism(x, y, pulse) {
  let k = 5 * cos(x / 14) * cos(y / 30);
  let e = y / 8 - 13;

  let d = pow(mag(k, e), 2) / 59 + 4;

  let angleTerm = atan2(k, e);
  let q = 60 - 3 * sin(angleTerm * e);

  let wave = k * (3 + 4 / d * sin(d * d - t * 2));

  let c = d / 2 + e / 99 - t / 18;

  let s = 2;
  let xCoord = (q + wave) * s * sin(c) + cx;
  let yCoord = (q + d * 9) * s * cos(c) + cy;

  // Couleur organique — varie selon la profondeur, position et temps
  // Cœur chaud (vert-doré ~90°) vers périphérie froide (bleu profond ~210°)
  let baseHue = map(d, 4, 15, 100, 210);
  // Variation Perlin par zone — chaque partie pulse sa propre teinte
  let hueNoise = noise(x * 0.05, y * 0.05, t * 0.02) * 40 - 20;
  // Ondulation temporelle lente
  let hueWave = 15 * sin(t * 0.3 + d * 0.5 + c * 0.2);
  let hue = baseHue + hueNoise + hueWave;

  // Saturation plus riche au cœur, plus pâle aux extrémités
  let sat = map(d, 4, 15, 60, 90);
  let brightness = map(d, 4, 15, 100, 55);
  let a = pulse * map(d, 4, 15, 180, 50);

  stroke(hue, sat, brightness, a);
  point(xCoord, yCoord);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function draw() {
  t += PI / 20;
  noiseOff += 0.003;

  // Pause — la créature ralentit mais dérive encore (jamais immobile)
  if (pauseTimer > 0) {
    pauseTimer--;
    targetSpeed = 0.15; // dérive lente au lieu d'arrêt total
    if (pauseTimer <= 0) {
      targetSpeed = random(0.6, 1.8);
    }
  } else if (random() < 0.002) {
    pauseTimer = floor(random(60, 180));
  }

  // Vitesse — Perlin noise pour des accélérations/décélérations organiques
  let speedNoise = noise(noiseOff * 1.5 + 100);
  let desiredSpeed = targetSpeed * map(speedNoise, 0, 1, 0.4, 1.4);
  speed = lerp(speed, desiredSpeed, 0.015);

  // Direction — deux couches de Perlin à fréquences différentes
  // Couche lente : grandes courbes (comme suivre un courant)
  let slowTurn = (noise(noiseOff * 0.7) - 0.5) * 0.04;
  // Couche rapide : micro-corrections (comme des nageoires)
  let fastTurn = (noise(noiseOff * 3 + 50) - 0.5) * 0.03;
  heading += slowTurn + fastTurn;

  // Ondulation latérale — la créature oscille perpendiculairement à sa direction
  swayOffset = sin(t * 0.6) * 0.8 + sin(t * 1.1) * 0.3;
  let swayX = cos(heading + HALF_PI) * swayOffset;
  let swayY = sin(heading + HALF_PI) * swayOffset;

  // Courant ambiant — un champ de force Perlin global pousse doucement
  let currentAngle = noise(cx * 0.001, cy * 0.001, t * 0.01) * TWO_PI * 2;
  let currentStrength = 0.15;

  // Vélocité = direction + ondulation + courant
  vx = cos(heading) * speed + swayX + cos(currentAngle) * currentStrength;
  vy = sin(heading) * speed + swayY + sin(currentAngle) * currentStrength;
  cx += vx;
  cy += vy;

  // Bords — force de répulsion progressive (pas de lerp sur angles)
  let repelForce = 0;
  let repelAngle = 0;
  let centerX = width / 2;
  let centerY = height / 2;

  if (cx < margin) { repelForce = map(cx, 0, margin, 0.12, 0); repelAngle = 0; }
  if (cx > width - margin) { repelForce = map(cx, width, width - margin, 0.12, 0); repelAngle = PI; }
  if (cy < margin) { repelForce = max(repelForce, map(cy, 0, margin, 0.12, 0)); repelAngle = HALF_PI; }
  if (cy > height - margin) { repelForce = max(repelForce, map(cy, height, height - margin, 0.12, 0)); repelAngle = -HALF_PI; }

  if (repelForce > 0) {
    // Appliquer la force directement sur la vélocité (pas sur l'angle)
    cx += cos(repelAngle) * repelForce * 3;
    cy += sin(repelAngle) * repelForce * 3;
    // Tourner doucement vers le centre
    let toCenter = atan2(centerY - cy, centerX - cx);
    let angleDiff = toCenter - heading;
    // Normaliser l'angle pour toujours prendre le chemin le plus court
    angleDiff = atan2(sin(angleDiff), cos(angleDiff));
    heading += angleDiff * repelForce;
    speed *= (1 - repelForce * 0.5);
  }

  // Sécurité : ne jamais sortir de l'écran
  cx = constrain(cx, creatureRadius, width - creatureRadius);
  cy = constrain(cy, creatureRadius, height - creatureRadius);

  // Traînée lumineuse avec blend normal
  blendMode(BLEND);
  noStroke();
  fill(0, 0, 0, 40);
  rect(0, 0, width, height);

  // Pulse de luminosité — respiration lumineuse
  let pulse = map(sin(t * 0.4), -1, 1, 0.7, 1.0);

  // Une seule passe — blendMode(ADD) crée le glow naturellement :
  // les zones denses s'additionnent et brillent plus fort
  blendMode(ADD);
  strokeWeight(1.5);
  for (let i = 0; i < 10000; i++) {
    let x = i % 80;
    let y = i / 43;
    organism(x, y, pulse);
  }
  blendMode(BLEND);
}
</script>
</body>
</html>
