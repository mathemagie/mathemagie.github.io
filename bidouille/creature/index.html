<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>lueur des abysses</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #000;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    #hud {
      position: fixed;
      top: 16px;
      right: 16px;
      width: 260px;
      background: rgba(0, 0, 0, 0.75);
      border: 1px solid rgba(100, 220, 255, 0.15);
      border-radius: 8px;
      padding: 16px;
      font-family: monospace;
      font-size: 11px;
      color: rgba(140, 220, 240, 0.9);
      z-index: 10;
      display: none;
      backdrop-filter: blur(6px);
      user-select: none;
    }
    #hud.visible { display: block; }
    #hud h3 {
      margin: 0 0 10px 0;
      font-size: 12px;
      color: rgba(140, 220, 240, 0.5);
      text-transform: uppercase;
      letter-spacing: 2px;
      border-bottom: 1px solid rgba(100, 220, 255, 0.1);
      padding-bottom: 6px;
    }
    #hud label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 6px 0 2px 0;
    }
    #hud label span { opacity: 0.6; }
    #hud input[type="range"] {
      width: 100%;
      height: 3px;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(100, 220, 255, 0.15);
      border-radius: 2px;
      outline: none;
      margin: 2px 0 8px 0;
    }
    #hud input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: rgba(120, 220, 255, 0.7);
      cursor: pointer;
    }
    #hud .section { margin-top: 12px; }
    #hint {
      position: fixed;
      bottom: 12px;
      right: 16px;
      font-family: monospace;
      font-size: 10px;
      color: rgba(140, 220, 240, 0.25);
      z-index: 10;
    }
  </style>
</head>
<body>
<div id="hud">
  <h3>visuel</h3>
  <label>taille <span id="v_scale">2.0</span></label>
  <input type="range" id="s_scale" min="0.5" max="5" step="0.1" value="2">
  <label>densit&eacute; <span id="v_density">10000</span></label>
  <input type="range" id="s_density" min="2000" max="20000" step="500" value="10000">
  <label>tra&icirc;n&eacute;e <span id="v_trail">40</span></label>
  <input type="range" id="s_trail" min="5" max="120" step="1" value="40">
  <label>&eacute;paisseur <span id="v_weight">1.5</span></label>
  <input type="range" id="s_weight" min="0.3" max="4" step="0.1" value="1.5">

  <div class="section">
    <h3>mouvement</h3>
    <label>vitesse max <span id="v_speed">1.8</span></label>
    <input type="range" id="s_speed" min="0.2" max="4" step="0.1" value="1.8">
    <label>ondulation <span id="v_sway">1.0</span></label>
    <input type="range" id="s_sway" min="0" max="3" step="0.1" value="1">
    <label>courant <span id="v_current">0.15</span></label>
    <input type="range" id="s_current" min="0" max="0.6" step="0.01" value="0.15">
  </div>

  <div class="section">
    <h3>audio</h3>
    <label>volume <span id="v_vol">15</span>%</label>
    <input type="range" id="s_vol" min="0" max="50" step="1" value="15">
  </div>
</div>
<div id="hint">[H] param&egrave;tres</div>
<script>
let t = 0;
let cx, cy;
let vx = 0, vy = 0;
let heading = 0;
let speed = 0;
let targetSpeed = 1.2;
let noiseOff = 0;
let pauseTimer = 0;
let creatureRadius = 200;
let margin;
let swayOffset = 0;

// --- Paramètres contrôlables via HUD ---
let params = {
  scale: 2, density: 10000, trail: 40, weight: 1.5,
  maxSpeed: 1.8, sway: 1, current: 0.15, volume: 15
};
let hudVisible = false;

function readHUD() {
  params.scale   = parseFloat(document.getElementById('s_scale').value);
  params.density = parseInt(document.getElementById('s_density').value);
  params.trail   = parseInt(document.getElementById('s_trail').value);
  params.weight  = parseFloat(document.getElementById('s_weight').value);
  params.maxSpeed = parseFloat(document.getElementById('s_speed').value);
  params.sway    = parseFloat(document.getElementById('s_sway').value);
  params.current = parseFloat(document.getElementById('s_current').value);
  params.volume  = parseInt(document.getElementById('s_vol').value);

  document.getElementById('v_scale').textContent   = params.scale.toFixed(1);
  document.getElementById('v_density').textContent  = params.density;
  document.getElementById('v_trail').textContent    = params.trail;
  document.getElementById('v_weight').textContent   = params.weight.toFixed(1);
  document.getElementById('v_speed').textContent    = params.maxSpeed.toFixed(1);
  document.getElementById('v_sway').textContent     = params.sway.toFixed(1);
  document.getElementById('v_current').textContent  = params.current.toFixed(2);
  document.getElementById('v_vol').textContent      = params.volume;

  if (audioStarted) {
    masterGain.gain.linearRampToValueAtTime(params.volume / 100, audioCtx.currentTime + 0.1);
  }
}

// --- Paysage sonore abyssal du cténophore ---
let audioCtx, audioStarted = false;
let masterGain;
// Eau profonde — ambiance hydrophone abyssale
let deepNoiseNode, deepNoiseGain, deepFilter;
// Pulsation des cils — battement rythmique filtré
let ciliaNoiseNode, ciliaGain, ciliaFilter;
// Résonance corporelle — vibration de la masse gélatineuse
let bodyOsc, bodyGain;
// Clics organiques — micro-impulsions biologiques
let clickTimer = 0;

function createNoiseBuffer() {
  let bufferSize = audioCtx.sampleRate * 2;
  let buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  let data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = Math.random() * 2 - 1;
  }
  return buffer;
}

function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.15;
  masterGain.connect(audioCtx.destination);

  let noiseBuf = createNoiseBuffer();

  // --- Eau profonde : bruit très grave, filtré passe-bas ---
  // Simule l'ambiance hydrophone des abysses (~5-80 Hz)
  deepNoiseNode = audioCtx.createBufferSource();
  deepNoiseNode.buffer = noiseBuf;
  deepNoiseNode.loop = true;
  deepFilter = audioCtx.createBiquadFilter();
  deepFilter.type = 'lowpass';
  deepFilter.frequency.value = 60;
  deepFilter.Q.value = 3;
  deepNoiseGain = audioCtx.createGain();
  deepNoiseGain.gain.value = 0.5;
  deepNoiseNode.connect(deepFilter);
  deepFilter.connect(deepNoiseGain);
  deepNoiseGain.connect(masterGain);
  deepNoiseNode.start();

  // --- Pulsation des cils : bruit bandpass pulsé ---
  // Simule le battement des 8 rangées de cils du cténophore
  ciliaNoiseNode = audioCtx.createBufferSource();
  ciliaNoiseNode.buffer = noiseBuf;
  ciliaNoiseNode.loop = true;
  ciliaFilter = audioCtx.createBiquadFilter();
  ciliaFilter.type = 'bandpass';
  ciliaFilter.frequency.value = 300;
  ciliaFilter.Q.value = 8;
  ciliaGain = audioCtx.createGain();
  ciliaGain.gain.value = 0;
  ciliaNoiseNode.connect(ciliaFilter);
  ciliaFilter.connect(ciliaGain);
  ciliaGain.connect(masterGain);
  ciliaNoiseNode.start();

  // --- Résonance corporelle : sinusoïde très grave ---
  // Vibration de la masse gélatineuse, suit le mouvement
  bodyOsc = audioCtx.createOscillator();
  bodyOsc.type = 'sine';
  bodyOsc.frequency.value = 38;
  bodyGain = audioCtx.createGain();
  bodyGain.gain.value = 0;
  bodyOsc.connect(bodyGain);
  bodyGain.connect(masterGain);
  bodyOsc.start();

  audioStarted = true;
}

function triggerClick() {
  // Micro-impulsion : simule les clics biologiques sous-marins
  // (crevettes pistolet, craquements organiques captés par hydrophone)
  let clickOsc = audioCtx.createOscillator();
  clickOsc.type = 'sine';
  clickOsc.frequency.value = 800 + Math.random() * 2000;
  let clickGain = audioCtx.createGain();
  let clickFilter = audioCtx.createBiquadFilter();
  clickFilter.type = 'bandpass';
  clickFilter.frequency.value = 1200 + Math.random() * 800;
  clickFilter.Q.value = 15;
  clickOsc.connect(clickFilter);
  clickFilter.connect(clickGain);
  clickGain.connect(masterGain);

  let now = audioCtx.currentTime;
  clickGain.gain.setValueAtTime(0, now);
  clickGain.gain.linearRampToValueAtTime(0.06 + Math.random() * 0.04, now + 0.002);
  clickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.03 + Math.random() * 0.04);

  clickOsc.start(now);
  clickOsc.stop(now + 0.08);
}

function updateAudio(pulse, spd) {
  if (!audioStarted) return;
  let now = audioCtx.currentTime;

  // Eau profonde — le filtre s'ouvre légèrement quand la créature bouge
  let deepFreq = 50 + spd * 30 + Math.sin(t * 0.08) * 15;
  deepFilter.frequency.linearRampToValueAtTime(deepFreq, now + 0.2);
  deepNoiseGain.gain.linearRampToValueAtTime(0.35 + Math.sin(t * 0.12) * 0.1, now + 0.2);

  // Pulsation des cils — gain modulé par la respiration de la créature
  // Le son apparait et disparait rythmiquement, comme les battements de cils
  let ciliaPulse = Math.pow(Math.max(0, Math.sin(t * 0.8)), 3) * 0.25;
  ciliaGain.gain.linearRampToValueAtTime(ciliaPulse, now + 0.05);
  // La fréquence des cils varie avec la vitesse
  ciliaFilter.frequency.linearRampToValueAtTime(250 + spd * 200, now + 0.1);

  // Résonance corporelle — suit le mouvement, pulse avec la respiration
  let bodyVol = (0.08 + spd * 0.12) * pulse;
  bodyGain.gain.linearRampToValueAtTime(bodyVol, now + 0.15);
  // Fréquence dérive très lentement (masse gélatineuse qui vibre)
  bodyOsc.frequency.linearRampToValueAtTime(35 + Math.sin(t * 0.1) * 6 + spd * 8, now + 0.2);

  // Clics organiques — déclenchés aléatoirement, plus fréquents quand la créature bouge
  clickTimer--;
  if (clickTimer <= 0) {
    triggerClick();
    // Intervalle aléatoire : 15-90 frames (plus fréquent si rapide)
    clickTimer = Math.floor(15 + Math.random() * 75 * (1 - Math.min(spd, 1.5) / 2));
  }
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 255);
  cx = random(creatureRadius, width - creatureRadius);
  cy = random(creatureRadius, height - creatureRadius);
  heading = random(TWO_PI);
  margin = creatureRadius + 40;
}

function organism(x, y, pulse) {
  let k = 5 * cos(x / 14) * cos(y / 30);
  let e = y / 8 - 13;

  let d = pow(mag(k, e), 2) / 59 + 4;

  let angleTerm = atan2(k, e);
  let q = 60 - 3 * sin(angleTerm * e);

  let wave = k * (3 + 4 / d * sin(d * d - t * 2));

  let c = d / 2 + e / 99 - t / 18;

  let xCoord = (q + wave) * params.scale * sin(c) + cx;
  let yCoord = (q + d * 9) * params.scale * cos(c) + cy;

  // Couleur organique — rouge profond au cœur, rouge sombre aux extrémités
  let baseHue = map(d, 4, 15, 0, 20);
  // Variation Perlin par zone — chaque partie pulse sa propre teinte
  let hueNoise = noise(x * 0.05, y * 0.05, t * 0.02) * 15 - 7;
  // Ondulation temporelle lente
  let hueWave = 8 * sin(t * 0.3 + d * 0.5 + c * 0.2);
  let hue = (baseHue + hueNoise + hueWave + 360) % 360;

  // Saturation riche
  let sat = map(d, 4, 15, 85, 95);
  let brightness = map(d, 4, 15, 100, 55);
  let a = pulse * map(d, 4, 15, 180, 50);

  stroke(hue, sat, brightness, a);
  point(xCoord, yCoord);
}

function mousePressed() {
  if (!audioStarted) initAudio();
}

function keyPressed() {
  if (key === 'h' || key === 'H') {
    hudVisible = !hudVisible;
    document.getElementById('hud').classList.toggle('visible', hudVisible);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function draw() {
  readHUD();
  t += PI / 20;
  noiseOff += 0.003;

  // Pause — la créature ralentit mais dérive encore (jamais immobile)
  if (pauseTimer > 0) {
    pauseTimer--;
    targetSpeed = 0.15;
    if (pauseTimer <= 0) {
      targetSpeed = random(0.6, params.maxSpeed);
    }
  } else if (random() < 0.002) {
    pauseTimer = floor(random(60, 180));
  }

  // Vitesse — Perlin noise pour des accélérations/décélérations organiques
  let speedNoise = noise(noiseOff * 1.5 + 100);
  let desiredSpeed = targetSpeed * map(speedNoise, 0, 1, 0.4, 1.4);
  speed = lerp(speed, desiredSpeed, 0.015);

  // Direction — deux couches de Perlin à fréquences différentes
  let slowTurn = (noise(noiseOff * 0.7) - 0.5) * 0.04;
  let fastTurn = (noise(noiseOff * 3 + 50) - 0.5) * 0.03;
  heading += slowTurn + fastTurn;

  // Ondulation latérale — amplitude contrôlable
  swayOffset = (sin(t * 0.6) * 0.8 + sin(t * 1.1) * 0.3) * params.sway;
  let swayX = cos(heading + HALF_PI) * swayOffset;
  let swayY = sin(heading + HALF_PI) * swayOffset;

  // Courant ambiant — force contrôlable
  let currentAngle = noise(cx * 0.001, cy * 0.001, t * 0.01) * TWO_PI * 2;
  let currentStrength = params.current;

  // Vélocité = direction + ondulation + courant
  vx = cos(heading) * speed + swayX + cos(currentAngle) * currentStrength;
  vy = sin(heading) * speed + swayY + sin(currentAngle) * currentStrength;
  cx += vx;
  cy += vy;

  // Bords — force de répulsion progressive (pas de lerp sur angles)
  let repelForce = 0;
  let repelAngle = 0;
  let centerX = width / 2;
  let centerY = height / 2;

  if (cx < margin) { repelForce = map(cx, 0, margin, 0.12, 0); repelAngle = 0; }
  if (cx > width - margin) { repelForce = map(cx, width, width - margin, 0.12, 0); repelAngle = PI; }
  if (cy < margin) { repelForce = max(repelForce, map(cy, 0, margin, 0.12, 0)); repelAngle = HALF_PI; }
  if (cy > height - margin) { repelForce = max(repelForce, map(cy, height, height - margin, 0.12, 0)); repelAngle = -HALF_PI; }

  if (repelForce > 0) {
    // Appliquer la force directement sur la vélocité (pas sur l'angle)
    cx += cos(repelAngle) * repelForce * 3;
    cy += sin(repelAngle) * repelForce * 3;
    // Tourner doucement vers le centre
    let toCenter = atan2(centerY - cy, centerX - cx);
    let angleDiff = toCenter - heading;
    // Normaliser l'angle pour toujours prendre le chemin le plus court
    angleDiff = atan2(sin(angleDiff), cos(angleDiff));
    heading += angleDiff * repelForce;
    speed *= (1 - repelForce * 0.5);
  }

  // Sécurité : ne jamais sortir de l'écran
  cx = constrain(cx, creatureRadius, width - creatureRadius);
  cy = constrain(cy, creatureRadius, height - creatureRadius);

  // Traînée lumineuse — opacité contrôlable
  blendMode(BLEND);
  noStroke();
  fill(0, 0, 0, params.trail);
  rect(0, 0, width, height);

  // Pulse de luminosité — respiration lumineuse
  let pulse = map(sin(t * 0.4), -1, 1, 0.7, 1.0);

  // Une seule passe — blendMode(ADD) crée le glow naturellement
  blendMode(ADD);
  strokeWeight(params.weight);
  for (let i = 0; i < params.density; i++) {
    let x = i % 80;
    let y = i / 43;
    organism(x, y, pulse);
  }
  blendMode(BLEND);

  // Synchroniser le son avec l'état de la créature
  updateAudio(pulse, speed);
}
</script>
</body>
</html>
