<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation Parapluie - Vue du Haut</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0F0F0F; /* Noir élégant pour effet dramatique */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        #sketch-container {
            /* Bordure et ombre retirées pour un look plus propre */
            cursor: pointer; /* Curseur pointer pour indiquer l'interactivité */
            transition: opacity 0.3s ease; /* Transition douce pour les effets */
        }

        .canvases-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, 100px);
            gap: 10px;
            justify-content: center;
            padding: 10px;
            max-width: 100vw;
            box-sizing: border-box;
        }

        .canvas-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100px;
            height: 100px;
        }

        .canvas-wrapper div[id^="sketch-container-"] {
            cursor: pointer;
            transition: opacity 0.3s ease;
        }

        .canvas-wrapper div[id^="sketch-container-"]:hover {
            opacity: 0.95;
        }
        .title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ecf0f1;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="canvases-container" class="canvases-container"></div>

    <!-- Enhanced Audio System for Umbrella Sounds -->
    <audio id="audio-open" preload="auto" muted playsinline style="display:none"></audio>
    <audio id="audio-close" preload="auto" muted playsinline style="display:none"></audio>

    <!-- Audio pool for multiple simultaneous sounds -->
    <audio id="audio-open-1" preload="auto" muted playsinline style="display:none"></audio>
    <audio id="audio-open-2" preload="auto" muted playsinline style="display:none"></audio>
    <audio id="audio-close-1" preload="auto" muted playsinline style="display:none"></audio>
    <audio id="audio-close-2" preload="auto" muted playsinline style="display:none"></audio>

    <script>
        // Advanced Web Audio Manager with synthesis and effects
        class UmbrellaAudioManager {
            constructor() {
                this.masterVolume = 0.4;
                this.audioContext = null;
                this.isInitialized = false;

                // Audio element pools
                this.openPool = [
                    document.getElementById('audio-open'),
                    document.getElementById('audio-open-1'),
                    document.getElementById('audio-open-2')
                ];
                this.closePool = [
                    document.getElementById('audio-close'),
                    document.getElementById('audio-close-1'),
                    document.getElementById('audio-close-2')
                ];

                this.currentOpenIndex = 0;
                this.currentCloseIndex = 0;
                this.lastPlayTime = 0;
                this.minPlayInterval = 150;

                // Web Audio nodes for effects
                this.masterGain = null;
                this.reverb = null;
                this.filter = null;
                this.spatialPanner = null;
            }

            async initializeWebAudio() {
                if (this.isInitialized) return true;

                try {
                    // Create audio context
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Create master gain node
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = this.masterVolume;
                    this.masterGain.connect(this.audioContext.destination);

                    // Create reverb effect
                    await this.createReverb();

                    // Create filter for sound shaping
                    this.filter = this.audioContext.createBiquadFilter();
                    this.filter.type = 'lowpass';
                    this.filter.frequency.value = 3000;
                    this.filter.Q.value = 1;
                    this.filter.connect(this.masterGain);

                    // Create spatial audio panner
                    this.spatialPanner = this.audioContext.createPanner();
                    this.spatialPanner.panningModel = 'HRTF';
                    this.spatialPanner.distanceModel = 'inverse';
                    this.spatialPanner.refDistance = 1;
                    this.spatialPanner.maxDistance = 1000;
                    this.spatialPanner.rolloffFactor = 1;
                    this.spatialPanner.coneInnerAngle = 360;
                    this.spatialPanner.coneOuterAngle = 0;
                    this.spatialPanner.coneOuterGain = 0;
                    this.spatialPanner.connect(this.filter);

                    this.isInitialized = true;
                    console.info('[WebAudio] Initialized successfully');
                    return true;

                } catch (error) {
                    console.warn('[WebAudio] Initialization failed:', error);
                    return false;
                }
            }

            async createReverb() {
                // Create a simple reverb effect
                this.reverb = this.audioContext.createConvolver();

                // Create impulse response for reverb
                const sampleRate = this.audioContext.sampleRate;
                const length = sampleRate * 2; // 2 second reverb
                const impulse = this.audioContext.createBuffer(2, length, sampleRate);

                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        // Create a decaying noise for reverb
                        const decay = Math.pow(1 - i / length, 2);
                        channelData[i] = (Math.random() * 2 - 1) * decay * 0.1;
                    }
                }

                this.reverb.buffer = impulse;
                this.reverb.connect(this.masterGain);
            }

            isReady() {
                return window.__audioUnlocked === true && window.__audioReady === true;
            }

            async playOpen(volume = 1.0, position = { x: 0, y: 0, z: 0 }) {
                if (!this.isReady()) return;

                const now = Date.now();
                if (now - this.lastPlayTime < this.minPlayInterval) return;

                // Initialize Web Audio if not already done
                if (!this.isInitialized) {
                    await this.initializeWebAudio();
                }

                const audio = this.openPool[this.currentOpenIndex];
                if (audio && audio.src) {
                    try {
                        // Set spatial position
                        this.spatialPanner.positionX.value = position.x;
                        this.spatialPanner.positionY.value = position.y;
                        this.spatialPanner.positionZ.value = position.z;

                        // Create Web Audio source from HTML5 audio
                        const source = this.audioContext.createMediaElementSource(audio);

                        // Apply effects chain
                        source.connect(this.spatialPanner);

                        // Add volume envelope for more natural sound
                        const envelopeGain = this.audioContext.createGain();
                        envelopeGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                        envelopeGain.gain.linearRampToValueAtTime(volume * this.masterVolume, this.audioContext.currentTime + 0.01);
                        envelopeGain.gain.exponentialRampToValueAtTime(volume * this.masterVolume * 0.3, this.audioContext.currentTime + 0.5);
                        envelopeGain.connect(this.spatialPanner);

                        source.connect(envelopeGain);

                        // Play the audio
                        audio.volume = 1; // Let Web Audio handle volume
                        audio.currentTime = 0;
                        audio.play();

                        // Clean up after sound ends
                        audio.onended = () => {
                            try {
                                source.disconnect();
                                envelopeGain.disconnect();
                            } catch(e) {}
                        };

                        this.currentOpenIndex = (this.currentOpenIndex + 1) % this.openPool.length;
                        this.lastPlayTime = now;

                    } catch(e) {
                        console.warn('WebAudio play failed, falling back to HTML5:', e);
                        // Fallback to simple HTML5 audio
                        audio.volume = this.masterVolume * volume;
                        audio.currentTime = 0;
                        audio.play();
                        this.currentOpenIndex = (this.currentOpenIndex + 1) % this.openPool.length;
                        this.lastPlayTime = now;
                    }
                }
            }

            async playClose(volume = 1.0, position = { x: 0, y: 0, z: 0 }) {
                if (!this.isReady()) return;

                const now = Date.now();
                if (now - this.lastPlayTime < this.minPlayInterval) return;

                // Initialize Web Audio if not already done
                if (!this.isInitialized) {
                    await this.initializeWebAudio();
                }

                const audio = this.closePool[this.currentCloseIndex];
                if (audio && audio.src) {
                    try {
                        // Set spatial position
                        this.spatialPanner.positionX.value = position.x;
                        this.spatialPanner.positionY.value = position.y;
                        this.spatialPanner.positionZ.value = position.z;

                        // Create Web Audio source from HTML5 audio
                        const source = this.audioContext.createMediaElementSource(audio);

                        // Apply effects chain
                        const envelopeGain = this.audioContext.createGain();
                        envelopeGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                        envelopeGain.gain.linearRampToValueAtTime(volume * this.masterVolume, this.audioContext.currentTime + 0.01);
                        envelopeGain.gain.exponentialRampToValueAtTime(volume * this.masterVolume * 0.2, this.audioContext.currentTime + 0.8);
                        envelopeGain.connect(this.spatialPanner);

                        source.connect(envelopeGain);

                        // Play the audio
                        audio.volume = 1;
                        audio.currentTime = 0;
                        audio.play();

                        // Clean up after sound ends
                        audio.onended = () => {
                            try {
                                source.disconnect();
                                envelopeGain.disconnect();
                            } catch(e) {}
                        };

                        this.currentCloseIndex = (this.currentCloseIndex + 1) % this.closePool.length;
                        this.lastPlayTime = now;

                    } catch(e) {
                        console.warn('WebAudio play failed, falling back to HTML5:', e);
                        // Fallback to simple HTML5 audio
                        audio.volume = this.masterVolume * volume;
                        audio.currentTime = 0;
                        audio.play();
                        this.currentCloseIndex = (this.currentCloseIndex + 1) % this.closePool.length;
                        this.lastPlayTime = now;
                    }
                }
            }

            setMasterVolume(volume) {
                this.masterVolume = Math.max(0, Math.min(1, volume));
                if (this.masterGain) {
                    this.masterGain.gain.value = this.masterVolume;
                }
            }

            // Create a symphonic synthesized sound effect
            createSynthSound(frequency = 440, duration = 0.5, type = 'sine') {
                if (!this.audioContext) return;

                const now = this.audioContext.currentTime;

                try {
                    // Create main oscillator
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(this.spatialPanner || this.masterGain);

                    oscillator.frequency.setValueAtTime(frequency, now);
                    oscillator.type = type;

                    // Create symphonic envelope (bell-like curve)
                    const attackTime = 0.02;
                    const decayTime = duration * 0.3;
                    const sustainTime = duration * 0.4;
                    const releaseTime = duration * 0.3;

                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(this.masterVolume * 0.15, now + attackTime);
                    gainNode.gain.exponentialRampToValueAtTime(this.masterVolume * 0.08, now + attackTime + decayTime);
                    gainNode.gain.setValueAtTime(this.masterVolume * 0.08, now + attackTime + decayTime + sustainTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + attackTime + decayTime + sustainTime + releaseTime);

                    oscillator.start(now);
                    oscillator.stop(now + duration);

                    // Add harmonic overtones for richness
                    this.addHarmonics(frequency, now, duration, type);

                    // Clean up
                    oscillator.onended = () => {
                        try {
                            oscillator.disconnect();
                            gainNode.disconnect();
                        } catch(e) {}
                    };

                } catch(e) {
                    console.warn('Symphonic synth sound creation failed:', e);
                }
            }

            // Add harmonic overtones for richer sound
            addHarmonics(baseFreq, startTime, duration, mainType) {
                try {
                    const harmonics = [
                        { freq: baseFreq * 2, gain: 0.3, type: 'sine' },
                        { freq: baseFreq * 3, gain: 0.2, type: 'triangle' },
                        { freq: baseFreq * 4, gain: 0.1, type: 'sine' }
                    ];

                    harmonics.forEach((harmonic, index) => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();

                        osc.connect(gain);
                        gain.connect(this.spatialPanner || this.masterGain);

                        osc.frequency.setValueAtTime(harmonic.freq, startTime);
                        osc.type = harmonic.type;

                        const delay = index * 0.01; // Slight delay for each harmonic
                        const harmonicStart = startTime + delay;

                        gain.gain.setValueAtTime(0, startTime);
                        gain.gain.setValueAtTime(this.masterVolume * harmonic.gain, harmonicStart);
                        gain.gain.exponentialRampToValueAtTime(0.001, harmonicStart + duration - delay);

                        osc.start(harmonicStart);
                        osc.stop(harmonicStart + duration - delay);
                    });

                } catch(e) {
                    console.warn('Harmonics creation failed:', e);
                }
            }

            // Create a symphonic umbrella opening/closing sound
            createUmbrellaSound(isOpening = true, intensity = 0.5) {
                if (!this.audioContext) return;

                const now = this.audioContext.currentTime;

                try {
                    // Create symphonic sound layers
                    const oscillators = [];
                    const gains = [];

                    // Musical scale frequencies (C major pentatonic for harmony)
                    const baseNote = isOpening ? 261.63 : 220.00; // C4 or A3
                    const scale = [1, 1.125, 1.25, 1.333, 1.5, 1.667, 1.875, 2]; // Musical intervals

                    // Create chord progression for opening/closing
                    const chordProgression = isOpening ?
                        [0, 2, 4, 7] : // C major chord (opening)
                        [9, 11, 14, 16]; // A minor chord (closing)

                    chordProgression.forEach((noteIndex, index) => {
                        const freq = baseNote * scale[noteIndex % scale.length];
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();

                        osc.connect(gain);
                        gain.connect(this.spatialPanner || this.masterGain);

                        // Musical waveforms for symphonic feel
                        osc.frequency.setValueAtTime(freq, now);
                        osc.type = index === 0 ? 'triangle' : // Fundamental - warm
                                  index === 1 ? 'sine' :     // Third - smooth
                                  index === 2 ? 'triangle' : // Fifth - rich
                                  'sine';                   // Octave - clear

                        // Sophisticated musical envelope (ADSR)
                        const attackTime = 0.1 + (index * 0.05);  // Staggered attack
                        const decayTime = isOpening ? 0.4 : 0.6;  // Longer decay for closing
                        const sustainLevel = intensity * (0.15 + index * 0.05); // Varying sustain
                        const releaseTime = isOpening ? 0.8 : 1.2; // Longer release for closing

                        gain.gain.setValueAtTime(0, now);
                        gain.gain.linearRampToValueAtTime(this.masterVolume * intensity * (0.8 + index * 0.1), now + attackTime);
                        gain.gain.exponentialRampToValueAtTime(this.masterVolume * sustainLevel, now + attackTime + decayTime);

                        // Add musical vibrato for richness
                        const vibratoRate = 4 + index; // Different rates for each voice
                        const vibratoDepth = 0.02 + (index * 0.01);
                        const vibratoStart = now + attackTime + 0.1;

                        if (isOpening) {
                            osc.frequency.setValueCurveAtTime(
                                this.createVibrato(freq, vibratoRate, vibratoDepth, 1.5),
                                vibratoStart,
                                1.5
                            );
                        }

                        gain.gain.exponentialRampToValueAtTime(0.001, now + attackTime + decayTime + releaseTime);

                        const startTime = now + (index * 0.02); // Slight delay for each voice
                        osc.start(startTime);
                        osc.stop(startTime + attackTime + decayTime + releaseTime);

                        oscillators.push(osc);
                        gains.push(gain);
                    });

                    // Add orchestral string-like resonance
                    this.addResonance(baseNote, now, intensity, isOpening);

                    // Clean up when done
                    const cleanup = () => {
                        oscillators.forEach(osc => {
                            try { osc.disconnect(); } catch(e) {}
                        });
                        gains.forEach(gain => {
                            try { gain.disconnect(); } catch(e) {}
                        });
                    };

                    oscillators[oscillators.length - 1].onended = cleanup;

                } catch(e) {
                    console.warn('Symphonic sound creation failed:', e);
                }
            }

            // Create vibrato curve for musical expression
            createVibrato(baseFreq, rate, depth, duration) {
                const sampleRate = this.audioContext.sampleRate;
                const samples = Math.floor(sampleRate * duration);
                const curve = new Float32Array(samples);

                for (let i = 0; i < samples; i++) {
                    const t = i / sampleRate;
                    curve[i] = baseFreq * (1 + Math.sin(t * rate * 2 * Math.PI) * depth);
                }

                return curve;
            }

            // Add orchestral resonance effect
            addResonance(baseFreq, startTime, intensity, isOpening) {
                try {
                    // Create resonance with harmonics
                    const resonanceFreqs = [
                        baseFreq * 2,   // Octave
                        baseFreq * 3,   // Fifth + octave
                        baseFreq * 4,   // Two octaves
                        baseFreq * 5    // Third + two octaves
                    ];

                    resonanceFreqs.forEach((freq, index) => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        const filter = this.audioContext.createBiquadFilter();

                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(this.spatialPanner || this.masterGain);

                        osc.frequency.setValueAtTime(freq, startTime);
                        osc.type = 'sine';

                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(freq * 2, startTime);
                        filter.Q.setValueAtTime(8 + index, startTime);

                        const delay = index * 0.05;
                        const resonanceStart = startTime + delay;
                        const resonanceDuration = isOpening ? 0.8 : 1.2;

                        gain.gain.setValueAtTime(0, startTime);
                        gain.gain.setValueAtTime(this.masterVolume * intensity * 0.1 * (1 / (index + 1)), resonanceStart);
                        gain.gain.exponentialRampToValueAtTime(0.001, resonanceStart + resonanceDuration);

                        osc.start(resonanceStart);
                        osc.stop(resonanceStart + resonanceDuration);
                    });

                } catch(e) {
                    console.warn('Resonance creation failed:', e);
                }
            }

            // Resume audio context (needed for some browsers)
            async resumeContext() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    try {
                        await this.audioContext.resume();
                        console.info('[WebAudio] Context resumed');
                    } catch(e) {
                        console.warn('[WebAudio] Failed to resume context:', e);
                    }
                }
            }

            // Adjust reverb level
            setReverbLevel(level) {
                if (this.reverb && this.reverb.gain) {
                    this.reverb.gain.value = level;
                }
            }

            // Adjust filter frequency
            setFilterFrequency(freq) {
                if (this.filter) {
                    this.filter.frequency.value = freq;
                }
            }

            // Toggle spatial audio
            setSpatialAudio(enabled) {
                // This would require restructuring the audio graph
                // For now, just log the intent
                console.info('[WebAudio] Spatial audio ' + (enabled ? 'enabled' : 'disabled'));
            }

            // Create an orchestral flourish for special moments
            createOrchestralFlourish(intensity = 0.3) {
                if (!this.audioContext) return;

                const now = this.audioContext.currentTime;

                try {
                    // Create a cascading arpeggio
                    const baseNote = 261.63; // C4
                    const flourishNotes = [0, 4, 7, 12, 16, 19, 24]; // C major scale

                    flourishNotes.forEach((noteOffset, index) => {
                        const freq = baseNote * Math.pow(2, noteOffset / 12);
                        const delay = index * 0.08; // Cascading effect
                        const startTime = now + delay;

                        // Create note with ADSR envelope
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();

                        osc.connect(gain);
                        gain.connect(this.spatialPanner || this.masterGain);

                        osc.frequency.setValueAtTime(freq, startTime);
                        osc.type = index % 2 === 0 ? 'triangle' : 'sine';

                        // Quick attack, medium decay
                        gain.gain.setValueAtTime(0, startTime);
                        gain.gain.linearRampToValueAtTime(this.masterVolume * intensity, startTime + 0.02);
                        gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.3);

                        osc.start(startTime);
                        osc.stop(startTime + 0.3);
                    });

                } catch(e) {
                    console.warn('Orchestral flourish creation failed:', e);
                }
            }
        }

        // Create global audio manager instance
        const audioManager = new UmbrellaAudioManager();

        // Fonction pour créer une animation de parapluie
        function createUmbrellaAnimation(containerId) {
            return new p5((p) => {
                // Variables locales pour cette instance
                let centerX, centerY;
                let umbrellaRadius = 45; // Divisé par 2 pour s'adapter au canvas 100x100
                let handleRadius = 8;
                let numSegments = 8;

                let animationState = 'closed';
                let currentOpenFactor = 0;
                let targetOpenFactor = 0;
                let animationSpeed = 0.025; // Faster for better responsiveness
                let animationActive = false;
                let bounceFactor = 0; // For natural bounce effect

                // Enhanced audio functions with spatial positioning and randomization
                function playOpenSound() {
                    // Vary volume based on how open the umbrella currently is
                    let baseVolume = 0.6 + (currentOpenFactor * 0.3); // 0.6 to 0.9
                    let randomVariation = p.random(-0.1, 0.1); // ±10% variation
                    let finalVolume = Math.max(0.3, Math.min(0.9, baseVolume + randomVariation));

                    // Calculate spatial position based on umbrella position on screen
                    const position = {
                        x: (centerX - p.width/2) * 0.01,  // Convert to audio space (-5 to 5)
                        y: (centerY - p.height/2) * 0.01,
                        z: currentOpenFactor * 2  // Closer when more open
                    };

                    audioManager.playOpen(finalVolume, position);

                    // Add symphonic synthesized sound for musical enhancement
                    if (p.random() < 0.6) { // 60% chance for more musical feel
                        setTimeout(() => {
                            audioManager.createUmbrellaSound(true, finalVolume * 0.7);
                        }, 80);
                    }

                    // Add harmonic counterpoint (25% chance)
                    if (p.random() < 0.25) {
                        setTimeout(() => {
                            audioManager.createSynthSound(440, 0.8, 'triangle');
                        }, 150);
                    }
                }

                function playCloseSound() {
                    // Closing sound gets louder as umbrella closes
                    let baseVolume = 0.5 + ((1 - currentOpenFactor) * 0.4); // 0.5 to 0.9
                    let randomVariation = p.random(-0.08, 0.08); // ±8% variation
                    let finalVolume = Math.max(0.4, Math.min(0.8, baseVolume + randomVariation));

                    // Calculate spatial position
                    const position = {
                        x: (centerX - p.width/2) * 0.01,
                        y: (centerY - p.height/2) * 0.01,
                        z: (1 - currentOpenFactor) * 2  // Closer when more closed
                    };

                    audioManager.playClose(finalVolume, position);

                    // Add symphonic synthesized sound for musical enhancement
                    if (p.random() < 0.7) { // 70% chance for closing (more frequent)
                        setTimeout(() => {
                            audioManager.createUmbrellaSound(false, finalVolume * 0.8);
                        }, 120);
                    }

                    // Add descending harmonic line for closing (35% chance)
                    if (p.random() < 0.35) {
                        setTimeout(() => {
                            audioManager.createSynthSound(330, 0.6, 'sine'); // E4
                        }, 200);
                    }

                    // Special orchestral flourish for closing (10% chance)
                    if (p.random() < 0.1) {
                        setTimeout(() => {
                            audioManager.createOrchestralFlourish(0.2);
                        }, 300);
                    }
                }

                function playHoverSound() {
                    if (hasPlayedHoverSound) return; // Only play once per umbrella

                    const now = p.millis();
                    if (now - lastHoverTime < 1500) return; // Shorter cooldown for more musical feel

                    // Calculate spatial position for hover sound
                    const position = {
                        x: (centerX - p.width/2) * 0.005,  // Closer for hover
                        y: (centerY - p.height/2) * 0.005,
                        z: 0.8  // Medium distance
                    };

                    // Create a symphonic hover melody
                    const baseNote = 523.25; // C5
                    const melodyNotes = [0, 4, 7, 12]; // C major arpeggio
                    const noteIndex = Math.floor(p.random() * melodyNotes.length);
                    const frequency = baseNote * Math.pow(2, melodyNotes[noteIndex] / 12);

                    // Play a beautiful symphonic hover sound
                    audioManager.createSynthSound(frequency, 0.4, 'triangle');

                    // Add harmonic accompaniment (30% chance)
                    if (p.random() < 0.3) {
                        setTimeout(() => {
                            const harmonyFreq = frequency * (p.random() < 0.5 ? 1.25 : 1.5); // Perfect fifth or major third
                            audioManager.createSynthSound(harmonyFreq, 0.3, 'sine');
                        }, 100);
                    }

                    // Add subtle orchestral flourish (15% chance)
                    if (p.random() < 0.15) {
                        setTimeout(() => {
                            audioManager.createUmbrellaSound(true, 0.15);
                        }, 200);
                    }

                    hasPlayedHoverSound = true;
                    lastHoverTime = now;
                }

                let segmentDelays = [];
                let lastStateChange = 0;
                let hasPlayedHoverSound = false; // Track if we've played hover sound for this umbrella
                let lastHoverTime = 0;

                // Single red color for all umbrella segments
                let umbrellaColor = '#FF0000';

                p.setup = function() {
                    let canvas = p.createCanvas(100, 100);
                    canvas.parent(containerId);

                    centerX = p.width / 2;
                    centerY = p.height / 2;

                    p.angleMode(p.DEGREES);

                    for (let i = 0; i < numSegments; i++) {
                        segmentDelays[i] = i * 0.05;
                    }
                };

                p.draw = function() {
                    updateAnimation();
                    drawBackground();
                    drawUmbrella(currentOpenFactor);
                    drawHandle();
                };


                function updateAnimation() {
                    let mouseIsOver = p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height;

                    if (mouseIsOver) {
                        // Play subtle hover sound for first-time hover
                        playHoverSound();

                        // Fermer sur hover
                        if (animationState !== 'closing' && animationState !== 'closed') {
                            if (!animationActive) {
                                animationActive = true;
                                lastStateChange = p.millis();
                            }
                            // lancer son de fermeture une seule fois au déclenchement
                            playCloseSound();
                            if (animationState === 'open' || animationState === 'opening') {
                                startClosing();
                                lastStateChange = p.millis();
                            }
                        }

                        if (animationState === 'opening' || animationState === 'closing') {
                            animateToTarget();
                        }
                    } else {
                        // Ouvrir sur mouse out
                        if (animationState !== 'opening' && animationState !== 'open') {
                            if (!animationActive) {
                                animationActive = true;
                                lastStateChange = p.millis();
                            }
                            // lancer son d'ouverture une seule fois au déclenchement
                            playOpenSound();
                            if (animationState === 'closed' || animationState === 'closing') {
                                startOpening();
                                lastStateChange = p.millis();
                            }
                        }

                        if (animationState === 'opening' || animationState === 'closing') {
                            animateToTarget();
                        }
                    }
                }

                function startOpening() {
                    animationState = 'opening';
                    targetOpenFactor = 1;
                }

                function startClosing() {
                    animationState = 'closing';
                    targetOpenFactor = 0;
                }

                function animateToTarget() {
                    let difference = targetOpenFactor - currentOpenFactor;

                    if (p.abs(difference) < 0.005) { // Slightly higher threshold for faster completion
                        currentOpenFactor = targetOpenFactor;
                        bounceFactor = 0;

                        if (targetOpenFactor === 1) {
                            animationState = 'open';
                        } else if (targetOpenFactor === 0) {
                            animationState = 'closed';
                        }
                        animationActive = false;
                        return;
                    }

                    // More responsive easing
                    let easing = 0.18; // Increased for faster response
                    let easedDifference = difference * easing;

                    // Reduced bounce effect for quicker completion
                    if (p.abs(difference) < 0.15) {
                        bounceFactor = p.sin(p.millis() * 0.03) * 0.01 * (1 - p.abs(difference) * 6);
                        easedDifference += bounceFactor;
                    }

                    currentOpenFactor += easedDifference;

                    // Ensure we don't overshoot
                    if ((difference > 0 && currentOpenFactor > targetOpenFactor) ||
                        (difference < 0 && currentOpenFactor < targetOpenFactor)) {
                        currentOpenFactor = targetOpenFactor;
                    }
                }

                function drawBackground() {
                    // Fond noir dramatique pour effet élégant
                    p.background(15, 15, 15); // #0F0F0F en RGB
                }

                function drawUmbrella(openFactor) {
                    p.push();
                    p.translate(centerX, centerY);

                    // Ombre portée sous le parapluie
                    drawShadow(openFactor);

                    let segmentAngle = 360 / numSegments;

                    for (let i = 0; i < numSegments; i++) {
                        p.push();
                        p.rotate(i * segmentAngle);

                        let segmentOpenFactor = calculateSegmentOpenFactor(i, openFactor);

                        // Create realistic red fabric gradient for umbrella canopy
                        let gradient = p.drawingContext.createRadialGradient(0, 0, 0, 0, 0, umbrellaRadius * openFactor);
                        // More realistic fabric colors - darker burgundy at center, bright red at edges
                        let centerColor = p.color('#7B0F0F'); // Dark burgundy at center (fabric fold)
                        let edgeColor = p.color('#E53E3E');   // Bright red at edges
                        let brightness = p.map(segmentOpenFactor, 0, 1, 0.85, 1); // Slightly more contrast

                        // Apply brightness adjustment to both colors
                        centerColor = p.lerpColor(centerColor, p.color(0, 0, 0), 1 - brightness);
                        edgeColor = p.lerpColor(edgeColor, p.color(0, 0, 0), 1 - brightness);

                        gradient.addColorStop(0, centerColor.toString('#rrggbb'));
                        gradient.addColorStop(1, edgeColor.toString('#rrggbb'));

                        p.drawingContext.fillStyle = gradient;
                        // Contours gris foncés pour se détacher du fond noir
                        p.stroke(80, 80, 80, p.map(segmentOpenFactor, 0, 1, 180, 255));
                        p.strokeWeight(2.5);

                        drawUmbrellaSegment(segmentOpenFactor, segmentAngle);
                        p.pop();
                    }

                    // Shading et détails au-dessus des segments
                    drawShading(openFactor);
                    drawCanopyRim(openFactor);
                    drawRibTips(openFactor);

                    p.pop();
                }

                function calculateSegmentOpenFactor(segmentIndex, globalOpenFactor) {
                    let delay = segmentDelays[segmentIndex];
                    let easedFactor = easeInOutCubic(globalOpenFactor);
                    let delayedFactor = sigmoid((easedFactor - delay) * 8);
                    return p.constrain(delayedFactor, 0, 1);
                }

                function easeInOutCubic(t) {
                    return t < 0.5 ? 4 * t * t * t : 1 - p.pow(-2 * t + 2, 3) / 2;
                }

                function sigmoid(x) {
                    return 1 / (1 + p.exp(-x));
                }

                function drawUmbrellaSegment(openFactor, segmentAngle) {
                    let segmentWidth = segmentAngle * openFactor;
                    let currentRadius = umbrellaRadius * openFactor;

                    // Create more realistic curved segment shape
                    p.beginShape();

                    // Start at center
                    p.vertex(0, 0);

                    // Create curved edge using quadratic bezier curves for realistic fabric drape
                    let steps = 20;
                    for (let i = 0; i <= steps; i++) {
                        let t = i / steps;
                        let angle = p.lerp(-segmentWidth/2, segmentWidth/2, t);

                        // Add some fabric sag for realism (parabolic curve)
                        let sagFactor = 0.15; // How much the fabric sags
                        let sag = p.sin(t * p.PI) * sagFactor * currentRadius;

                        let x = p.cos(angle) * (currentRadius - sag);
                        let y = p.sin(angle) * (currentRadius - sag);
                        p.vertex(x, y);
                    }

                    p.endShape(p.CLOSE);

                    // More realistic rib structure with curves
                    p.stroke(101, 67, 33); // Darker brown for realistic wood/metal
                    p.strokeWeight(2.8);
                    p.strokeCap(p.ROUND);

                    // Main rib with slight curve
                    let ribStartX = p.cos(-segmentWidth/2) * currentRadius * 0.1;
                    let ribStartY = p.sin(-segmentWidth/2) * currentRadius * 0.1;
                    let ribEndX = p.cos(-segmentWidth/2) * currentRadius;
                    let ribEndY = p.sin(-segmentWidth/2) * currentRadius;

                    // Add slight curve to rib for realism
                    let midX = (ribStartX + ribEndX) / 2;
                    let midY = (ribStartY + ribEndY) / 2 - currentRadius * 0.05;

                    p.noFill();
                    p.beginShape();
                    p.vertex(ribStartX, ribStartY);
                    p.quadraticVertex(midX, midY, ribEndX, ribEndY);
                    p.endShape();

                    // Second rib
                    ribStartX = p.cos(segmentWidth/2) * currentRadius * 0.1;
                    ribStartY = p.sin(segmentWidth/2) * currentRadius * 0.1;
                    ribEndX = p.cos(segmentWidth/2) * currentRadius;
                    ribEndY = p.sin(segmentWidth/2) * currentRadius;

                    midX = (ribStartX + ribEndX) / 2;
                    midY = (ribStartY + ribEndY) / 2 - currentRadius * 0.05;

                    p.beginShape();
                    p.vertex(ribStartX, ribStartY);
                    p.quadraticVertex(midX, midY, ribEndX, ribEndY);
                    p.endShape();

                    // Add cross braces for extra realism
                    if (openFactor > 0.7) {
                        p.strokeWeight(1.5);
                        p.stroke(80, 50, 30, 150);
                        let braceY = currentRadius * 0.6;
                        p.line(-currentRadius * 0.3, braceY, currentRadius * 0.3, braceY);
                    }
                }

                // Bordure lisse pour un rendu propre (sans ondulations)
                function drawCanopyRim(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    p.noFill();
                    p.stroke(120, 120, 120, 120);  // Much darker and less opaque
                    p.strokeWeight(1.5);             // Slightly thinner
                    p.circle(0, 0, baseR * 2);
                }

                // Enhanced fabric shading for realistic material appearance
                function drawShading(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    p.push();
                    p.noStroke();

                    // Fabric texture simulation with subtle radial shading
                    for (let i = 0; i <= 8; i++) {
                        let t = i / 8;
                        let r = p.lerp(baseR * 0.3, baseR * 0.9, t);
                        let alpha = p.lerp(8, 25, t) * openFactor;
                        p.fill(0, 0, 0, alpha);
                        p.circle(0, 0, r * 2);
                    }

                    // Add fabric fold highlights for realism
                    if (openFactor > 0.6) {
                        // Subtle crease lines
                        p.stroke(255, 255, 255, 15 * openFactor);
                        p.strokeWeight(0.8);
                        p.noFill();

                        let creaseR = baseR * 0.7;
                        for (let i = 0; i < numSegments; i++) {
                            let angle = (i * 360 / numSegments) + 15; // Offset for natural look
                            let x1 = p.cos(angle) * creaseR * 0.8;
                            let y1 = p.sin(angle) * creaseR * 0.8;
                            let x2 = p.cos(angle) * creaseR * 1.1;
                            let y2 = p.sin(angle) * creaseR * 1.1;
                            p.line(x1, y1, x2, y2);
                        }
                    }

                    // Enhanced highlight for fabric sheen
                    p.noStroke();
                    p.fill(255, 100, 100, 12 * openFactor); // Slight reddish highlight
                    p.ellipse(-baseR * 0.3, -baseR * 0.3, baseR * 0.5, baseR * 0.25);

                    // Additional specular highlight
                    p.fill(255, 255, 255, 8 * openFactor);
                    p.ellipse(-baseR * 0.2, -baseR * 0.2, baseR * 0.2, baseR * 0.1);

                    p.pop();
                }

                // Realistic rib tips with metallic finish
                function drawRibTips(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    let segmentAngle = 360 / numSegments;

                    for (let i = 0; i < numSegments; i++) {
                        let a = i * segmentAngle;
                        let x = p.cos(a) * baseR;
                        let y = p.sin(a) * baseR;

                        // Metallic rib tip with highlight
                        p.noStroke();
                        p.fill(180, 180, 190); // Base metallic color
                        p.circle(x, y, p.max(2, baseR * 0.08));

                        // Highlight for 3D effect
                        p.fill(220, 220, 230, 200);
                        p.circle(x - 0.5, y - 0.5, p.max(1, baseR * 0.04));
                    }
                }

                function drawShadow(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    p.push();
                    p.noStroke();

                    // More realistic shadow with gradient and multiple layers
                    for (let i = 0; i < 3; i++) {
                        let alpha = 60 - i * 15;
                        let scale = 1.2 + i * 0.2;
                        let offset = baseR * (0.1 + i * 0.05);
                        p.fill(0, 0, 0, alpha * openFactor);
                        p.ellipse(0, offset, baseR * scale, baseR * (0.4 + i * 0.1));
                    }

                    // Add subtle shadow from handle
                    p.fill(0, 0, 0, 30 * openFactor);
                    p.ellipse(0, -baseR * 0.2, baseR * 0.3, baseR * 0.8);
                    p.pop();
                }

                function drawHandle() {
                    // More realistic central hub with metallic finish
                    p.push();
                    p.translate(centerX, centerY);

                    // Main hub
                    p.noStroke();
                    p.fill(50, 50, 60); // Dark metallic
                    p.circle(0, 0, 8);

                    // Metallic ring
                    p.stroke(80, 80, 90);
                    p.strokeWeight(1.5);
                    p.noFill();
                    p.circle(0, 0, 7);

                    // Highlight for 3D effect
                    p.noStroke();
                    p.fill(120, 120, 140, 180);
                    p.circle(-1, -1, 4);

                    // Central rivet
                    p.fill(30, 30, 40);
                    p.circle(0, 0, 2);

                    p.pop();
                }
            });
        }

        // Créer le maximum de parapluies possible
        function createMaximumUmbrellas() {
            const container = document.getElementById('canvases-container');
            const canvasSize = 100; // Taille d'un canvas (divisée par 2)
            const gap = 10; // Espace entre les canvas (divisé par 2)
            const totalCanvasSize = canvasSize + gap;

            // Calculer le nombre maximum de canvas qui peuvent tenir
            const availableWidth = window.innerWidth - 40; // Marges
            const availableHeight = window.innerHeight - 40; // Juste les marges (pas de titre)

            const maxCols = Math.floor(availableWidth / totalCanvasSize);
            const maxRows = Math.floor(availableHeight / totalCanvasSize);
            const totalCanvases = Math.min(maxCols * maxRows, 200); // Limite augmentée à 200 grâce aux canvas plus petits

            console.log(`Création de ${totalCanvases} parapluies maximum (${maxCols}x${maxRows} possible)`);

            // Créer les éléments HTML dynamiquement
            for (let i = 0; i < totalCanvases; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'canvas-wrapper';

                const canvasDiv = document.createElement('div');
                canvasDiv.id = `sketch-container-${i + 1}`;

                wrapper.appendChild(canvasDiv);
                container.appendChild(wrapper);
            }

            // Créer les instances d'animation
            const umbrellas = [];
            for (let i = 0; i < totalCanvases; i++) {
                umbrellas.push(createUmbrellaAnimation(`sketch-container-${i + 1}`));
            }

            return umbrellas;
        }

        // Créer tous les parapluies
        let allUmbrellas = createMaximumUmbrellas();

        // Gérer le redimensionnement de la fenêtre
        window.addEventListener('resize', function() {
            // Supprimer les anciens canvas
            const container = document.getElementById('canvases-container');
            container.innerHTML = '';

            // Arrêter les anciennes instances p5
            allUmbrellas.forEach(umbrella => {
                if (umbrella && umbrella.remove) {
                    umbrella.remove();
                }
            });

            // Recréer avec les nouvelles dimensions
            allUmbrellas = createMaximumUmbrellas();
        });
    </script>

    <script>
        // Enhanced Audio Configuration with multiple sound sources
        (function initAudioDefaults(){
            // Primary audio elements
            const openEl = document.getElementById('audio-open');
            const closeEl = document.getElementById('audio-close');

            // Audio pool elements
            const open1El = document.getElementById('audio-open-1');
            const open2El = document.getElementById('audio-open-2');
            const close1El = document.getElementById('audio-close-1');
            const close2El = document.getElementById('audio-close-2');

            // Audio file paths (you can replace these with different sounds)
            const basePath = (location.hostname === "127.0.0.1" || location.hostname === "localhost")
                ? "assets/"
                : "/hack/umbrella/assets/";

            // For now, use the same sound file for all (you can replace with different sounds)
            const openSound = basePath + "audio.mp3";
            const closeSound = basePath + "audio.mp3";

            console.info('[AUDIO] Initializing enhanced audio system');

            // Set sources for all audio elements
            const allAudioElements = [openEl, closeEl, open1El, open2El, close1El, close2El];
            allAudioElements.forEach((el, index) => {
                if (el && !el.src) {
                    // Alternate between open and close sounds
                    el.src = (index % 2 === 0) ? openSound : closeSound;
                }
            });

            console.info('[AUDIO] Sources set for all audio elements');

            // Marqueurs globaux
            window.__audioUnlocked = false;
            window.__audioReady = false;

            // Mark ready when all audio elements are loaded
            let loadedCount = 0;
            const totalElements = allAudioElements.length;
            const markReady = () => {
                loadedCount++;
                console.info(`[AUDIO] ${loadedCount}/${totalElements} elements loaded`);
                if (loadedCount >= totalElements) {
                    window.__audioReady = true;
                    console.info('[AUDIO] All elements ready - audio system active!');
                }
            };

            allAudioElements.forEach(el => {
                if (el) el.addEventListener('canplaythrough', markReady, { once: true });
            });

            const unlock = async (ev) => {
                console.info('[AUDIO] unlock gesture', ev && ev.type);
                try {
                    // Unlock all audio elements by playing them muted first
                    allAudioElements.forEach(el => { if (el) el.muted = true; });

                    const playPromises = allAudioElements.map(el =>
                        el ? el.play() : Promise.resolve()
                    );

                    await Promise.allSettled(playPromises);

                    // Pause all and unmute
                    allAudioElements.forEach(el => {
                        if (el) {
                            el.pause();
                            el.muted = false;
                        }
                    });

                    // Resume Web Audio context if available
                    await audioManager.resumeContext();

                    // Mark as unlocked and set master volume
                    window.__audioUnlocked = true;
                    audioManager.setMasterVolume(0.4); // Set comfortable default volume
                    console.info('[AUDIO] All elements unlocked and Web Audio ready!');

                } catch(e) {
                    console.warn('[AUDIO] unlock failed', e);
                } finally {
                    window.removeEventListener('pointerdown', unlock);
                    window.removeEventListener('keydown', unlock);
                }
            };
            window.addEventListener('pointerdown', unlock, { once: true });
            window.addEventListener('keydown', unlock, { once: true });
            console.info('[AUDIO] bootstrap done, waiting for user gesture...');
        })();
    </script>
</body>
</html>
