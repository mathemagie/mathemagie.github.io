<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation Parapluie - Vue du Haut</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0F0F0F; /* Noir élégant pour effet dramatique */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        #sketch-container {
            /* Bordure et ombre retirées pour un look plus propre */
            cursor: pointer; /* Curseur pointer pour indiquer l'interactivité */
            transition: opacity 0.3s ease; /* Transition douce pour les effets */
        }

        .canvases-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, 100px);
            gap: 10px;
            justify-content: center;
            padding: 10px;
            max-width: 100vw;
            box-sizing: border-box;
        }

        .canvas-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100px;
            height: 100px;
        }

        .canvas-wrapper div[id^="sketch-container-"] {
            cursor: pointer;
            transition: opacity 0.3s ease;
        }

        .canvas-wrapper div[id^="sketch-container-"]:hover {
            opacity: 0.95;
        }
        .title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ecf0f1;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 25px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            display: none; /* Hidden by default, shown only in debug mode */
        }

        .title:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
        }

        /* Fullscreen Button */
        #fullscreen-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #666666;
            border-radius: 8px;
            color: #000000;
            font-size: 16px;
            font-weight: bold;
            padding: 10px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        #fullscreen-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        #fullscreen-btn:active {
            transform: scale(0.95);
        }

        #fullscreen-btn.fullscreen {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-color: #333333;
        }

        #fullscreen-btn.fullscreen:hover {
            background: rgba(0, 0, 0, 1);
        }

        /* Heartbeat Controls */
        #heartbeat-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 10px;
            display: none; /* Hidden by default, shown only in debug mode */
            align-items: center;
            gap: 10px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        #heartbeat-controls button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 16px;
            font-weight: bold;
            width: 35px;
            height: 35px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #heartbeat-controls button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        #heartbeat-controls button:active {
            transform: scale(0.95);
        }

        #heartbeat-controls #heartbeat-pause {
            border-radius: 8px;
            width: auto;
            padding: 0 12px;
            font-size: 14px;
        }

        #heartbeat-controls #bpm-display {
            color: #ecf0f1;
            font-weight: bold;
            font-size: 14px;
            min-width: 60px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="canvases-container" class="canvases-container"></div>

    <!-- Heartbeat Display -->
    <div class="title" id="heartbeat-display">
        <span id="bpm-value">72</span> BPM - <span id="heartbeat-phase">Diastole</span>
    </div>

    <!-- Fullscreen Button -->
    <button id="fullscreen-btn" title="Toggle Fullscreen (F11)">
        ⛶
    </button>

    <!-- Heartbeat Controls -->
    <div id="heartbeat-controls">
        <button id="bpm-decrease" title="Decrease BPM">-</button>
        <span id="bpm-display">72 BPM</span>
        <button id="bpm-increase" title="Increase BPM">+</button>
        <button id="heartbeat-pause" title="Pause/Resume Rhythm">⏸️</button>
    </div>

    <!-- Enhanced Audio System for Umbrella Sounds -->
    <audio id="audio-open" preload="auto" muted playsinline style="display:none"></audio>
    <audio id="audio-close" preload="auto" muted playsinline style="display:none"></audio>

    <!-- Audio pool for multiple simultaneous sounds -->
    <audio id="audio-open-1" preload="auto" muted playsinline style="display:none"></audio>
    <audio id="audio-open-2" preload="auto" muted playsinline style="display:none"></audio>
    <audio id="audio-close-1" preload="auto" muted playsinline style="display:none"></audio>
    <audio id="audio-close-2" preload="auto" muted playsinline style="display:none"></audio>

    <script>
        // Advanced Web Audio Manager with synthesis and effects
        class UmbrellaAudioManager {
            constructor() {
                this.masterVolume = 0.4;
                this.audioContext = null;
                this.isInitialized = false;

                // Audio element pools
                this.openPool = [
                    document.getElementById('audio-open'),
                    document.getElementById('audio-open-1'),
                    document.getElementById('audio-open-2')
                ];
                this.closePool = [
                    document.getElementById('audio-close'),
                    document.getElementById('audio-close-1'),
                    document.getElementById('audio-close-2')
                ];

                this.currentOpenIndex = 0;
                this.currentCloseIndex = 0;
                this.lastPlayTime = 0;
                this.minPlayInterval = 150;

                // Web Audio nodes for effects
                this.masterGain = null;
                this.reverb = null;
                this.filter = null;
                this.spatialPanner = null;
                this.quartetRhythmPlayer = null;
            }

            async initializeWebAudio() {
                if (this.isInitialized) return true;

                try {
                    // Create audio context
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Create master gain node
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = this.masterVolume;
                    this.masterGain.connect(this.audioContext.destination);

                    // Create reverb effect
                    await this.createReverb();

                    // Create filter for sound shaping
                    this.filter = this.audioContext.createBiquadFilter();
                    this.filter.type = 'lowpass';
                    this.filter.frequency.value = 3000;
                    this.filter.Q.value = 1;
                    this.filter.connect(this.masterGain);

                    // Create spatial audio panner
                    this.spatialPanner = this.audioContext.createPanner();
                    this.spatialPanner.panningModel = 'HRTF';
                    this.spatialPanner.distanceModel = 'inverse';
                    this.spatialPanner.refDistance = 1;
                    this.spatialPanner.maxDistance = 1000;
                    this.spatialPanner.rolloffFactor = 1;
                    this.spatialPanner.coneInnerAngle = 360;
                    this.spatialPanner.coneOuterAngle = 0;
                    this.spatialPanner.coneOuterGain = 0;
                    this.spatialPanner.connect(this.filter);

                    // Initialize quartet rhythm player
                    this.quartetRhythmPlayer = new QuartetRhythmPlayer(this.audioContext, this.masterGain);

                    this.isInitialized = true;
                    console.info('[WebAudio] Initialized successfully with quartet rhythm');
                    return true;

                } catch (error) {
                    console.warn('[WebAudio] Initialization failed:', error);
                    return false;
                }
            }

            async createReverb() {
                // Create a simple reverb effect
                this.reverb = this.audioContext.createConvolver();

                // Create impulse response for reverb
                const sampleRate = this.audioContext.sampleRate;
                const length = sampleRate * 2; // 2 second reverb
                const impulse = this.audioContext.createBuffer(2, length, sampleRate);

                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        // Create a decaying noise for reverb
                        const decay = Math.pow(1 - i / length, 2);
                        channelData[i] = (Math.random() * 2 - 1) * decay * 0.1;
                    }
                }

                this.reverb.buffer = impulse;
                this.reverb.connect(this.masterGain);
            }

            isReady() {
                return window.__audioUnlocked === true && window.__audioReady === true;
            }

            async playOpen(volume = 1.0, position = { x: 0, y: 0, z: 0 }) {
                if (!this.isReady()) return;

                const now = Date.now();
                if (now - this.lastPlayTime < this.minPlayInterval) return;

                // Initialize Web Audio if not already done
                if (!this.isInitialized) {
                    await this.initializeWebAudio();
                }

                const audio = this.openPool[this.currentOpenIndex];
                if (audio && audio.src) {
                    try {
                        // Set spatial position
                        this.spatialPanner.positionX.value = position.x;
                        this.spatialPanner.positionY.value = position.y;
                        this.spatialPanner.positionZ.value = position.z;

                        // Create Web Audio source from HTML5 audio
                        const source = this.audioContext.createMediaElementSource(audio);

                        // Apply effects chain
                        source.connect(this.spatialPanner);

                        // Add volume envelope for more natural sound
                        const envelopeGain = this.audioContext.createGain();
                        envelopeGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                        envelopeGain.gain.linearRampToValueAtTime(volume * this.masterVolume, this.audioContext.currentTime + 0.01);
                        envelopeGain.gain.exponentialRampToValueAtTime(volume * this.masterVolume * 0.3, this.audioContext.currentTime + 0.5);
                        envelopeGain.connect(this.spatialPanner);

                        source.connect(envelopeGain);

                        // Play the audio
                        audio.volume = 1; // Let Web Audio handle volume
                        audio.currentTime = 0;
                        audio.play();

                        // Clean up after sound ends
                        audio.onended = () => {
                            try {
                                source.disconnect();
                                envelopeGain.disconnect();
                            } catch(e) {}
                        };

                        this.currentOpenIndex = (this.currentOpenIndex + 1) % this.openPool.length;
                        this.lastPlayTime = now;

                    } catch(e) {
                        console.warn('WebAudio play failed, falling back to HTML5:', e);
                        // Fallback to simple HTML5 audio
                        audio.volume = this.masterVolume * volume;
                        audio.currentTime = 0;
                        audio.play();
                        this.currentOpenIndex = (this.currentOpenIndex + 1) % this.openPool.length;
                        this.lastPlayTime = now;
                    }
                }
            }

            async playClose(volume = 1.0, position = { x: 0, y: 0, z: 0 }) {
                if (!this.isReady()) return;

                const now = Date.now();
                if (now - this.lastPlayTime < this.minPlayInterval) return;

                // Initialize Web Audio if not already done
                if (!this.isInitialized) {
                    await this.initializeWebAudio();
                }

                const audio = this.closePool[this.currentCloseIndex];
                if (audio && audio.src) {
                    try {
                        // Set spatial position
                        this.spatialPanner.positionX.value = position.x;
                        this.spatialPanner.positionY.value = position.y;
                        this.spatialPanner.positionZ.value = position.z;

                        // Create Web Audio source from HTML5 audio
                        const source = this.audioContext.createMediaElementSource(audio);

                        // Apply effects chain
                        const envelopeGain = this.audioContext.createGain();
                        envelopeGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                        envelopeGain.gain.linearRampToValueAtTime(volume * this.masterVolume, this.audioContext.currentTime + 0.01);
                        envelopeGain.gain.exponentialRampToValueAtTime(volume * this.masterVolume * 0.2, this.audioContext.currentTime + 0.8);
                        envelopeGain.connect(this.spatialPanner);

                        source.connect(envelopeGain);

                        // Play the audio
                        audio.volume = 1;
                        audio.currentTime = 0;
                        audio.play();

                        // Clean up after sound ends
                        audio.onended = () => {
                            try {
                                source.disconnect();
                                envelopeGain.disconnect();
                            } catch(e) {}
                        };

                        this.currentCloseIndex = (this.currentCloseIndex + 1) % this.closePool.length;
                        this.lastPlayTime = now;

                    } catch(e) {
                        console.warn('WebAudio play failed, falling back to HTML5:', e);
                        // Fallback to simple HTML5 audio
                        audio.volume = this.masterVolume * volume;
                        audio.currentTime = 0;
                        audio.play();
                        this.currentCloseIndex = (this.currentCloseIndex + 1) % this.closePool.length;
                        this.lastPlayTime = now;
                    }
                }
            }

            setMasterVolume(volume) {
                this.masterVolume = Math.max(0, Math.min(1, volume));
                if (this.masterGain) {
                    this.masterGain.gain.value = this.masterVolume;
                }
            }

            // Create a symphonic synthesized sound effect
            createSynthSound(frequency = 440, duration = 0.5, type = 'sine') {
                if (!this.audioContext) return;

                const now = this.audioContext.currentTime;

                try {
                    // Create main oscillator
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(this.spatialPanner || this.masterGain);

                    oscillator.frequency.setValueAtTime(frequency, now);
                    oscillator.type = type;

                    // Create symphonic envelope (bell-like curve)
                    const attackTime = 0.02;
                    const decayTime = duration * 0.3;
                    const sustainTime = duration * 0.4;
                    const releaseTime = duration * 0.3;

                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(this.masterVolume * 0.15, now + attackTime);
                    gainNode.gain.exponentialRampToValueAtTime(this.masterVolume * 0.08, now + attackTime + decayTime);
                    gainNode.gain.setValueAtTime(this.masterVolume * 0.08, now + attackTime + decayTime + sustainTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + attackTime + decayTime + sustainTime + releaseTime);

                    oscillator.start(now);
                    oscillator.stop(now + duration);

                    // Clean up
                    oscillator.onended = () => {
                        try {
                            oscillator.disconnect();
                            gainNode.disconnect();
                        } catch(e) {}
                    };

                } catch(e) {
                    console.warn('Symphonic synth sound creation failed:', e);
                }
            }





            // Resume audio context (needed for some browsers)
            async resumeContext() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    try {
                        await this.audioContext.resume();
                        console.info('[WebAudio] Context resumed');
                    } catch(e) {
                        console.warn('[WebAudio] Failed to resume context:', e);
                    }
                }
            }

            // Adjust reverb level
            setReverbLevel(level) {
                if (this.reverb && this.reverb.gain) {
                    this.reverb.gain.value = level;
                }
            }

            // Adjust filter frequency
            setFilterFrequency(freq) {
                if (this.filter) {
                    this.filter.frequency.value = freq;
                }
            }

            // Toggle spatial audio
            setSpatialAudio(enabled) {
                // This would require restructuring the audio graph
                // For now, just log the intent
                console.info('[WebAudio] Spatial audio ' + (enabled ? 'enabled' : 'disabled'));
            }

            // Control quartet rhythm
            startQuartetRhythm() {
                if (this.quartetRhythmPlayer) {
                    this.quartetRhythmPlayer.start();
                }
            }

            stopQuartetRhythm() {
                if (this.quartetRhythmPlayer) {
                    this.quartetRhythmPlayer.stop();
                }
            }

            updateQuartetRhythm(heartbeatPhase, bpm) {
                if (this.quartetRhythmPlayer) {
                    this.quartetRhythmPlayer.update(heartbeatPhase, bpm);
                }
            }

        }

        // Create global audio manager instance
        const audioManager = new UmbrellaAudioManager();

        // Heartbeat simulation system
        class HeartbeatSimulator {
            constructor() {
                this.baseBPM = 72; // Normal resting heart rate
                this.currentBPM = this.baseBPM;
                this.heartbeatPhase = 0; // 0 to 1 representing heartbeat cycle
                this.lastUpdate = Date.now();
                this.heartbeatDuration = (60 / this.baseBPM) * 1000; // Duration in milliseconds
                this.isBeating = true;

                // Add some natural variation
                this.variation = 0;
                this.variationSpeed = 0.002;
                this.variationAmplitude = 0.1; // ±10% variation

                console.log('[HEARTBEAT] Simulator initialized - BPM:', this.baseBPM);
            }

            update() {
                if (!this.isBeating) return;

                const now = Date.now();
                const deltaTime = now - this.lastUpdate;
                this.lastUpdate = now;

                // Update heartbeat phase
                this.heartbeatPhase += deltaTime / this.heartbeatDuration;
                if (this.heartbeatPhase >= 1) {
                    this.heartbeatPhase = 0;
                }

                // Add natural variation to BPM
                this.variation += this.variationSpeed;
                const bpmVariation = Math.sin(this.variation) * this.variationAmplitude;
                this.currentBPM = this.baseBPM * (1 + bpmVariation);
                this.heartbeatDuration = (60 / this.currentBPM) * 1000;

                // Simulate slight irregularities (like real heartbeat)
                if (Math.random() < 0.02) { // 2% chance of slight irregularity
                    this.heartbeatDuration *= (0.95 + Math.random() * 0.1);
                }
            }

            // Get current heartbeat intensity (0 to 1)
            // Higher during systole (contraction), lower during diastole (relaxation)
            getHeartbeatIntensity() {
                // Create a realistic heartbeat waveform
                const phase = this.heartbeatPhase;

                if (phase < 0.1) {
                    // Rapid systole spike
                    return 0.3 + (phase / 0.1) * 0.7; // 0.3 to 1.0
                } else if (phase < 0.3) {
                    // Systole plateau
                    return 1.0;
                } else if (phase < 0.4) {
                    // Initial diastole drop
                    return 1.0 - ((phase - 0.3) / 0.1) * 0.3; // 1.0 to 0.7
                } else {
                    // Rest of diastole (relaxation)
                    return 0.7 - ((phase - 0.4) / 0.6) * 0.4; // 0.7 to 0.3
                }
            }

            // Check if we're in systole (contraction phase)
            isSystole() {
                return this.heartbeatPhase < 0.3;
            }

            // Check if we're in diastole (relaxation phase)
            isDiastole() {
                return this.heartbeatPhase >= 0.3;
            }

            // Get current BPM for display
            getCurrentBPM() {
                return Math.round(this.currentBPM);
            }

            // Pause/resume heartbeat simulation
            setPaused(paused) {
                this.isBeating = !paused;

                // Also control quartet rhythm
                if (paused) {
                    audioManager.stopQuartetRhythm();
                } else {
                    audioManager.startQuartetRhythm();
                }

                console.log('[HEARTBEAT]', paused ? 'Paused' : 'Resumed');
            }
        }

        // Debug mode detection
        function isDebugMode() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('debug') === '1';
        }

        // Show debug elements if debug mode is enabled
        function showDebugElements() {
            if (isDebugMode()) {
                const heartbeatDisplay = document.getElementById('heartbeat-display');
                const heartbeatControls = document.getElementById('heartbeat-controls');

                if (heartbeatDisplay) {
                    heartbeatDisplay.style.display = 'block';
                    console.log('[DEBUG] Heartbeat display shown');
                }

                if (heartbeatControls) {
                    heartbeatControls.style.display = 'flex';
                    console.log('[DEBUG] Heartbeat controls shown');
                }

                console.log('[DEBUG] Debug mode enabled - showing debug elements');
            } else {
                console.log('[DEBUG] Debug mode disabled - debug elements hidden');
            }
        }

        // Function to toggle debug mode (for development)
        window.toggleDebugMode = function() {
            const currentUrl = new URL(window.location);
            const hasDebug = currentUrl.searchParams.has('debug');

            if (hasDebug) {
                currentUrl.searchParams.delete('debug');
            } else {
                currentUrl.searchParams.set('debug', '1');
            }

            window.location.href = currentUrl.toString();
        };

        // Add keyboard shortcut for debug mode (Ctrl+D)
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === 'd') {
                event.preventDefault();
                window.toggleDebugMode();
            }
        });

        // Create global heartbeat simulator
        const heartbeatSimulator = new HeartbeatSimulator();

        // Visual rhythm effects manager
        const visualRhythmEffects = {
            flashIntensity: 0,
            flashDecay: 0.95,
            flashColor: [255, 255, 255], // White flash

            triggerFlash(intensity = 1.0, color = [255, 255, 255]) {
                this.flashIntensity = Math.min(1.0, this.flashIntensity + intensity);
                this.flashColor = color;
            },

            update() {
                this.flashIntensity *= this.flashDecay;
                if (this.flashIntensity < 0.01) {
                    this.flashIntensity = 0;
                }
            },

            getFlashColor() {
                return this.flashColor;
            },

            getFlashIntensity() {
                return this.flashIntensity;
            }
        };

        // Quartet Rhythm Player - creates rhythmic sounds synchronized with heartbeat
        class QuartetRhythmPlayer {
            constructor(audioContext, masterGain) {
                this.audioContext = audioContext;
                this.masterGain = masterGain;
                this.isPlaying = false;
                this.lastBeatTime = 0;
                this.quarterNoteDuration = 0;
                this.visualFlashCallback = null; // Callback for visual effects

                // Quartet rhythm patterns (4/4 time signature)
                this.rhythmPatterns = {
                    kick: [1, 0, 0, 0],     // Downbeat
                    snare: [0, 0, 1, 0],    // Backbeat
                    hihat: [1, 1, 1, 1],    // Every beat
                    bass: [1, 0, 1, 0]      // Alternating
                };

                this.currentStep = 0;
                this.stepsPerBeat = 4; // 16th notes

                console.log('[QUARTET] Rhythm player initialized');
            }

            start() {
                if (this.isPlaying) return;
                this.isPlaying = true;
                this.lastBeatTime = this.audioContext.currentTime;
                console.log('[QUARTET] Rhythm started');
            }

            stop() {
                this.isPlaying = false;
                console.log('[QUARTET] Rhythm stopped');
            }

            // Update rhythm based on heartbeat phase
            update(heartbeatPhase, bpm) {
                if (!this.isPlaying || !this.audioContext) return;

                // Calculate quarter note duration based on current BPM
                this.quarterNoteDuration = (60 / bpm) * 0.25; // Quarter note = 1/4 of whole note

                const currentTime = this.audioContext.currentTime;
                const timeSinceLastBeat = currentTime - this.lastBeatTime;

                // Trigger sounds at specific phases of the heartbeat
                if (heartbeatPhase < 0.1 && timeSinceLastBeat > this.quarterNoteDuration * 0.8) {
                    // Systole start - play kick and bass
                    this.playKick(0.8);
                    this.playBass(0.6);
                    visualRhythmEffects.triggerFlash(0.8, [255, 100, 100]); // Red flash for kick
                    this.lastBeatTime = currentTime;
                } else if (heartbeatPhase > 0.25 && heartbeatPhase < 0.35 && timeSinceLastBeat > this.quarterNoteDuration * 0.5) {
                    // Systole peak - play snare
                    this.playSnare(0.7);
                    visualRhythmEffects.triggerFlash(0.6, [100, 255, 100]); // Green flash for snare
                    this.lastBeatTime = currentTime;
                } else if (heartbeatPhase > 0.6 && heartbeatPhase < 0.7 && timeSinceLastBeat > this.quarterNoteDuration * 0.3) {
                    // Diastole - play hihat
                    this.playHihat(0.4);
                    visualRhythmEffects.triggerFlash(0.3, [100, 100, 255]); // Blue flash for hihat
                    this.lastBeatTime = currentTime;
                }
            }

            // Create kick drum sound
            playKick(volume = 0.8) {
                if (!this.audioContext) return;

                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain || this.audioContext.destination);

                // Kick drum envelope
                oscillator.frequency.setValueAtTime(150, now);
                oscillator.frequency.exponentialRampToValueAtTime(60, now + 0.1);

                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

                oscillator.start(now);
                oscillator.stop(now + 0.15);
            }

            // Create snare drum sound
            playSnare(volume = 0.7) {
                if (!this.audioContext) return;

                const now = this.audioContext.currentTime;
                const noise = this.createNoiseBuffer();
                const noiseSource = this.audioContext.createBufferSource();
                const gainNode = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();

                noiseSource.buffer = noise;
                noiseSource.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.masterGain || this.audioContext.destination);

                // Snare characteristics
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(1000, now);
                filter.Q.setValueAtTime(5, now);

                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.005);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.08);

                noiseSource.start(now);
                noiseSource.stop(now + 0.08);
            }

            // Create hihat sound
            playHihat(volume = 0.4) {
                if (!this.audioContext) return;

                const now = this.audioContext.currentTime;
                const noise = this.createNoiseBuffer();
                const noiseSource = this.audioContext.createBufferSource();
                const gainNode = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();

                noiseSource.buffer = noise;
                noiseSource.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.masterGain || this.audioContext.destination);

                // Hi-hat characteristics
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(7000, now);
                filter.Q.setValueAtTime(1, now);

                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.005);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.05);

                noiseSource.start(now);
                noiseSource.stop(now + 0.05);
            }

            // Create bass sound
            playBass(volume = 0.6) {
                if (!this.audioContext) return;

                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain || this.audioContext.destination);

                // Bass characteristics - low frequency
                oscillator.frequency.setValueAtTime(80, now);
                oscillator.type = 'triangle';

                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.12);

                oscillator.start(now);
                oscillator.stop(now + 0.12);
            }

            // Create noise buffer for percussion
            createNoiseBuffer() {
                const bufferSize = this.audioContext.sampleRate * 0.1; // 100ms buffer
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }

                return buffer;
            }
        }


        // Fonction pour créer une animation de parapluie
        function createUmbrellaAnimation(containerId) {
            return new p5((p) => {
                // Variables locales pour cette instance
                let centerX, centerY;
                let umbrellaRadius = 45; // Divisé par 2 pour s'adapter au canvas 100x100
                let handleRadius = 8;
                let numSegments = 8;

                let animationState = 'closed';
                let currentOpenFactor = 0;
                let targetOpenFactor = 0;
                let animationSpeed = 0.025; // Faster for better responsiveness
                let animationActive = false;
                let bounceFactor = 0; // For natural bounce effect

                // Enhanced audio functions with spatial positioning and randomization
                function playOpenSound() {
                    // Vary volume based on how open the umbrella currently is
                    let baseVolume = 0.6 + (currentOpenFactor * 0.3); // 0.6 to 0.9
                    let randomVariation = p.random(-0.1, 0.1); // ±10% variation
                    let finalVolume = Math.max(0.3, Math.min(0.9, baseVolume + randomVariation));

                    // Calculate spatial position based on umbrella position on screen
                    const position = {
                        x: (centerX - p.width/2) * 0.01,  // Convert to audio space (-5 to 5)
                        y: (centerY - p.height/2) * 0.01,
                        z: currentOpenFactor * 2  // Closer when more open
                    };

                    audioManager.playOpen(finalVolume, position);

                }

                function playCloseSound() {
                    // Closing sound gets louder as umbrella closes
                    let baseVolume = 0.5 + ((1 - currentOpenFactor) * 0.4); // 0.5 to 0.9
                    let randomVariation = p.random(-0.08, 0.08); // ±8% variation
                    let finalVolume = Math.max(0.4, Math.min(0.8, baseVolume + randomVariation));

                    // Calculate spatial position
                    const position = {
                        x: (centerX - p.width/2) * 0.01,
                        y: (centerY - p.height/2) * 0.01,
                        z: (1 - currentOpenFactor) * 2  // Closer when more closed
                    };

                    audioManager.playClose(finalVolume, position);

                }

                function playHoverSound() {
                    // Disabled hover sound to keep only open/close sounds
                }


                function addHeartbeatPulseEffect(intensity) {
                    // Add subtle visual pulse effect based on heartbeat
                    // This could be enhanced with background color changes or scale effects
                    // For now, we'll store the intensity for potential use in draw functions
                    this.heartbeatPulse = intensity;
                }

                let segmentDelays = [];
                let lastStateChange = 0;
                let hasPlayedHoverSound = false; // Track if we've played hover sound for this umbrella
                let lastHoverTime = 0;

                // Single red color for all umbrella segments
                let umbrellaColor = '#FF0000';

                p.setup = function() {
                    let canvas = p.createCanvas(100, 100);
                    canvas.parent(containerId);

                    centerX = p.width / 2;
                    centerY = p.height / 2;

                    p.angleMode(p.DEGREES);

                    for (let i = 0; i < numSegments; i++) {
                        segmentDelays[i] = i * 0.05;
                    }
                };

                p.draw = function() {
                    updateAnimation();
                    drawBackground();
                    drawUmbrella(currentOpenFactor);
                    drawHandle();
                };


                function updateAnimation() {
                    // Update global heartbeat simulator
                    heartbeatSimulator.update();

                    // Get current heartbeat intensity
                    const heartbeatIntensity = heartbeatSimulator.getHeartbeatIntensity();
                    const isSystole = heartbeatSimulator.isSystole();
                    const isDiastole = heartbeatSimulator.isDiastole();

                    // Synchronize all umbrellas with heartbeat rhythm
                    // During systole (contraction): umbrellas close
                    // During diastole (relaxation): umbrellas open

                    const targetState = isSystole ? 0 : 1; // 0 = closed, 1 = open

                    // Only trigger state change when crossing phase boundaries
                    if (isSystole && (animationState === 'open' || animationState === 'opening')) {
                        if (!animationActive) {
                            animationActive = true;
                            lastStateChange = p.millis();
                        }
                        startClosing();
                    } else if (isDiastole && (animationState === 'closed' || animationState === 'closing')) {
                        if (!animationActive) {
                            animationActive = true;
                            lastStateChange = p.millis();
                        }
                        startOpening();
                    }

                    // Continue animation if active
                    if (animationState === 'opening' || animationState === 'closing') {
                        animateToTarget();
                    }

                    // Update quartet rhythm synchronized with heartbeat
                    const currentBPM = heartbeatSimulator.getCurrentBPM();
                    audioManager.updateQuartetRhythm(heartbeatSimulator.heartbeatPhase, currentBPM);

                    // Add subtle pulsing effect based on heartbeat intensity
                    addHeartbeatPulseEffect(heartbeatIntensity);
                }

                function startOpening() {
                    animationState = 'opening';
                    targetOpenFactor = 1;
                }

                function startClosing() {
                    animationState = 'closing';
                    targetOpenFactor = 0;
                }

                function animateToTarget() {
                    let difference = targetOpenFactor - currentOpenFactor;

                    if (p.abs(difference) < 0.005) { // Slightly higher threshold for faster completion
                        currentOpenFactor = targetOpenFactor;
                        bounceFactor = 0;

                        if (targetOpenFactor === 1) {
                            animationState = 'open';
                        } else if (targetOpenFactor === 0) {
                            animationState = 'closed';
                        }
                        animationActive = false;
                        return;
                    }

                    // More responsive easing
                    let easing = 0.18; // Increased for faster response
                    let easedDifference = difference * easing;

                    // Reduced bounce effect for quicker completion
                    if (p.abs(difference) < 0.15) {
                        bounceFactor = p.sin(p.millis() * 0.03) * 0.01 * (1 - p.abs(difference) * 6);
                        easedDifference += bounceFactor;
                    }

                    currentOpenFactor += easedDifference;

                    // Ensure we don't overshoot
                    if ((difference > 0 && currentOpenFactor > targetOpenFactor) ||
                        (difference < 0 && currentOpenFactor < targetOpenFactor)) {
                        currentOpenFactor = targetOpenFactor;
                    }
                }

                function drawBackground() {
                    // Fond noir dramatique pour effet élégant
                    let baseColor = 15; // Base color value
                    let r = baseColor, g = baseColor, b = baseColor;

                    // Add heartbeat pulse effect
                    if (this.heartbeatPulse !== undefined) {
                        // Subtle color variation based on heartbeat intensity
                        const pulseIntensity = this.heartbeatPulse * 0.1; // Very subtle effect
                        baseColor = p.lerp(baseColor, 25, pulseIntensity);
                        r = g = b = baseColor;
                    }

                    // Add quartet rhythm flash effects
                    visualRhythmEffects.update();
                    const flashIntensity = visualRhythmEffects.getFlashIntensity();
                    if (flashIntensity > 0) {
                        const flashColor = visualRhythmEffects.getFlashColor();
                        r = p.lerp(r, flashColor[0], flashIntensity * 0.3);
                        g = p.lerp(g, flashColor[1], flashIntensity * 0.3);
                        b = p.lerp(b, flashColor[2], flashIntensity * 0.3);
                    }

                    p.background(r, g, b);
                }

                function drawUmbrella(openFactor) {
                    p.push();
                    p.translate(centerX, centerY);

                    // Ombre portée sous le parapluie
                    drawShadow(openFactor);

                    let segmentAngle = 360 / numSegments;

                    for (let i = 0; i < numSegments; i++) {
                        p.push();
                        p.rotate(i * segmentAngle);

                        let segmentOpenFactor = calculateSegmentOpenFactor(i, openFactor);

                        // Create realistic red fabric gradient for umbrella canopy
                        let gradient = p.drawingContext.createRadialGradient(0, 0, 0, 0, 0, umbrellaRadius * openFactor);
                        // More realistic fabric colors - darker burgundy at center, bright red at edges
                        let centerColor = p.color('#7B0F0F'); // Dark burgundy at center (fabric fold)
                        let edgeColor = p.color('#E53E3E');   // Bright red at edges
                        let brightness = p.map(segmentOpenFactor, 0, 1, 0.85, 1); // Slightly more contrast

                        // Apply brightness adjustment to both colors
                        centerColor = p.lerpColor(centerColor, p.color(0, 0, 0), 1 - brightness);
                        edgeColor = p.lerpColor(edgeColor, p.color(0, 0, 0), 1 - brightness);

                        gradient.addColorStop(0, centerColor.toString('#rrggbb'));
                        gradient.addColorStop(1, edgeColor.toString('#rrggbb'));

                        p.drawingContext.fillStyle = gradient;
                        // Contours gris foncés pour se détacher du fond noir
                        p.stroke(80, 80, 80, p.map(segmentOpenFactor, 0, 1, 180, 255));
                        p.strokeWeight(2.5);

                        drawUmbrellaSegment(segmentOpenFactor, segmentAngle);
                        p.pop();
                    }

                    // Shading et détails au-dessus des segments
                    drawShading(openFactor);
                    drawCanopyRim(openFactor);
                    drawRibTips(openFactor);

                    p.pop();
                }

                function calculateSegmentOpenFactor(segmentIndex, globalOpenFactor) {
                    let delay = segmentDelays[segmentIndex];
                    let easedFactor = easeInOutCubic(globalOpenFactor);
                    let delayedFactor = sigmoid((easedFactor - delay) * 8);
                    return p.constrain(delayedFactor, 0, 1);
                }

                function easeInOutCubic(t) {
                    return t < 0.5 ? 4 * t * t * t : 1 - p.pow(-2 * t + 2, 3) / 2;
                }

                function sigmoid(x) {
                    return 1 / (1 + p.exp(-x));
                }

                function drawUmbrellaSegment(openFactor, segmentAngle) {
                    let segmentWidth = segmentAngle * openFactor;
                    let currentRadius = umbrellaRadius * openFactor;

                    // Create more realistic curved segment shape
                    p.beginShape();

                    // Start at center
                    p.vertex(0, 0);

                    // Create curved edge using quadratic bezier curves for realistic fabric drape
                    let steps = 20;
                    for (let i = 0; i <= steps; i++) {
                        let t = i / steps;
                        let angle = p.lerp(-segmentWidth/2, segmentWidth/2, t);

                        // Add some fabric sag for realism (parabolic curve)
                        let sagFactor = 0.15; // How much the fabric sags
                        let sag = p.sin(t * p.PI) * sagFactor * currentRadius;

                        let x = p.cos(angle) * (currentRadius - sag);
                        let y = p.sin(angle) * (currentRadius - sag);
                        p.vertex(x, y);
                    }

                    p.endShape(p.CLOSE);

                    // More realistic rib structure with curves
                    p.stroke(101, 67, 33); // Darker brown for realistic wood/metal
                    p.strokeWeight(2.8);
                    p.strokeCap(p.ROUND);

                    // Main rib with slight curve
                    let ribStartX = p.cos(-segmentWidth/2) * currentRadius * 0.1;
                    let ribStartY = p.sin(-segmentWidth/2) * currentRadius * 0.1;
                    let ribEndX = p.cos(-segmentWidth/2) * currentRadius;
                    let ribEndY = p.sin(-segmentWidth/2) * currentRadius;

                    // Add slight curve to rib for realism
                    let midX = (ribStartX + ribEndX) / 2;
                    let midY = (ribStartY + ribEndY) / 2 - currentRadius * 0.05;

                    p.noFill();
                    p.beginShape();
                    p.vertex(ribStartX, ribStartY);
                    p.quadraticVertex(midX, midY, ribEndX, ribEndY);
                    p.endShape();

                    // Second rib
                    ribStartX = p.cos(segmentWidth/2) * currentRadius * 0.1;
                    ribStartY = p.sin(segmentWidth/2) * currentRadius * 0.1;
                    ribEndX = p.cos(segmentWidth/2) * currentRadius;
                    ribEndY = p.sin(segmentWidth/2) * currentRadius;

                    midX = (ribStartX + ribEndX) / 2;
                    midY = (ribStartY + ribEndY) / 2 - currentRadius * 0.05;

                    p.beginShape();
                    p.vertex(ribStartX, ribStartY);
                    p.quadraticVertex(midX, midY, ribEndX, ribEndY);
                    p.endShape();

                    // Add cross braces for extra realism
                    if (openFactor > 0.7) {
                        p.strokeWeight(1.5);
                        p.stroke(80, 50, 30, 150);
                        let braceY = currentRadius * 0.6;
                        p.line(-currentRadius * 0.3, braceY, currentRadius * 0.3, braceY);
                    }
                }

                // Bordure lisse pour un rendu propre (sans ondulations)
                function drawCanopyRim(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    p.noFill();
                    p.stroke(120, 120, 120, 120);  // Much darker and less opaque
                    p.strokeWeight(1.5);             // Slightly thinner
                    p.circle(0, 0, baseR * 2);
                }

                // Enhanced fabric shading for realistic material appearance
                function drawShading(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    p.push();
                    p.noStroke();

                    // Fabric texture simulation with subtle radial shading
                    for (let i = 0; i <= 8; i++) {
                        let t = i / 8;
                        let r = p.lerp(baseR * 0.3, baseR * 0.9, t);
                        let alpha = p.lerp(8, 25, t) * openFactor;
                        p.fill(0, 0, 0, alpha);
                        p.circle(0, 0, r * 2);
                    }

                    // Add fabric fold highlights for realism
                    if (openFactor > 0.6) {
                        // Subtle crease lines
                        p.stroke(255, 255, 255, 15 * openFactor);
                        p.strokeWeight(0.8);
                        p.noFill();

                        let creaseR = baseR * 0.7;
                        for (let i = 0; i < numSegments; i++) {
                            let angle = (i * 360 / numSegments) + 15; // Offset for natural look
                            let x1 = p.cos(angle) * creaseR * 0.8;
                            let y1 = p.sin(angle) * creaseR * 0.8;
                            let x2 = p.cos(angle) * creaseR * 1.1;
                            let y2 = p.sin(angle) * creaseR * 1.1;
                            p.line(x1, y1, x2, y2);
                        }
                    }

                    // Enhanced highlight for fabric sheen
                    p.noStroke();
                    p.fill(255, 100, 100, 12 * openFactor); // Slight reddish highlight
                    p.ellipse(-baseR * 0.3, -baseR * 0.3, baseR * 0.5, baseR * 0.25);

                    // Additional specular highlight
                    p.fill(255, 255, 255, 8 * openFactor);
                    p.ellipse(-baseR * 0.2, -baseR * 0.2, baseR * 0.2, baseR * 0.1);

                    p.pop();
                }

                // Realistic rib tips with metallic finish
                function drawRibTips(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    let segmentAngle = 360 / numSegments;

                    for (let i = 0; i < numSegments; i++) {
                        let a = i * segmentAngle;
                        let x = p.cos(a) * baseR;
                        let y = p.sin(a) * baseR;

                        // Metallic rib tip with highlight
                        p.noStroke();
                        p.fill(180, 180, 190); // Base metallic color
                        p.circle(x, y, p.max(2, baseR * 0.08));

                        // Highlight for 3D effect
                        p.fill(220, 220, 230, 200);
                        p.circle(x - 0.5, y - 0.5, p.max(1, baseR * 0.04));
                    }
                }

                function drawShadow(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    p.push();
                    p.noStroke();

                    // More realistic shadow with gradient and multiple layers
                    for (let i = 0; i < 3; i++) {
                        let alpha = 60 - i * 15;
                        let scale = 1.2 + i * 0.2;
                        let offset = baseR * (0.1 + i * 0.05);
                        p.fill(0, 0, 0, alpha * openFactor);
                        p.ellipse(0, offset, baseR * scale, baseR * (0.4 + i * 0.1));
                    }

                    // Add subtle shadow from handle
                    p.fill(0, 0, 0, 30 * openFactor);
                    p.ellipse(0, -baseR * 0.2, baseR * 0.3, baseR * 0.8);
                    p.pop();
                }

                function drawHandle() {
                    // More realistic central hub with metallic finish
                    p.push();
                    p.translate(centerX, centerY);

                    // Main hub
                    p.noStroke();
                    p.fill(50, 50, 60); // Dark metallic
                    p.circle(0, 0, 8);

                    // Metallic ring
                    p.stroke(80, 80, 90);
                    p.strokeWeight(1.5);
                    p.noFill();
                    p.circle(0, 0, 7);

                    // Highlight for 3D effect
                    p.noStroke();
                    p.fill(120, 120, 140, 180);
                    p.circle(-1, -1, 4);

                    // Central rivet
                    p.fill(30, 30, 40);
                    p.circle(0, 0, 2);

                    p.pop();
                }
            });
        }

        // Créer le maximum de parapluies possible
        function createMaximumUmbrellas() {
            const container = document.getElementById('canvases-container');
            const canvasSize = 100; // Taille d'un canvas (divisée par 2)
            const gap = 10; // Espace entre les canvas (divisé par 2)
            const totalCanvasSize = canvasSize + gap;

            // Calculer le nombre maximum de canvas qui peuvent tenir
            const availableWidth = window.innerWidth - 40; // Marges
            const availableHeight = window.innerHeight - 40; // Juste les marges (pas de titre)

            const maxCols = Math.floor(availableWidth / totalCanvasSize);
            const maxRows = Math.floor(availableHeight / totalCanvasSize);
            const totalCanvases = Math.min(maxCols * maxRows, 200); // Limite augmentée à 200 grâce aux canvas plus petits

            console.log(`Création de ${totalCanvases} parapluies maximum (${maxCols}x${maxRows} possible)`);

            // Créer les éléments HTML dynamiquement
            for (let i = 0; i < totalCanvases; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'canvas-wrapper';

                const canvasDiv = document.createElement('div');
                canvasDiv.id = `sketch-container-${i + 1}`;

                wrapper.appendChild(canvasDiv);
                container.appendChild(wrapper);
            }

            // Créer les instances d'animation
            const umbrellas = [];
            for (let i = 0; i < totalCanvases; i++) {
                umbrellas.push(createUmbrellaAnimation(`sketch-container-${i + 1}`));
            }

            return umbrellas;
        }

        // Créer tous les parapluies
        let allUmbrellas = createMaximumUmbrellas();

        // Gérer le redimensionnement de la fenêtre
        window.addEventListener('resize', function() {
            // Supprimer les anciens canvas
            const container = document.getElementById('canvases-container');
            container.innerHTML = '';

            // Arrêter les anciennes instances p5
            allUmbrellas.forEach(umbrella => {
                if (umbrella && umbrella.remove) {
                    umbrella.remove();
                }
            });

            // Recréer avec les nouvelles dimensions
            allUmbrellas = createMaximumUmbrellas();
        });
    </script>

    <script>
        // Enhanced Audio Configuration with multiple sound sources
        (function initAudioDefaults(){
            // Primary audio elements
            const openEl = document.getElementById('audio-open');
            const closeEl = document.getElementById('audio-close');

            // Audio pool elements
            const open1El = document.getElementById('audio-open-1');
            const open2El = document.getElementById('audio-open-2');
            const close1El = document.getElementById('audio-close-1');
            const close2El = document.getElementById('audio-close-2');

            // Audio file paths (you can replace these with different sounds)
            const basePath = (location.hostname === "127.0.0.1" || location.hostname === "localhost")
                ? "assets/"
                : "/hack/umbrella/assets/";

            // For now, use the same sound file for all (you can replace with different sounds)
            const openSound = basePath + "audio.mp3";
            const closeSound = basePath + "audio.mp3";

            console.info('[AUDIO] Initializing enhanced audio system');

            // Set sources for all audio elements
            const allAudioElements = [openEl, closeEl, open1El, open2El, close1El, close2El];
            allAudioElements.forEach((el, index) => {
                if (el && !el.src) {
                    // Alternate between open and close sounds
                    el.src = (index % 2 === 0) ? openSound : closeSound;
                }
            });

            console.info('[AUDIO] Sources set for all audio elements');

            // Marqueurs globaux
            window.__audioUnlocked = false;
            window.__audioReady = false;

            // Mark ready when all audio elements are loaded
            let loadedCount = 0;
            const totalElements = allAudioElements.length;
            const markReady = () => {
                loadedCount++;
                console.info(`[AUDIO] ${loadedCount}/${totalElements} elements loaded`);
                if (loadedCount >= totalElements) {
                    window.__audioReady = true;
                    console.info('[AUDIO] All elements ready - audio system active!');
                }
            };

            allAudioElements.forEach(el => {
                if (el) el.addEventListener('canplaythrough', markReady, { once: true });
            });

            const unlock = async (ev) => {
                console.info('[AUDIO] unlock gesture', ev && ev.type);
                try {
                    // Unlock all audio elements by playing them muted first
                    allAudioElements.forEach(el => { if (el) el.muted = true; });

                    const playPromises = allAudioElements.map(el =>
                        el ? el.play() : Promise.resolve()
                    );

                    await Promise.allSettled(playPromises);

                    // Pause all and unmute
                    allAudioElements.forEach(el => {
                        if (el) {
                            el.pause();
                            el.muted = false;
                        }
                    });

                    // Resume Web Audio context if available
                    await audioManager.resumeContext();

                    // Mark as unlocked and set master volume
                    window.__audioUnlocked = true;
                    audioManager.setMasterVolume(0.4); // Set comfortable default volume
                    console.info('[AUDIO] All elements unlocked and Web Audio ready!');

                } catch(e) {
                    console.warn('[AUDIO] unlock failed', e);
                } finally {
                    window.removeEventListener('pointerdown', unlock);
                    window.removeEventListener('keydown', unlock);
                }
            };
            window.addEventListener('pointerdown', unlock, { once: true });
            window.addEventListener('keydown', unlock, { once: true });
            console.info('[AUDIO] bootstrap done, waiting for user gesture...');
        })();

        // Fullscreen Functionality
        (function initFullscreen() {
            const fullscreenBtn = document.getElementById('fullscreen-btn');

            // Check if fullscreen is supported
            const fullscreenEnabled = document.fullscreenEnabled ||
                                    document.webkitFullscreenEnabled ||
                                    document.mozFullScreenEnabled ||
                                    document.msFullscreenEnabled;

            if (!fullscreenEnabled) {
                fullscreenBtn.style.display = 'none';
                console.info('[FULLSCREEN] Not supported, hiding button');
                return;
            }

            function isFullscreen() {
                return document.fullscreenElement ||
                       document.webkitFullscreenElement ||
                       document.mozFullScreenElement ||
                       document.msFullscreenElement;
            }

            function updateButtonState() {
                const inFullscreen = isFullscreen();
                fullscreenBtn.classList.toggle('fullscreen', inFullscreen);
            }

            async function toggleFullscreen() {
                try {
                    if (isFullscreen()) {
                        // Exit fullscreen
                        if (document.exitFullscreen) {
                            await document.exitFullscreen();
                        } else if (document.webkitExitFullscreen) {
                            await document.webkitExitFullscreen();
                        } else if (document.mozCancelFullScreen) {
                            await document.mozCancelFullScreen();
                        } else if (document.msExitFullscreen) {
                            await document.msExitFullscreen();
                        }
                    } else {
                        // Enter fullscreen
                        const element = document.documentElement;
                        if (element.requestFullscreen) {
                            await element.requestFullscreen();
                        } else if (element.webkitRequestFullscreen) {
                            await element.webkitRequestFullscreen();
                        } else if (element.mozRequestFullScreen) {
                            await element.mozRequestFullScreen();
                        } else if (element.msRequestFullscreen) {
                            await element.msRequestFullscreen();
                        }
                    }
                } catch (error) {
                    console.warn('[FULLSCREEN] Toggle failed:', error);
                }
            }

            // Button click handler
            fullscreenBtn.addEventListener('click', toggleFullscreen);

            // Keyboard shortcuts (F11 and Escape)
            document.addEventListener('keydown', (event) => {
                if (event.key === 'F11') {
                    event.preventDefault();
                    toggleFullscreen();
                } else if (event.key === 'Escape' && isFullscreen()) {
                    toggleFullscreen();
                }
            });

            // Listen for fullscreen changes
            function handleFullscreenChange() {
                updateButtonState();

                // Recalculate umbrellas when entering/exiting fullscreen
                setTimeout(() => {
                    const resizeEvent = new Event('resize');
                    window.dispatchEvent(resizeEvent);
                }, 100); // Small delay to ensure fullscreen change is complete
            }

            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);

            // Initial state update
            updateButtonState();

            console.info('[FULLSCREEN] Initialized successfully');
        })();

        // Heartbeat Display Update Function
        function updateHeartbeatDisplay() {
            // Only update if debug mode is enabled
            if (!isDebugMode()) return;

            const bpmElement = document.getElementById('bpm-value');
            const phaseElement = document.getElementById('heartbeat-phase');
            const controlsDisplay = document.getElementById('bpm-display');

            if (bpmElement && phaseElement) {
                // Update BPM value
                const currentBPM = heartbeatSimulator.getCurrentBPM();
                bpmElement.textContent = currentBPM;

                // Update phase indicator
                const isSystole = heartbeatSimulator.isSystole();
                phaseElement.textContent = isSystole ? 'Systole' : 'Diastole';

                // Add visual feedback for heartbeat phase
                phaseElement.style.color = isSystole ? '#ff6b6b' : '#4ecdc4';

                // Update controls display too
                if (controlsDisplay) {
                    controlsDisplay.textContent = `${currentBPM} BPM`;
                }
            }
        }

        // Update heartbeat display every 100ms for smooth animation
        setInterval(updateHeartbeatDisplay, 100);

        // Heartbeat Controls Functionality
        function initHeartbeatControls() {
            // Show debug elements if debug mode is enabled
            showDebugElements();

            // If not in debug mode, don't initialize controls
            if (!isDebugMode()) {
                console.log('[DEBUG] Debug mode disabled - skipping heartbeat controls initialization');
                return;
            }

            const bpmDecreaseBtn = document.getElementById('bpm-decrease');
            const bpmIncreaseBtn = document.getElementById('bpm-increase');
            const bpmDisplay = document.getElementById('bpm-display');
            const pauseBtn = document.getElementById('heartbeat-pause');

            if (!bpmDecreaseBtn || !bpmIncreaseBtn || !bpmDisplay || !pauseBtn) {
                console.warn('[HEARTBEAT] Control elements not found');
                return;
            }

            // Update display function
            function updateBPMDisplay() {
                const currentBPM = heartbeatSimulator.getCurrentBPM();
                bpmDisplay.textContent = `${currentBPM} BPM`;
                pauseBtn.textContent = heartbeatSimulator.isBeating ? '⏸️' : '▶️';
            }

            // Event listeners
            bpmDecreaseBtn.addEventListener('click', () => {
                const newBPM = Math.max(40, heartbeatSimulator.baseBPM - 5);
                heartbeatSimulator.baseBPM = newBPM;
                updateBPMDisplay();
                console.info(`[HEARTBEAT] BPM decreased to ${newBPM}`);
            });

            bpmIncreaseBtn.addEventListener('click', () => {
                const newBPM = Math.min(150, heartbeatSimulator.baseBPM + 5);
                heartbeatSimulator.baseBPM = newBPM;
                updateBPMDisplay();
                console.info(`[HEARTBEAT] BPM increased to ${newBPM}`);
            });

            pauseBtn.addEventListener('click', () => {
                heartbeatSimulator.setPaused(!heartbeatSimulator.isBeating);
                updateBPMDisplay();
            });

            // Initial update
            updateBPMDisplay();

            // Start quartet rhythm if audio is ready
            if (audioManager.isReady()) {
                audioManager.startQuartetRhythm();
            }

            console.info('[HEARTBEAT] Controls initialized');
        }

        // Initialize controls when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                showDebugElements(); // Show debug elements immediately
                initHeartbeatControls();
            });
        } else {
            showDebugElements(); // Show debug elements immediately
            initHeartbeatControls();
        }

        console.info('[HEARTBEAT] Display system initialized');
    </script>
</body>
</html>
