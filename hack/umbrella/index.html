<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation Parapluie - Vue du Haut</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0F0F0F; /* Noir élégant pour effet dramatique */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        #sketch-container {
            /* Bordure et ombre retirées pour un look plus propre */
            cursor: pointer; /* Curseur pointer pour indiquer l'interactivité */
            transition: opacity 0.3s ease; /* Transition douce pour les effets */
        }

        .canvases-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, 100px);
            gap: 10px;
            justify-content: center;
            padding: 10px;
            max-width: 100vw;
            box-sizing: border-box;
        }

        .canvas-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100px;
            height: 100px;
        }

        .canvas-wrapper div[id^="sketch-container-"] {
            cursor: pointer;
            transition: opacity 0.3s ease;
        }

        .canvas-wrapper div[id^="sketch-container-"]:hover {
            opacity: 0.95;
        }
        .title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ecf0f1;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="canvases-container" class="canvases-container"></div>

    <!-- Enhanced Audio System for Umbrella Sounds -->
    <audio id="audio-open" preload="auto" muted playsinline style="display:none"></audio>
    <audio id="audio-close" preload="auto" muted playsinline style="display:none"></audio>

    <!-- Audio pool for multiple simultaneous sounds -->
    <audio id="audio-open-1" preload="auto" muted playsinline style="display:none"></audio>
    <audio id="audio-open-2" preload="auto" muted playsinline style="display:none"></audio>
    <audio id="audio-close-1" preload="auto" muted playsinline style="display:none"></audio>
    <audio id="audio-close-2" preload="auto" muted playsinline style="display:none"></audio>

    <script>
        // Enhanced Audio Manager for realistic umbrella sounds
        class UmbrellaAudioManager {
            constructor() {
                this.masterVolume = 0.4; // Overall volume control (0-1)
                this.openPool = [
                    document.getElementById('audio-open'),
                    document.getElementById('audio-open-1'),
                    document.getElementById('audio-open-2')
                ];
                this.closePool = [
                    document.getElementById('audio-close'),
                    document.getElementById('audio-close-1'),
                    document.getElementById('audio-close-2')
                ];
                this.currentOpenIndex = 0;
                this.currentCloseIndex = 0;
                this.lastPlayTime = 0;
                this.minPlayInterval = 150; // Minimum time between sounds (ms)
            }

            isReady() {
                return window.__audioUnlocked === true && window.__audioReady === true;
            }

            playOpen(volume = 1.0) {
                if (!this.isReady()) return;

                const now = Date.now();
                if (now - this.lastPlayTime < this.minPlayInterval) return;

                const audio = this.openPool[this.currentOpenIndex];
                if (audio && audio.src) {
                    try {
                        audio.volume = this.masterVolume * volume;
                        audio.currentTime = 0;
                        audio.play();
                        this.currentOpenIndex = (this.currentOpenIndex + 1) % this.openPool.length;
                        this.lastPlayTime = now;
                    } catch(e) {
                        console.warn('Audio play failed:', e);
                    }
                }
            }

            playClose(volume = 1.0) {
                if (!this.isReady()) return;

                const now = Date.now();
                if (now - this.lastPlayTime < this.minPlayInterval) return;

                const audio = this.closePool[this.currentCloseIndex];
                if (audio && audio.src) {
                    try {
                        audio.volume = this.masterVolume * volume;
                        audio.currentTime = 0;
                        audio.play();
                        this.currentCloseIndex = (this.currentCloseIndex + 1) % this.closePool.length;
                        this.lastPlayTime = now;
                    } catch(e) {
                        console.warn('Audio play failed:', e);
                    }
                }
            }

            setMasterVolume(volume) {
                this.masterVolume = Math.max(0, Math.min(1, volume));
            }
        }

        // Create global audio manager instance
        const audioManager = new UmbrellaAudioManager();

        // Fonction pour créer une animation de parapluie
        function createUmbrellaAnimation(containerId) {
            return new p5((p) => {
                // Variables locales pour cette instance
                let centerX, centerY;
                let umbrellaRadius = 45; // Divisé par 2 pour s'adapter au canvas 100x100
                let handleRadius = 8;
                let numSegments = 8;

                let animationState = 'closed';
                let currentOpenFactor = 0;
                let targetOpenFactor = 0;
                let animationSpeed = 0.02;
                let animationActive = false;

                // Enhanced audio functions with randomization and state-based volume
                function playOpenSound() {
                    // Vary volume based on how open the umbrella currently is
                    let baseVolume = 0.6 + (currentOpenFactor * 0.3); // 0.6 to 0.9
                    let randomVariation = p.random(-0.1, 0.1); // ±10% variation
                    let finalVolume = Math.max(0.3, Math.min(0.9, baseVolume + randomVariation));

                    audioManager.playOpen(finalVolume);
                }

                function playCloseSound() {
                    // Closing sound gets louder as umbrella closes
                    let baseVolume = 0.5 + ((1 - currentOpenFactor) * 0.4); // 0.5 to 0.9
                    let randomVariation = p.random(-0.08, 0.08); // ±8% variation
                    let finalVolume = Math.max(0.4, Math.min(0.8, baseVolume + randomVariation));

                    audioManager.playClose(finalVolume);
                }

                function playHoverSound() {
                    if (hasPlayedHoverSound) return; // Only play once per umbrella

                    const now = p.millis();
                    if (now - lastHoverTime < 2000) return; // Minimum 2 seconds between hover sounds

                    // Very quiet hover sound (20% of normal volume)
                    audioManager.playOpen(0.2);
                    hasPlayedHoverSound = true;
                    lastHoverTime = now;
                }

                let segmentDelays = [];
                let lastStateChange = 0;
                let hasPlayedHoverSound = false; // Track if we've played hover sound for this umbrella
                let lastHoverTime = 0;

                // Single red color for all umbrella segments
                let umbrellaColor = '#DC2626';

                p.setup = function() {
                    let canvas = p.createCanvas(100, 100);
                    canvas.parent(containerId);

                    centerX = p.width / 2;
                    centerY = p.height / 2;

                    p.angleMode(p.DEGREES);

                    for (let i = 0; i < numSegments; i++) {
                        segmentDelays[i] = i * 0.05;
                    }
                };

                p.draw = function() {
                    updateAnimation();
                    drawBackground();
                    drawUmbrella(currentOpenFactor);
                    drawHandle();
                };


                function updateAnimation() {
                    let mouseIsOver = p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height;

                    if (mouseIsOver) {
                        // Play subtle hover sound for first-time hover
                        playHoverSound();

                        // Fermer sur hover
                        if (animationState !== 'closing' && animationState !== 'closed') {
                            if (!animationActive) {
                                animationActive = true;
                                lastStateChange = p.millis();
                            }
                            // lancer son de fermeture une seule fois au déclenchement
                            playCloseSound();
                            if (animationState === 'open' || animationState === 'opening') {
                                startClosing();
                                lastStateChange = p.millis();
                            }
                        }

                        if (animationState === 'opening' || animationState === 'closing') {
                            animateToTarget();
                        }
                    } else {
                        // Ouvrir sur mouse out
                        if (animationState !== 'opening' && animationState !== 'open') {
                            if (!animationActive) {
                                animationActive = true;
                                lastStateChange = p.millis();
                            }
                            // lancer son d'ouverture une seule fois au déclenchement
                            playOpenSound();
                            if (animationState === 'closed' || animationState === 'closing') {
                                startOpening();
                                lastStateChange = p.millis();
                            }
                        }

                        if (animationState === 'opening' || animationState === 'closing') {
                            animateToTarget();
                        }
                    }
                }

                function startOpening() {
                    animationState = 'opening';
                    targetOpenFactor = 1;
                }

                function startClosing() {
                    animationState = 'closing';
                    targetOpenFactor = 0;
                }

                function animateToTarget() {
                    let difference = targetOpenFactor - currentOpenFactor;

                    if (p.abs(difference) < 0.001) {
                        currentOpenFactor = targetOpenFactor;

                        if (targetOpenFactor === 1) {
                            animationState = 'open';
                        } else if (targetOpenFactor === 0) {
                            animationState = 'closed';
                        }
                        return;
                    }

                    let easing = 0.15; // Plus rapide pour une animation plus dynamique
                    currentOpenFactor += difference * easing;
                }

                function drawBackground() {
                    // Fond noir dramatique pour effet élégant
                    p.background(15, 15, 15); // #0F0F0F en RGB
                }

                function drawUmbrella(openFactor) {
                    p.push();
                    p.translate(centerX, centerY);

                    // Ombre portée sous le parapluie
                    drawShadow(openFactor);

                    let segmentAngle = 360 / numSegments;

                    for (let i = 0; i < numSegments; i++) {
                        p.push();
                        p.rotate(i * segmentAngle);

                        let segmentOpenFactor = calculateSegmentOpenFactor(i, openFactor);
                        let segmentColor = p.color(umbrellaColor);
                        let brightness = p.map(segmentOpenFactor, 0, 1, 0.6, 1);
                        segmentColor = p.lerpColor(segmentColor, p.color(0, 0, 0), 1 - brightness);

                        p.fill(segmentColor);
                        // Contours gris foncés pour se détacher du fond noir
                        p.stroke(80, 80, 80, p.map(segmentOpenFactor, 0, 1, 180, 255));
                        p.strokeWeight(2.5);

                        drawUmbrellaSegment(segmentOpenFactor, segmentAngle);
                        p.pop();
                    }

                    // Shading et détails au-dessus des segments
                    drawShading(openFactor);
                    drawCanopyRim(openFactor);
                    drawRibTips(openFactor);

                    p.pop();
                }

                function calculateSegmentOpenFactor(segmentIndex, globalOpenFactor) {
                    let delay = segmentDelays[segmentIndex];
                    let easedFactor = easeInOutCubic(globalOpenFactor);
                    let delayedFactor = sigmoid((easedFactor - delay) * 8);
                    return p.constrain(delayedFactor, 0, 1);
                }

                function easeInOutCubic(t) {
                    return t < 0.5 ? 4 * t * t * t : 1 - p.pow(-2 * t + 2, 3) / 2;
                }

                function sigmoid(x) {
                    return 1 / (1 + p.exp(-x));
                }

                function drawUmbrellaSegment(openFactor, segmentAngle) {
                    let segmentWidth = segmentAngle * openFactor;
                    let currentRadius = umbrellaRadius * openFactor;

                    p.beginShape();
                    p.vertex(0, 0);

                    for (let a = -segmentWidth/2; a <= segmentWidth/2; a += 2) {
                        let x = p.cos(a) * currentRadius;
                        let y = p.sin(a) * currentRadius;
                        p.vertex(x, y);
                    }

                    p.endShape(p.CLOSE);

                    // Baleines du parapluie avec un rouge plus visible sur fond noir
                    p.stroke(139, 69, 19); // #8B4513 - Brun rouge qui ressort sur noir
                    p.strokeWeight(3.5);
                    p.line(0, 0, p.cos(-segmentWidth/2) * currentRadius, p.sin(-segmentWidth/2) * currentRadius);
                    p.line(0, 0, p.cos(segmentWidth/2) * currentRadius, p.sin(segmentWidth/2) * currentRadius);
                }

                // Bordure lisse pour un rendu propre (sans ondulations)
                function drawCanopyRim(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    p.noFill();
                    p.stroke(120, 120, 120, 120);  // Much darker and less opaque
                    p.strokeWeight(1.5);             // Slightly thinner
                    p.circle(0, 0, baseR * 2);
                }

                // Ombrage radial + reflet directionnel
                function drawShading(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    p.push();
                    p.noStroke();
                    // assombrir vers les bords (vignette douce)
                    for (let i = 0; i <= 10; i++) {
                        let t = i / 10;
                        let r = p.lerp(baseR * 0.2, baseR, t);
                        let alpha = p.lerp(10, 50, t);
                        p.fill(0, 0, 0, alpha);
                        p.circle(0, 0, r * 2);
                    }
                    // highlight doux en haut-gauche (much subtler)
                    p.fill(255, 255, 255, 8);   // Much less bright
                    p.ellipse(-baseR * 0.25, -baseR * 0.25, baseR * 0.4, baseR * 0.2);
                    p.pop();
                }

                // Petits capuchons en bout de baleine
                function drawRibTips(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    let segmentAngle = 360 / numSegments;
                    p.fill(210, 210, 210);
                    p.noStroke();
                    for (let i = 0; i < numSegments; i++) {
                        let a = i * segmentAngle;
                        let x = p.cos(a) * baseR;
                        let y = p.sin(a) * baseR;
                        p.circle(x, y, p.max(1.5, baseR * 0.06));
                    }
                }

                function drawShadow(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    p.push();
                    p.noStroke();
                    p.fill(0, 0, 0, 80);
                    p.ellipse(0, baseR * 0.08, baseR * 1.4, baseR * 0.5);
                    p.pop();
                }

                function drawHandle() {
                    // Capuchon central réaliste
                    p.push();
                    p.translate(centerX, centerY);
                    p.noStroke();
                    p.fill(40, 40, 40);
                    p.circle(0, 0, 6);
                    p.fill(255, 255, 255, 60);
                    p.circle(-1, -1, 3);
                    p.pop();
                }
            });
        }

        // Créer le maximum de parapluies possible
        function createMaximumUmbrellas() {
            const container = document.getElementById('canvases-container');
            const canvasSize = 100; // Taille d'un canvas (divisée par 2)
            const gap = 10; // Espace entre les canvas (divisé par 2)
            const totalCanvasSize = canvasSize + gap;

            // Calculer le nombre maximum de canvas qui peuvent tenir
            const availableWidth = window.innerWidth - 40; // Marges
            const availableHeight = window.innerHeight - 40; // Juste les marges (pas de titre)

            const maxCols = Math.floor(availableWidth / totalCanvasSize);
            const maxRows = Math.floor(availableHeight / totalCanvasSize);
            const totalCanvases = Math.min(maxCols * maxRows, 200); // Limite augmentée à 200 grâce aux canvas plus petits

            console.log(`Création de ${totalCanvases} parapluies maximum (${maxCols}x${maxRows} possible)`);

            // Créer les éléments HTML dynamiquement
            for (let i = 0; i < totalCanvases; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'canvas-wrapper';

                const canvasDiv = document.createElement('div');
                canvasDiv.id = `sketch-container-${i + 1}`;

                wrapper.appendChild(canvasDiv);
                container.appendChild(wrapper);
            }

            // Créer les instances d'animation
            const umbrellas = [];
            for (let i = 0; i < totalCanvases; i++) {
                umbrellas.push(createUmbrellaAnimation(`sketch-container-${i + 1}`));
            }

            return umbrellas;
        }

        // Créer tous les parapluies
        let allUmbrellas = createMaximumUmbrellas();

        // Gérer le redimensionnement de la fenêtre
        window.addEventListener('resize', function() {
            // Supprimer les anciens canvas
            const container = document.getElementById('canvases-container');
            container.innerHTML = '';

            // Arrêter les anciennes instances p5
            allUmbrellas.forEach(umbrella => {
                if (umbrella && umbrella.remove) {
                    umbrella.remove();
                }
            });

            // Recréer avec les nouvelles dimensions
            allUmbrellas = createMaximumUmbrellas();
        });
    </script>

    <script>
        // Enhanced Audio Configuration with multiple sound sources
        (function initAudioDefaults(){
            // Primary audio elements
            const openEl = document.getElementById('audio-open');
            const closeEl = document.getElementById('audio-close');

            // Audio pool elements
            const open1El = document.getElementById('audio-open-1');
            const open2El = document.getElementById('audio-open-2');
            const close1El = document.getElementById('audio-close-1');
            const close2El = document.getElementById('audio-close-2');

            // Audio file paths (you can replace these with different sounds)
            const basePath = (location.hostname === "127.0.0.1" || location.hostname === "localhost")
                ? "assets/"
                : "/hack/umbrella/assets/";

            // For now, use the same sound file for all (you can replace with different sounds)
            const openSound = basePath + "audio.mp3";
            const closeSound = basePath + "audio.mp3";

            console.info('[AUDIO] Initializing enhanced audio system');

            // Set sources for all audio elements
            const allAudioElements = [openEl, closeEl, open1El, open2El, close1El, close2El];
            allAudioElements.forEach((el, index) => {
                if (el && !el.src) {
                    // Alternate between open and close sounds
                    el.src = (index % 2 === 0) ? openSound : closeSound;
                }
            });

            console.info('[AUDIO] Sources set for all audio elements');

            // Marqueurs globaux
            window.__audioUnlocked = false;
            window.__audioReady = false;

            // Mark ready when all audio elements are loaded
            let loadedCount = 0;
            const totalElements = allAudioElements.length;
            const markReady = () => {
                loadedCount++;
                console.info(`[AUDIO] ${loadedCount}/${totalElements} elements loaded`);
                if (loadedCount >= totalElements) {
                    window.__audioReady = true;
                    console.info('[AUDIO] All elements ready - audio system active!');
                }
            };

            allAudioElements.forEach(el => {
                if (el) el.addEventListener('canplaythrough', markReady, { once: true });
            });

            const unlock = async (ev) => {
                console.info('[AUDIO] unlock gesture', ev && ev.type);
                try {
                    // Unlock all audio elements by playing them muted first
                    allAudioElements.forEach(el => { if (el) el.muted = true; });

                    const playPromises = allAudioElements.map(el =>
                        el ? el.play() : Promise.resolve()
                    );

                    await Promise.allSettled(playPromises);

                    // Pause all and unmute
                    allAudioElements.forEach(el => {
                        if (el) {
                            el.pause();
                            el.muted = false;
                        }
                    });

                    // Mark as unlocked and set master volume
                    window.__audioUnlocked = true;
                    audioManager.setMasterVolume(0.4); // Set comfortable default volume
                    console.info('[AUDIO] All elements unlocked and ready!');

                } catch(e) {
                    console.warn('[AUDIO] unlock failed', e);
                } finally {
                    window.removeEventListener('pointerdown', unlock);
                    window.removeEventListener('keydown', unlock);
                }
            };
            window.addEventListener('pointerdown', unlock, { once: true });
            window.addEventListener('keydown', unlock, { once: true });
            console.info('[AUDIO] bootstrap done, waiting for user gesture...');
        })();
    </script>
</body>
</html>
