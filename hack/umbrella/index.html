<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation Parapluie - Vue du Haut</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0F0F0F; /* Noir élégant pour effet dramatique */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        #sketch-container {
            /* Bordure et ombre retirées pour un look plus propre */
            cursor: pointer; /* Curseur pointer pour indiquer l'interactivité */
            transition: opacity 0.3s ease; /* Transition douce pour les effets */
        }

        .canvases-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, 100px);
            gap: 10px;
            justify-content: center;
            padding: 10px;
            max-width: 100vw;
            box-sizing: border-box;
        }

        .canvas-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100px;
            height: 100px;
        }

        .canvas-wrapper div[id^="sketch-container-"] {
            cursor: pointer;
            transition: opacity 0.3s ease;
        }

        .canvas-wrapper div[id^="sketch-container-"]:hover {
            opacity: 0.95;
        }
        .title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ecf0f1;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="canvases-container" class="canvases-container"></div>

    <!-- Sons (optionnels). Déposez vos fichiers dans assets/ et mettez les src ci-dessous -->
    <audio id="audio-open" preload="auto" muted playsinline style="display:none"></audio>
    <audio id="audio-close" preload="auto" muted playsinline style="display:none"></audio>

    <script>
        // Fonction pour créer une animation de parapluie
        function createUmbrellaAnimation(containerId) {
            return new p5((p) => {
                // Variables locales pour cette instance
                let centerX, centerY;
                let umbrellaRadius = 45; // Divisé par 2 pour s'adapter au canvas 100x100
                let handleRadius = 8;
                let numSegments = 8;

                let animationState = 'closed';
                let currentOpenFactor = 0;
                let targetOpenFactor = 0;
                let animationSpeed = 0.02;
                let animationActive = false;

                // Audio refs (partagés par la page)
                const audioOpen = document.getElementById('audio-open');
                const audioClose = document.getElementById('audio-close');
                const isAudioUnlocked = () => window.__audioUnlocked === true;
                const isAudioReady = () => window.__audioReady === true && audioOpen && audioOpen.src && audioClose && audioClose.src;

                let segmentDelays = [];
                let bounceFactor = 0;
                let lastStateChange = 0;

                // Couleurs extraites du parapluie rouge de l'image
                let colors = [
                    '#DC2626', '#EF4444', '#F87171', '#FCA5A5',
                    '#B91C1C', '#991B1B', '#7F1D1D', '#450A0A'
                ];

                p.setup = function() {
                    let canvas = p.createCanvas(100, 100);
                    canvas.parent(containerId);

                    centerX = p.width / 2;
                    centerY = p.height / 2;

                    p.angleMode(p.DEGREES);

                    for (let i = 0; i < numSegments; i++) {
                        segmentDelays[i] = i * 0.05;
                    }
                };

                p.draw = function() {
                    updateAnimation();
                    drawBackground();
                    drawUmbrella(currentOpenFactor);
                    drawHandle();
                };

                function playOpenSound() {
                    if (!isAudioUnlocked() || !isAudioReady()) return;
                    try { audioOpen.currentTime = 0; audioOpen.play(); } catch(e) {}
                }
                function playCloseSound() {
                    if (!isAudioUnlocked() || !isAudioReady()) return;
                    try { audioClose.currentTime = 0; audioClose.play(); } catch(e) {}
                }

                function updateAnimation() {
                    let mouseIsOver = p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height;

                    if (mouseIsOver) {
                        // Fermer sur hover
                        if (animationState !== 'closing' && animationState !== 'closed') {
                            if (!animationActive) {
                                animationActive = true;
                                lastStateChange = p.millis();
                            }
                            // lancer son de fermeture une seule fois au déclenchement
                            playCloseSound();
                            if (animationState === 'open' || animationState === 'opening') {
                                startClosing();
                                lastStateChange = p.millis();
                            }
                        }

                        if (animationState === 'opening' || animationState === 'closing') {
                            animateToTarget();
                        }
                    } else {
                        // Ouvrir sur mouse out
                        if (animationState !== 'opening' && animationState !== 'open') {
                            if (!animationActive) {
                                animationActive = true;
                                lastStateChange = p.millis();
                            }
                            // lancer son d'ouverture une seule fois au déclenchement
                            playOpenSound();
                            if (animationState === 'closed' || animationState === 'closing') {
                                startOpening();
                                lastStateChange = p.millis();
                            }
                        }

                        if (animationState === 'opening' || animationState === 'closing') {
                            animateToTarget();
                        }
                    }
                }

                function startOpening() {
                    animationState = 'opening';
                    targetOpenFactor = 1;
                    bounceFactor = 0;
                }

                function startClosing() {
                    animationState = 'closing';
                    targetOpenFactor = 0;
                    bounceFactor = 0;
                }

                function animateToTarget() {
                    let difference = targetOpenFactor - currentOpenFactor;

                    if (p.abs(difference) < 0.001) {
                        currentOpenFactor = targetOpenFactor;

                        if (targetOpenFactor === 1) {
                            animationState = 'open';
                        } else if (targetOpenFactor === 0) {
                            animationState = 'closed';
                        }
                        return;
                    }

                    let easing = 0.15; // Plus rapide pour une animation plus dynamique
                    currentOpenFactor += difference * easing;

                    if (p.abs(difference) < 0.1) {
                        bounceFactor = p.sin(p.frameCount * 10) * 0.02;
                        currentOpenFactor += bounceFactor;
                    }
                }

                function drawBackground() {
                    // Fond noir dramatique pour effet élégant
                    p.background(15, 15, 15); // #0F0F0F en RGB
                }

                function drawUmbrella(openFactor) {
                    p.push();
                    p.translate(centerX, centerY);

                    // Ombre portée sous le parapluie
                    drawShadow(openFactor);

                    let segmentAngle = 360 / numSegments;

                    for (let i = 0; i < numSegments; i++) {
                        p.push();
                        p.rotate(i * segmentAngle);

                        let segmentOpenFactor = calculateSegmentOpenFactor(i, openFactor);
                        let segmentColor = p.color(colors[i]);
                        let brightness = p.map(segmentOpenFactor, 0, 1, 0.6, 1);
                        segmentColor = p.lerpColor(segmentColor, p.color(0, 0, 0), 1 - brightness);

                        p.fill(segmentColor);
                        // Contours gris foncés pour se détacher du fond noir
                        p.stroke(80, 80, 80, p.map(segmentOpenFactor, 0, 1, 180, 255));
                        p.strokeWeight(2.5);

                        drawUmbrellaSegment(segmentOpenFactor, segmentAngle);
                        p.pop();
                    }

                    // Shading et détails au-dessus des segments
                    drawShading(openFactor);
                    drawCanopyRim(openFactor);
                    drawRibTips(openFactor);

                    p.pop();
                }

                function calculateSegmentOpenFactor(segmentIndex, globalOpenFactor) {
                    let delay = segmentDelays[segmentIndex];
                    let easedFactor = easeInOutCubic(globalOpenFactor);
                    let delayedFactor = sigmoid((easedFactor - delay) * 8);
                    return p.constrain(delayedFactor, 0, 1);
                }

                function easeInOutCubic(t) {
                    return t < 0.5 ? 4 * t * t * t : 1 - p.pow(-2 * t + 2, 3) / 2;
                }

                function sigmoid(x) {
                    return 1 / (1 + p.exp(-x));
                }

                function drawUmbrellaSegment(openFactor, segmentAngle) {
                    let segmentWidth = segmentAngle * openFactor;
                    let currentRadius = umbrellaRadius * openFactor;

                    p.beginShape();
                    p.vertex(0, 0);

                    for (let a = -segmentWidth/2; a <= segmentWidth/2; a += 2) {
                        let x = p.cos(a) * currentRadius;
                        let y = p.sin(a) * currentRadius;
                        p.vertex(x, y);
                    }

                    p.endShape(p.CLOSE);

                    // Baleines du parapluie avec un rouge plus visible sur fond noir
                    p.stroke(139, 69, 19); // #8B4513 - Brun rouge qui ressort sur noir
                    p.strokeWeight(3.5);
                    p.line(0, 0, p.cos(-segmentWidth/2) * currentRadius, p.sin(-segmentWidth/2) * currentRadius);
                    p.line(0, 0, p.cos(segmentWidth/2) * currentRadius, p.sin(segmentWidth/2) * currentRadius);
                }

                // Bordure lisse pour un rendu propre (sans ondulations)
                function drawCanopyRim(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    p.noFill();
                    p.stroke(180, 180, 180, 220);
                    p.strokeWeight(1.8);
                    p.circle(0, 0, baseR * 2);
                }

                // Ombrage radial + reflet directionnel
                function drawShading(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    p.push();
                    p.noStroke();
                    // assombrir vers les bords (vignette douce)
                    for (let i = 0; i <= 10; i++) {
                        let t = i / 10;
                        let r = p.lerp(baseR * 0.2, baseR, t);
                        let alpha = p.lerp(10, 50, t);
                        p.fill(0, 0, 0, alpha);
                        p.circle(0, 0, r * 2);
                    }
                    // highlight doux en haut-gauche
                    p.fill(255, 255, 255, 30);
                    p.ellipse(-baseR * 0.25, -baseR * 0.25, baseR * 0.6, baseR * 0.35);
                    p.pop();
                }

                // Petits capuchons en bout de baleine
                function drawRibTips(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    let segmentAngle = 360 / numSegments;
                    p.fill(210, 210, 210);
                    p.noStroke();
                    for (let i = 0; i < numSegments; i++) {
                        let a = i * segmentAngle;
                        let x = p.cos(a) * baseR;
                        let y = p.sin(a) * baseR;
                        p.circle(x, y, p.max(1.5, baseR * 0.06));
                    }
                }

                function drawShadow(openFactor) {
                    let baseR = umbrellaRadius * openFactor;
                    if (baseR <= 0.5) return;
                    p.push();
                    p.noStroke();
                    p.fill(0, 0, 0, 80);
                    p.ellipse(0, baseR * 0.08, baseR * 1.4, baseR * 0.5);
                    p.pop();
                }

                function drawHandle() {
                    // Capuchon central réaliste
                    p.push();
                    p.translate(centerX, centerY);
                    p.noStroke();
                    p.fill(40, 40, 40);
                    p.circle(0, 0, 6);
                    p.fill(255, 255, 255, 60);
                    p.circle(-1, -1, 3);
                    p.pop();
                }
            });
        }

        // Créer le maximum de parapluies possible
        function createMaximumUmbrellas() {
            const container = document.getElementById('canvases-container');
            const canvasSize = 100; // Taille d'un canvas (divisée par 2)
            const gap = 10; // Espace entre les canvas (divisé par 2)
            const totalCanvasSize = canvasSize + gap;

            // Calculer le nombre maximum de canvas qui peuvent tenir
            const availableWidth = window.innerWidth - 40; // Marges
            const availableHeight = window.innerHeight - 40; // Juste les marges (pas de titre)

            const maxCols = Math.floor(availableWidth / totalCanvasSize);
            const maxRows = Math.floor(availableHeight / totalCanvasSize);
            const totalCanvases = Math.min(maxCols * maxRows, 200); // Limite augmentée à 200 grâce aux canvas plus petits

            console.log(`Création de ${totalCanvases} parapluies maximum (${maxCols}x${maxRows} possible)`);

            // Créer les éléments HTML dynamiquement
            for (let i = 0; i < totalCanvases; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'canvas-wrapper';

                const canvasDiv = document.createElement('div');
                canvasDiv.id = `sketch-container-${i + 1}`;

                wrapper.appendChild(canvasDiv);
                container.appendChild(wrapper);
            }

            // Créer les instances d'animation
            const umbrellas = [];
            for (let i = 0; i < totalCanvases; i++) {
                umbrellas.push(createUmbrellaAnimation(`sketch-container-${i + 1}`));
            }

            return umbrellas;
        }

        // Créer tous les parapluies
        let allUmbrellas = createMaximumUmbrellas();

        // Gérer le redimensionnement de la fenêtre
        window.addEventListener('resize', function() {
            // Supprimer les anciens canvas
            const container = document.getElementById('canvases-container');
            container.innerHTML = '';

            // Arrêter les anciennes instances p5
            allUmbrellas.forEach(umbrella => {
                if (umbrella && umbrella.remove) {
                    umbrella.remove();
                }
            });

            // Recréer avec les nouvelles dimensions
            allUmbrellas = createMaximumUmbrellas();
        });
    </script>

    <script>
        // Configurer des sons par défaut (modifiable). Nécessite un geste utilisateur pour jouer.
        (function initAudioDefaults(){
            const openEl = document.getElementById('audio-open');
            const closeEl = document.getElementById('audio-close');
            // Définir des sources par défaut (remplacez ce chemin si besoin)
            // ATTENTION: le caractère # doit être encodé en %23 dans une URL
            // If running on localhost, use a different audio file for development
            const umbrellaSfx = (location.hostname === "127.0.0.1" || location.hostname === "localhost")
                ? "assets/audio.mp3"
                : "/hack/umbrella/assets/audio.mp3";
            console.info('[AUDIO] set src', { umbrellaSfx });
            if (!openEl.src) openEl.src = umbrellaSfx;
            if (!closeEl.src) closeEl.src = umbrellaSfx;
            console.info('[AUDIO] set src', { openSrc: openEl.src, closeSrc: closeEl.src });

            // Marqueurs globaux
            window.__audioUnlocked = false;
            window.__audioReady = false;

            // Quand au moins une source peut jouer, on marque prêt
            const markReady = () => { window.__audioReady = true; console.info('[AUDIO] canplaythrough → ready=true'); };
            openEl.addEventListener('canplaythrough', markReady, { once: true });
            closeEl.addEventListener('canplaythrough', markReady, { once: true });

            const unlock = async (ev) => {
                console.info('[AUDIO] unlock gesture', ev && ev.type);
                try {
                    // Essayer de jouer en mode muet pour déverrouiller
                    openEl.muted = true; closeEl.muted = true;
                    await Promise.allSettled([openEl.play(), closeEl.play()]);
                    openEl.pause(); closeEl.pause();
                    // Déverrouiller: enlever muted et marquer l'état global
                    openEl.muted = false; closeEl.muted = false;
                    window.__audioUnlocked = true;
                    console.info('[AUDIO] unlocked=true');
                } catch(e) {
                    console.warn('[AUDIO] unlock failed', e);
                } finally {
                    window.removeEventListener('pointerdown', unlock);
                    window.removeEventListener('keydown', unlock);
                }
            };
            window.addEventListener('pointerdown', unlock, { once: true });
            window.addEventListener('keydown', unlock, { once: true });
            console.info('[AUDIO] bootstrap done, waiting for user gesture...');
        })();
    </script>
</body>
</html>
