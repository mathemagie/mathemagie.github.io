<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life</title>
    <!-- Link to the p5.js library from a CDN to enable drawing and animation functionalities. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
        /* Full screen styling with darker background for higher contrast */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000000; /* Pure black background for ultimate contrast */
            overflow: hidden; /* Prevents scrollbars */
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block; /* Removes any default margins/padding from canvas */
        }

        /* Sound toggle button styling */
        #soundToggle {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 1000;
            font-size: 24px;
            color: rgba(255, 255, 255, 0.7);
            user-select: none;
        }

        #soundToggle:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        #soundToggle.active {
            background: rgba(100, 200, 255, 0.15);
            border-color: rgba(100, 200, 255, 0.3);
            color: rgba(100, 200, 255, 0.9);
        }
    </style>
</head>
<body>
    <!-- Sound toggle button -->
    <div id="soundToggle" title="Toggle ambient sound">ðŸ”‡</div>

    <script>
        // Global variables for animation control. These variables determine the characteristics and behavior of the animation elements.
        let blob; // Represents the main amorphous organism in the center.
        let particles = []; // An array to store small, randomly moving background particles.
        let internalCircles = []; // An array to store the larger, pulsing circular elements inside the blob.
        let stars = []; // Array to store twinkling stars for Milky Way effect.
        let animationSpeed = 0.01; // Controls the overall speed of the animation. A lower value results in slower movement.
        let particleCount = 250; // The total number of small background particles.
        let internalCircleCount = 15; // The total number of internal pulsing circles within the blob.
        let starCount = 150; // Number of stars in the Milky Way background.
        let nebulaClouds = []; // Array for subtle nebula effects.
        let nebulaCount = 8; // Number of nebula clouds.
        let backgroundColorHSB; // HSB color object for the canvas background.
        let breathingPhase = 0; // Global breathing rhythm for the entire organism.

        // Audio system variables for deep ambient sound
        let audioContext;
        let oscillators = []; // Array of multiple detuned oscillators for organic texture
        let noiseNode; // Pink noise for organic texture
        let noiseGain; // Gain for noise
        let droneGain; // Master gain for drones
        let breathingGain; // Gain modulated by breathing rhythm
        let filter; // Low-pass filter for underwater effect
        let filter2; // Second filter for more complex filtering
        let lfoOsc1, lfoOsc2; // Low-frequency oscillators for modulation
        let lfoGain1, lfoGain2; // LFO gain nodes
        let soundEnabled = false; // Track if sound is currently playing

        // Enhanced natural color palettes with higher contrast for better visibility
        const naturalColorPalettes = {
            // Aquatic cellular environments - blues and cyans (increased saturation and brightness)
            aquatic: [
                {hue: 190, sat: 45, bright: 18}, // Deep ocean blue - darker background
                {hue: 200, sat: 55, bright: 25}, // Marine blue - more saturated
                {hue: 210, sat: 50, bright: 35}, // Cyan blue - brighter
                {hue: 220, sat: 60, bright: 45}  // Bright cyan - higher contrast
            ],
            // Organic cellular materials - greens and teal (increased saturation)
            organic: [
                {hue: 120, sat: 40, bright: 35}, // Forest green - more saturated
                {hue: 140, sat: 50, bright: 42}, // Sea green - brighter
                {hue: 160, sat: 45, bright: 48}, // Mint green - higher contrast
                {hue: 180, sat: 55, bright: 55}  // Teal - more vivid
            ],
            // Metabolic processes - warm organic tones (increased brightness and saturation)
            metabolic: [
                {hue: 30, sat: 35, bright: 50},  // Warm amber - more saturated
                {hue: 45, sat: 40, bright: 55},  // Golden yellow - brighter
                {hue: 15, sat: 30, bright: 60},  // Soft peach - higher contrast
                {hue: 60, sat: 45, bright: 70}   // Light yellow - very bright
            ],
            // Structural elements - purples and magentas (increased saturation and brightness)
            structural: [
                {hue: 270, sat: 40, bright: 35}, // Deep purple - more saturated
                {hue: 290, sat: 50, bright: 40}, // Magenta purple - brighter
                {hue: 310, sat: 45, bright: 50}, // Pink purple - higher contrast
                {hue: 330, sat: 55, bright: 55}  // Rose pink - more vivid
            ]
        };

        /**
         * Creates pink noise for organic texture
         */
        function createPinkNoise() {
            const bufferSize = audioContext.sampleRate * 2;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);

            // Generate pink noise using Paul Kellet's algorithm
            let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                b0 = 0.99886 * b0 + white * 0.0555179;
                b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520;
                b3 = 0.86650 * b3 + white * 0.3104856;
                b4 = 0.55000 * b4 + white * 0.5329522;
                b5 = -0.7616 * b5 - white * 0.0168980;
                output[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                b6 = white * 0.115926;
            }
            return buffer;
        }

        /**
         * Initializes the Web Audio API for deep ambient sound with organic layering
         */
        function initAudio() {
            // Create audio context
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Create multiple detuned oscillators for organic chorus effect
            // Layer 1: Deep bass drones (35-45 Hz) - creates rumbling foundation
            const bassFreqs = [35, 38, 40, 42, 45];
            bassFreqs.forEach((freq, i) => {
                const osc = audioContext.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, audioContext.currentTime);

                const oscGain = audioContext.createGain();
                oscGain.gain.setValueAtTime(0.15 / bassFreqs.length, audioContext.currentTime);

                osc.connect(oscGain);
                oscillators.push({osc: osc, gain: oscGain, baseFreq: freq, type: 'bass'});
            });

            // Layer 2: Mid-range texture (100-130 Hz) - organic warmth
            const midFreqs = [100, 108, 115, 122, 130];
            midFreqs.forEach((freq, i) => {
                const osc = audioContext.createOscillator();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(freq, audioContext.currentTime);

                const oscGain = audioContext.createGain();
                oscGain.gain.setValueAtTime(0.08 / midFreqs.length, audioContext.currentTime);

                osc.connect(oscGain);
                oscillators.push({osc: osc, gain: oscGain, baseFreq: freq, type: 'mid'});
            });

            // Layer 3: High texture (200-250 Hz) - shimmer
            const highFreqs = [200, 215, 230];
            highFreqs.forEach((freq, i) => {
                const osc = audioContext.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, audioContext.currentTime);

                const oscGain = audioContext.createGain();
                oscGain.gain.setValueAtTime(0.03 / highFreqs.length, audioContext.currentTime);

                osc.connect(oscGain);
                oscillators.push({osc: osc, gain: oscGain, baseFreq: freq, type: 'high'});
            });

            // Create pink noise for organic texture
            const pinkNoiseBuffer = createPinkNoise();
            noiseNode = audioContext.createBufferSource();
            noiseNode.buffer = pinkNoiseBuffer;
            noiseNode.loop = true;

            noiseGain = audioContext.createGain();
            noiseGain.gain.setValueAtTime(0.04, audioContext.currentTime);
            noiseNode.connect(noiseGain);

            // Create LFO oscillators for organic frequency modulation
            lfoOsc1 = audioContext.createOscillator();
            lfoOsc1.type = 'sine';
            lfoOsc1.frequency.setValueAtTime(0.08, audioContext.currentTime); // Slow modulation

            lfoGain1 = audioContext.createGain();
            lfoGain1.gain.setValueAtTime(3, audioContext.currentTime); // Modulation depth
            lfoOsc1.connect(lfoGain1);

            lfoOsc2 = audioContext.createOscillator();
            lfoOsc2.type = 'sine';
            lfoOsc2.frequency.setValueAtTime(0.13, audioContext.currentTime); // Slightly faster

            lfoGain2 = audioContext.createGain();
            lfoGain2.gain.setValueAtTime(5, audioContext.currentTime);
            lfoOsc2.connect(lfoGain2);

            // Create dual filters for complex underwater effect
            filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(450, audioContext.currentTime);
            filter.Q.setValueAtTime(3, audioContext.currentTime);

            filter2 = audioContext.createBiquadFilter();
            filter2.type = 'lowpass';
            filter2.frequency.setValueAtTime(800, audioContext.currentTime);
            filter2.Q.setValueAtTime(1.5, audioContext.currentTime);

            // Create breathing-modulated gain (will pulse with animation)
            breathingGain = audioContext.createGain();
            breathingGain.gain.setValueAtTime(0.4, audioContext.currentTime);

            // Create master gain for overall volume control
            droneGain = audioContext.createGain();
            droneGain.gain.setValueAtTime(0.2, audioContext.currentTime);

            // Connect oscillators to filter chain
            oscillators.forEach(oscData => {
                oscData.gain.connect(filter);
            });

            // Connect noise to filter chain
            noiseGain.connect(filter);

            // Connect filter chain: filter -> filter2 -> breathing gain -> master gain -> speakers
            filter.connect(filter2);
            filter2.connect(breathingGain);
            breathingGain.connect(droneGain);
            droneGain.connect(audioContext.destination);

            // Start all oscillators and noise
            oscillators.forEach(oscData => oscData.osc.start());
            noiseNode.start();
            lfoOsc1.start();
            lfoOsc2.start();

            soundEnabled = true;
        }

        /**
         * Toggles sound on/off
         */
        function toggleSound() {
            const button = document.getElementById('soundToggle');

            if (!soundEnabled) {
                initAudio();
                button.textContent = 'ðŸ”Š';
                button.classList.add('active');
            } else {
                // Stop sound with fade out
                if (audioContext) {
                    droneGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                    setTimeout(() => {
                        // Stop all oscillators
                        oscillators.forEach(oscData => {
                            try { oscData.osc.stop(); } catch(e) {}
                        });
                        if (noiseNode) {
                            try { noiseNode.stop(); } catch(e) {}
                        }
                        if (lfoOsc1) {
                            try { lfoOsc1.stop(); } catch(e) {}
                        }
                        if (lfoOsc2) {
                            try { lfoOsc2.stop(); } catch(e) {}
                        }
                        if (audioContext) audioContext.close();

                        // Reset arrays
                        oscillators = [];
                        soundEnabled = false;
                        button.textContent = 'ðŸ”‡';
                        button.classList.remove('active');
                    }, 500);
                }
            }
        }

        /**
         * The setup() function is called once when the program starts.
         * It initializes the canvas, sets up the color mode, and creates the initial animation elements.
         */
        function setup() {
            // Creates a full-screen canvas that fills the entire window
            createCanvas(windowWidth, windowHeight);
            // Sets the color mode to HSB (Hue, Saturation, Brightness) for easier and more intuitive color manipulation.
            // Hue ranges from 0-360, Saturation and Brightness from 0-100, and Alpha (transparency) from 0-1.
            colorMode(HSB, 360, 100, 100, 1);
            // pixelDensity(1) ensures consistent rendering across devices with different screen densities.
            pixelDensity(1);

            // Set a natural aquatic environment background color that mimics cellular fluid
            let bgPalette = naturalColorPalettes.aquatic[0]; // Use deep ocean blue as base
            backgroundColorHSB = color(bgPalette.hue, bgPalette.sat, bgPalette.bright);

            // Initializes the small background particles with natural colors that mimic microscopic elements
            for (let i = 0; i < particleCount; i++) {
                // Select colors from different natural palettes to create variety
                let paletteChoice = floor(random(4)); // Choose from 4 different palette categories
                let selectedPalette;

                switch(paletteChoice) {
                    case 0: selectedPalette = naturalColorPalettes.aquatic[floor(random(naturalColorPalettes.aquatic.length))]; break;
                    case 1: selectedPalette = naturalColorPalettes.organic[floor(random(naturalColorPalettes.organic.length))]; break;
                    case 2: selectedPalette = naturalColorPalettes.metabolic[floor(random(naturalColorPalettes.metabolic.length))]; break;
                    case 3: selectedPalette = naturalColorPalettes.structural[floor(random(naturalColorPalettes.structural.length))]; break;
                }

                particles.push({
                    x: random(width), // Random X position within the canvas.
                    y: random(height), // Random Y position within the canvas.
                    size: random(1, 2.5), // Random size for each particle, making some larger than others.
                    alpha: random(0.15, 0.55), // More translucent range for ethereal effect.
                    speedX: random(-0.3, 0.3), // Horizontal movement speed, allowing particles to drift left or right.
                    speedY: random(-0.3, 0.3), // Vertical movement speed, allowing particles to drift up or down.
                    hue: selectedPalette.hue, // Natural hue from biological palette.
                    saturation: selectedPalette.sat + random(-8, 12), // Increased saturation variation for contrast.
                    brightness: selectedPalette.bright + random(-10, 20), // Increased brightness range for more contrast.
                    noiseSeedA: random(1000), // Unique noise seed for alpha twinkling.
                    // Enhanced color variation for higher contrast
                    hueVariation: random(-8, 8), // More pronounced hue drift
                    saturationVariation: random(-8, 8) // More saturation variation
                });
            }

            // Initialize twinkling stars for Milky Way background effect
            for (let i = 0; i < starCount; i++) {
                stars.push({
                    x: random(width), // Random position across the canvas
                    y: random(height), // Random position across the canvas
                    size: random(0.5, 2.5), // Small star sizes
                    brightness: random(70, 100), // Bright stars
                    twinkleSpeed: random(0.005, 0.02), // Different twinkle speeds
                    twinkleOffset: random(TWO_PI), // Random twinkle phase
                    // Some stars have subtle color variations (blue/white)
                    hue: random() < 0.3 ? random(200, 220) : 0, // 30% blue stars, rest white
                    saturation: random() < 0.3 ? random(10, 30) : 0 // Blue stars have slight saturation
                });
            }

            // Initialize subtle nebula clouds for cosmic atmosphere
            for (let i = 0; i < nebulaCount; i++) {
                nebulaClouds.push({
                    x: random(width), // Random position
                    y: random(height), // Random position
                    radius: random(100, 300), // Large cloud radius
                    // Subtle cosmic colors
                    hue: random([270, 300, 330, 200, 240]), // Purples, magentas, blues
                    saturation: random(20, 40), // Low saturation for subtlety
                    brightness: random(10, 25), // Very dim for background effect
                    alpha: random(0.03, 0.08), // Very low opacity
                    driftSpeed: random(0.001, 0.003), // Very slow movement
                    pulseSpeed: random(0.002, 0.005) // Slow pulsing
                });
            }

            // Initializes the larger, pulsing internal circles with natural biological colors.
            for (let i = 0; i < internalCircleCount; i++) {
                // Select from natural palettes based on cellular function types
                let paletteChoice = floor(random(4));
                let selectedPalette;
                let cellFunction = ''; // Track the type for additional behavior

                switch(paletteChoice) {
                    case 0:
                        selectedPalette = naturalColorPalettes.aquatic[floor(random(naturalColorPalettes.aquatic.length))];
                        cellFunction = 'membrane'; // Cell membrane elements
                        break;
                    case 1:
                        selectedPalette = naturalColorPalettes.organic[floor(random(naturalColorPalettes.organic.length))];
                        cellFunction = 'organelle'; // Cellular organelles
                        break;
                    case 2:
                        selectedPalette = naturalColorPalettes.metabolic[floor(random(naturalColorPalettes.metabolic.length))];
                        cellFunction = 'metabolic'; // Metabolic processes
                        break;
                    case 3:
                        selectedPalette = naturalColorPalettes.structural[floor(random(naturalColorPalettes.structural.length))];
                        cellFunction = 'structural'; // Structural elements
                        break;
                }

                internalCircles.push({
                    // Initial positions are somewhat centered, but with random offsets to distribute them.
                    x: width / 2 + random(-200, 200), // Wider spread for larger cell
                    y: height / 2 + random(-150, 150), // Wider spread for larger cell
                    initialRadius: random(12, 35), // Larger base radius for each internal circle to match bigger cell.
                    radiusOffset: random(0.5, 2), // A factor that determines the magnitude of the circle's pulsing.
                    // Use natural biological colors with enhanced contrast properties
                    baseHue: selectedPalette.hue,
                    baseSat: selectedPalette.sat,
                    baseBright: selectedPalette.bright,
                    cellFunction: cellFunction, // Track cellular function for specialized behavior
                    color: color(selectedPalette.hue, selectedPalette.sat + random(-8, 12), selectedPalette.bright + random(-10, 20), 0.8),
                    noiseSeedX: random(1000), // Unique Perlin noise seed for independent X-axis movement.
                    noiseSeedY: random(2000), // Unique Perlin noise seed for independent Y-axis movement.
                    noiseSeedR: random(3000), // Unique Perlin noise seed for independent radius pulsing.
                    noiseSeedC: random(4000), // Unique noise seed for color shifting.
                    // Enhanced color variation properties for higher contrast
                    hueVariation: random(-10, 10), // More pronounced hue variation for internal elements
                    brightnessVariation: random(-15, 15) // Brightness variation for metabolic activity effect
                });
            }

            // Initializes the main Blob object with natural cellular colors, positioning it at the center.
            let blobPalette = naturalColorPalettes.aquatic[1]; // Use marine blue for the main cell membrane
            blob = new Blob(width / 2, height / 2, 200, blobPalette); // Increased size for bigger cell

            // Add event listener for sound toggle button
            document.getElementById('soundToggle').addEventListener('click', toggleSound);
        }

        /**
         * The windowResized() function is called automatically by p5.js when the browser window is resized.
         * It resizes the canvas to match the new window dimensions, making the animation truly full-screen.
         */
        function windowResized() {
            // Resize canvas to fill the new window dimensions
            resizeCanvas(windowWidth, windowHeight);
        }

        /**
         * The mousePressed() function is called once when the user clicks on the canvas.
         * It sets a new target position for the blob to move towards.
         */
        function mousePressed() {
            // Set the blob's target to the clicked position
            blob.setTarget(mouseX, mouseY);
        }

        /**
         * The draw() function is called continuously after setup().
         * It updates the state of all animation elements and renders them frame by frame, creating the animation.
         * By default, this function automatically runs in a continuous loop.
         */
        function draw() {
            background(backgroundColorHSB); // Sets the canvas background to the deep muted blue-purple color.

            // Update global breathing phase for synchronized organic pulsing
            breathingPhase += animationSpeed * 0.3;

            // Sync audio with visual breathing rhythm and add organic modulation
            if (soundEnabled && audioContext && breathingGain) {
                // Map breathing phase to gain (0.2 to 0.5 range for organic pulsing)
                let breathingAmount = map(sin(breathingPhase), -1, 1, 0.2, 0.5);
                breathingGain.gain.setValueAtTime(breathingAmount, audioContext.currentTime);

                // Organically modulate filter frequencies with multiple layers
                let filterFreq = map(sin(breathingPhase * 0.7), -1, 1, 400, 550);
                let filterFreq2 = map(sin(breathingPhase * 1.3 + 1.5), -1, 1, 700, 900);
                filter.frequency.setValueAtTime(filterFreq, audioContext.currentTime);
                filter2.frequency.setValueAtTime(filterFreq2, audioContext.currentTime);

                // Modulate filter resonance for organic evolution
                let filterQ = map(sin(breathingPhase * 0.5), -1, 1, 2, 4);
                filter.Q.setValueAtTime(filterQ, audioContext.currentTime);

                // Organically modulate oscillator frequencies for evolving texture
                oscillators.forEach((oscData, i) => {
                    // Create unique modulation pattern for each oscillator
                    let mod1 = sin(breathingPhase * (0.8 + i * 0.1) + i);
                    let mod2 = sin(breathingPhase * (1.2 + i * 0.15) + i * 2);

                    // Calculate frequency deviation based on oscillator type
                    let deviation = 0;
                    if (oscData.type === 'bass') {
                        deviation = mod1 * 1.5 + mod2 * 0.8; // Subtle bass wobble
                    } else if (oscData.type === 'mid') {
                        deviation = mod1 * 3 + mod2 * 2; // More mid movement
                    } else if (oscData.type === 'high') {
                        deviation = mod1 * 5 + mod2 * 3; // Most high shimmer
                    }

                    let newFreq = oscData.baseFreq + deviation;
                    oscData.osc.frequency.setValueAtTime(newFreq, audioContext.currentTime);
                });

                // Modulate noise level with breathing for organic texture variation
                let noiseLevel = map(sin(breathingPhase * 0.9), -1, 1, 0.02, 0.06);
                if (noiseGain) {
                    noiseGain.gain.setValueAtTime(noiseLevel, audioContext.currentTime);
                }
            }

            // Draw twinkling stars for Milky Way background effect
            noStroke();
            for (let i = 0; i < stars.length; i++) {
                let star = stars[i];
                // Create twinkling effect using sine wave
                let twinkle = sin(frameCount * star.twinkleSpeed + star.twinkleOffset) * 0.5 + 0.5; // 0 to 1 range
                let currentBrightness = star.brightness * (0.3 + twinkle * 0.7); // Vary between 30% and 100% of base brightness

                // Draw star with twinkling brightness
                fill(star.hue, star.saturation, currentBrightness, 0.8 + twinkle * 0.2);
                ellipse(star.x, star.y, star.size);

                // Add a subtle glow effect for brighter stars
                if (star.size > 1.5 && twinkle > 0.7) {
                    fill(star.hue, star.saturation * 0.5, currentBrightness * 1.2, 0.3);
                    ellipse(star.x, star.y, star.size * 2);
                }
            }

            // Draw subtle nebula clouds for cosmic atmosphere
            noStroke();
            for (let i = 0; i < nebulaClouds.length; i++) {
                let nebula = nebulaClouds[i];

                // Very slow drift movement
                nebula.x += sin(frameCount * nebula.driftSpeed + i) * 0.1;
                nebula.y += cos(frameCount * nebula.driftSpeed * 0.7 + i) * 0.08;

                // Wrap around screen edges
                if (nebula.x < -nebula.radius) nebula.x = width + nebula.radius;
                if (nebula.x > width + nebula.radius) nebula.x = -nebula.radius;
                if (nebula.y < -nebula.radius) nebula.y = height + nebula.radius;
                if (nebula.y > height + nebula.radius) nebula.y = -nebula.radius;

                // Gentle pulsing effect
                let pulse = sin(frameCount * nebula.pulseSpeed + i * 0.5) * 0.3 + 0.7;
                let currentAlpha = nebula.alpha * pulse;

                // Draw nebula cloud as a soft gradient
                fill(nebula.hue, nebula.saturation, nebula.brightness, currentAlpha);
                ellipse(nebula.x, nebula.y, nebula.radius);

                // Add a softer outer glow
                fill(nebula.hue, nebula.saturation * 0.5, nebula.brightness * 0.5, currentAlpha * 0.5);
                ellipse(nebula.x, nebula.y, nebula.radius * 1.5);
            }

            // Updates and displays the small background particles with natural color variations.
            for (let i = 0; i < particles.length; i++) {
                let p = particles[i];

                // Add organic flow field based on Perlin noise for fluid-like movement
                let noiseX = noise(p.x * 0.003, p.y * 0.003, frameCount * 0.001);
                let noiseY = noise(p.x * 0.003 + 500, p.y * 0.003 + 500, frameCount * 0.001);
                let flowAngle = map(noiseX, 0, 1, 0, TWO_PI);
                let flowStrength = map(noiseY, 0, 1, 0.1, 0.5);

                // Very subtle attraction to the blob center for gentle organic clustering
                let dx = blob.x - p.x;
                let dy = blob.y - p.y;
                let distance = sqrt(dx * dx + dy * dy);
                let attractionForce = 0.0001; // Reduced for more distributed particles

                // Combine original speed, flow field, and attraction
                p.x += p.speedX + cos(flowAngle) * flowStrength + (dx * attractionForce);
                p.y += p.speedY + sin(flowAngle) * flowStrength + (dy * attractionForce);

                // Wraps particles around the screen edges, creating a continuous flow effect.
                if (p.x < 0) p.x = width;
                if (p.x > width) p.x = 0;
                if (p.y < 0) p.y = height;
                if (p.y > height) p.y = 0;

                noStroke(); // Ensures particles have no outline.

                // Enhanced color variations for higher contrast and visibility
                let dynamicHue = p.hue + sin(frameCount * animationSpeed * 0.5 + i * 0.1) * p.hueVariation;
                let dynamicSat = constrain(p.saturation + cos(frameCount * animationSpeed * 0.3 + i * 0.15) * p.saturationVariation, 30, 95);
                let dynamicBright = constrain(p.brightness + sin(frameCount * animationSpeed * 0.7 + i * 0.2) * 15, 40, 100);

                // More translucent alpha twinkling for ethereal effect
                let twinkleAlpha = map(noise(p.noiseSeedA + frameCount * animationSpeed * 2), 0, 1, 0.18, 0.65);
                fill(dynamicHue, dynamicSat, dynamicBright, twinkleAlpha); // Fills particles with high-contrast colors.

                ellipse(p.x, p.y, p.size); // Draws each particle as a small ellipse.
            }

            // Updates the state and displays the main blob organism.
            blob.update();
            blob.display();

            // Updates and displays the internal pulsing circles with natural biological colors.
            for (let i = 0; i < internalCircles.length; i++) {
                let c = internalCircles[i];

                // Organic movement with Perlin noise
                let noiseX = (noise(c.noiseSeedX + frameCount * animationSpeed * 0.5) * 2 - 1) * 120;
                let noiseY = (noise(c.noiseSeedY + frameCount * animationSpeed * 0.5) * 2 - 1) * 90;

                // Add gentle attraction/repulsion forces between internal circles for organic clustering
                let forceX = 0;
                let forceY = 0;
                for (let j = 0; j < internalCircles.length; j++) {
                    if (i !== j) {
                        let other = internalCircles[j];
                        let dx = other.x - c.x;
                        let dy = other.y - c.y;
                        let dist = sqrt(dx * dx + dy * dy);

                        if (dist > 0 && dist < 100) {
                            // Gentle repulsion when too close
                            let repulsion = map(dist, 0, 100, -0.3, 0);
                            forceX += (dx / dist) * repulsion;
                            forceY += (dy / dist) * repulsion;
                        } else if (dist > 150 && dist < 250) {
                            // Subtle attraction to maintain clustering
                            let attraction = map(dist, 150, 250, 0, 0.1);
                            forceX += (dx / dist) * attraction;
                            forceY += (dy / dist) * attraction;
                        }
                    }
                }

                // Combine noise-based movement with organic forces
                c.x = blob.x + noiseX + forceX * 5;
                c.y = blob.y + noiseY + forceY * 5;

                // Animates the radius of each circle, creating a pulsing or breathing effect.
                // Perlin noise, sine wave, and gentle global breathing create smooth, organic size changes.
                let breathingInfluence = sin(breathingPhase) * 0.08 + 1; // Gentle breathing to preserve form
                let localPulse = sin(noise(c.noiseSeedR + frameCount * animationSpeed * 1.5));
                let currentRadius = c.initialRadius * breathingInfluence + localPulse * c.radiusOffset * 8;

                // Enhanced natural color variations based on cellular function
                let baseHue = c.baseHue;
                let baseSat = c.baseSat;
                let baseBright = c.baseBright;

                // Function-specific color behaviors
                let metabolicMultiplier = 1;
                let activityLevel = 1;

                if (c.cellFunction === 'metabolic') {
                    // Metabolic elements pulse more brightly when "active"
                    metabolicMultiplier = 1 + sin(frameCount * animationSpeed * 2 + i * 0.4) * 0.3;
                    activityLevel = map(noise(c.noiseSeedC + frameCount * animationSpeed * 0.8), 0, 1, 0.7, 1.3);
                } else if (c.cellFunction === 'membrane') {
                    // Membrane elements have subtle aquatic variations
                    baseHue += sin(frameCount * animationSpeed * 0.3 + i * 0.2) * 5;
                } else if (c.cellFunction === 'organelle') {
                    // Organelles have more stable, organic colors
                    activityLevel = map(noise(c.noiseSeedC + frameCount * animationSpeed * 0.4), 0, 1, 0.8, 1.2);
                }

                // Natural color variations with enhanced biological realism
                let dynamicHue = (baseHue + sin(frameCount * animationSpeed * 0.7 + i * 0.3) * c.hueVariation) % 360;
                let dynamicSat = constrain(baseSat + cos(frameCount * animationSpeed * 1.2 + i * 0.7) * 8, 30, 90);
                let dynamicBright = constrain(baseBright + sin(frameCount * animationSpeed * 0.9 + i * 0.4) * c.brightnessVariation * metabolicMultiplier, 50, 100) * activityLevel;

                noStroke(); // Ensures internal circles have no outline.

                // More translucent alpha variations for ethereal glow effects
                let baseAlpha = map(noise(c.noiseSeedC + frameCount * animationSpeed * 0.6), 0, 1, 0.4, 0.7);
                let currentAlpha = baseAlpha * activityLevel;

                // Create layered glow effect with translucent ethereal appearance
                // Outer glow layer - very translucent, larger
                fill(dynamicHue, dynamicSat * 0.8, dynamicBright * 1.3, currentAlpha * 0.25);
                ellipse(c.x, c.y, currentRadius * 3.0);

                // Middle glow layer - more translucent
                fill(dynamicHue, dynamicSat * 0.9, dynamicBright * 1.2, currentAlpha * 0.4);
                ellipse(c.x, c.y, currentRadius * 2.5);

                // Core layer - still translucent but more visible
                fill(dynamicHue, dynamicSat, dynamicBright * 1.1, currentAlpha * 0.6);
                ellipse(c.x, c.y, currentRadius * 2); // Draws the internal circle core with ethereal translucency.
            }
        }

        /**
         * Blob Class: Defines the properties and behavior of the main amorphous, pulsating organism.
         */
        class Blob {
            constructor(x, y, r, colorPalette) {
                this.x = x; // The X coordinate of the blob's center.
                this.y = y; // The Y coordinate of the blob's center.
                this.targetX = x; // Target X position for movement (initially same as starting position)
                this.targetY = y; // Target Y position for movement (initially same as starting position)
                this.baseRadius = r; // The average or base radius of the blob.
                this.noiseScale = 0.008; // Determines the 'granularity' or frequency of the Perlin noise, affecting the smoothness of the shape.
                this.timeOffset = random(1000); // A unique time offset for noise, ensuring independent animation from other blobs or elements.
                this.numPoints = 200; // The number of vertices used to draw the blob's outline. More points result in a smoother shape.
                this.amplitude = 45; // Increased amplitude for more dramatic shape variation with larger cell.
                this.hairLength = 25; // Increased maximum length of cilia to match bigger cell size.
                this.hairDensity = 2; // Controls how frequently hair-like projections are drawn along the outline (lower value = more dense hairs).

                // Enhanced color properties for the blob with higher contrast
                this.baseHue = colorPalette.hue; // Use the natural palette hue.
                this.baseSat = colorPalette.sat; // Use the natural palette saturation.
                this.baseBright = colorPalette.bright; // Use the natural palette brightness.
                this.hueSpeed = random(0.3, 0.7); // Slower, more natural hue oscillation.
                this.saturation = this.baseSat + random(-8, 10); // Increased saturation range for contrast.
                this.brightness = this.baseBright + random(-8, 15); // Increased brightness range for contrast.

                // Enhanced color variation properties for higher contrast
                this.hueVariation = random(-15, 15); // More pronounced hue drift for cellular appearance
                this.saturationVariation = random(-10, 10); // Saturation variation for membrane fluidity
                this.brightnessVariation = random(-20, 20); // Brightness variation for health/activity
            }

            /**
             * Updates the state of the blob for animation purposes.
             * This includes advancing its internal noise-based animation and overall position.
             */
            update() {
                this.timeOffset += animationSpeed * 0.5; // Increments the time offset, causing the blob's shape to continuously morph.

                // Smooth organic movement towards target position with easing
                let easing = 0.01; // Slower easing factor for leisurely organic movement

                // Calculate distance to target
                let dx = this.targetX - this.x;
                let dy = this.targetY - this.y;
                let distance = sqrt(dx * dx + dy * dy);

                // Add subtle organic drift and wobble during movement
                let drift1X = sin(this.timeOffset * 0.8) * 8; // Reduced drift while moving
                let drift1Y = cos(this.timeOffset * 0.6) * 6;

                let drift2X = sin(this.timeOffset * 0.5 + 3) * 5;
                let drift2Y = cos(this.timeOffset * 0.4 + 2) * 5;

                let noiseX = map(noise(this.timeOffset * 0.3, 0), 0, 1, -3, 3);
                let noiseY = map(noise(this.timeOffset * 0.3, 100), 0, 1, -3, 3);

                // Move towards target with organic easing and subtle drift
                this.x += dx * easing + drift1X * 0.3 + drift2X * 0.3 + noiseX * 0.5;
                this.y += dy * easing + drift1Y * 0.3 + drift2Y * 0.3 + noiseY * 0.5;

                // Enhanced natural color variations for cellular membrane effect
                let membraneFluidity = map(noise(this.timeOffset * 0.1), 0, 1, 0.8, 1.2); // Simulates membrane fluidity
                let metabolicActivity = map(noise(this.timeOffset * 0.05), 0, 1, 0.9, 1.1); // Simulates metabolic activity

                // Natural hue variations with membrane fluidity effect
                this.currentHue = (this.baseHue + sin(frameCount * animationSpeed * this.hueSpeed) * this.hueVariation * membraneFluidity) % 360;
                if (this.currentHue < 0) this.currentHue += 360; // Ensure hue stays positive.

                // Dynamic saturation and brightness with higher contrast ranges
                this.currentSat = constrain(this.saturation + cos(frameCount * animationSpeed * 0.8) * this.saturationVariation, 45, 90);
                this.currentBright = constrain(this.brightness + sin(frameCount * animationSpeed * 0.6) * this.brightnessVariation * metabolicActivity, 55, 100);
            }

            /**
             * Sets a new target position for the blob to move towards
             */
            setTarget(x, y) {
                this.targetX = x;
                this.targetY = y;
            }

            /**
             * Draws the blob and its hair-like projections on the canvas.
             */
            display() {
                push(); // Saves the current drawing style settings and transformations.
                translate(this.x, this.y); // Moves the drawing origin to the blob's current center, simplifying coordinate calculations.

                // Calculates the blob's current pulsing radius with gentle breathing rhythm.
                let breathingScale = sin(breathingPhase) * 0.05 + 1; // Gentle breathing to preserve shape
                let localNoise = map(noise(this.timeOffset * 0.5), 0, 1, -10, 10);
                let currentRadius = this.baseRadius * breathingScale + localNoise;
                let outlineVertices = []; // An array to temporarily store the calculated vertices of the blob's outline.

                // Create layered cellular membrane effect with translucency
                // Outer membrane layer - translucent with ethereal appearance
                beginShape();
                fill(this.currentHue, this.currentSat * 0.85, this.currentBright * 1.2, 0.08);
                stroke((this.currentHue + 15) % 360, this.currentSat * 0.8, this.currentBright * 1.3, 0.18);
                strokeWeight(1.0);

                // Generates the blob's organic, continuously morphing shape using multi-layered Perlin noise.
                for (let i = 0; i < this.numPoints; i++) {
                    let angle = map(i, 0, this.numPoints, 0, TWO_PI); // Calculates an angle around the circle for each vertex.

                    // Layer 1: Large-scale deformation (slow, broad movements) - reduced for cellular shape
                    let xoff1 = cos(angle) * currentRadius * this.noiseScale * 0.5 + this.timeOffset;
                    let yoff1 = sin(angle) * currentRadius * this.noiseScale * 0.5 + this.timeOffset;
                    let deform1 = map(noise(xoff1, yoff1), 0, 1, -this.amplitude * 0.5, this.amplitude * 0.5);

                    // Layer 2: Medium-scale detail (organic ripples) - subtle
                    let xoff2 = cos(angle) * currentRadius * this.noiseScale * 2 + this.timeOffset * 1.5;
                    let yoff2 = sin(angle) * currentRadius * this.noiseScale * 2 + this.timeOffset * 1.5;
                    let deform2 = map(noise(xoff2, yoff2), 0, 1, -this.amplitude * 0.2, this.amplitude * 0.2);

                    // Layer 3: Fine detail (cellular membrane texture) - very subtle
                    let xoff3 = cos(angle) * currentRadius * this.noiseScale * 5 + this.timeOffset * 3;
                    let yoff3 = sin(angle) * currentRadius * this.noiseScale * 5 + this.timeOffset * 3;
                    let deform3 = map(noise(xoff3, yoff3), 0, 1, -this.amplitude * 0.1, this.amplitude * 0.1);

                    // Combine all layers with gentle breathing rhythm (reduced for shape preservation)
                    let breathingMod = sin(breathingPhase) * 0.08 + 1;
                    let totalDeformation = (deform1 + deform2 + deform3) * breathingMod;
                    let distance = (currentRadius + totalDeformation) * 1.05; // Slightly larger for outer layer

                    let x = cos(angle) * distance;
                    let y = sin(angle) * distance;
                    vertex(x, y); // Adds the calculated point as a vertex to the shape.
                }
                endShape(CLOSE); // Closes the outer membrane layer.

                // Inner membrane layer - more translucent with ethereal quality
                beginShape();
                fill(this.currentHue, this.currentSat, this.currentBright * 1.1, 0.12);
                stroke((this.currentHue + 25) % 360, this.currentSat * 0.95, this.currentBright * 1.05, 0.25);
                strokeWeight(1.5);

                // Regenerate vertices for inner layer using same multi-layered noise (slightly smaller)
                for (let i = 0; i < this.numPoints; i++) {
                    let angle = map(i, 0, this.numPoints, 0, TWO_PI);

                    // Multi-layered deformation for inner membrane (reduced to maintain cellular shape)
                    let xoff1 = cos(angle) * currentRadius * this.noiseScale * 0.5 + this.timeOffset;
                    let yoff1 = sin(angle) * currentRadius * this.noiseScale * 0.5 + this.timeOffset;
                    let deform1 = map(noise(xoff1, yoff1), 0, 1, -this.amplitude * 0.5, this.amplitude * 0.5);

                    let xoff2 = cos(angle) * currentRadius * this.noiseScale * 2 + this.timeOffset * 1.5;
                    let yoff2 = sin(angle) * currentRadius * this.noiseScale * 2 + this.timeOffset * 1.5;
                    let deform2 = map(noise(xoff2, yoff2), 0, 1, -this.amplitude * 0.2, this.amplitude * 0.2);

                    let xoff3 = cos(angle) * currentRadius * this.noiseScale * 5 + this.timeOffset * 3;
                    let yoff3 = sin(angle) * currentRadius * this.noiseScale * 5 + this.timeOffset * 3;
                    let deform3 = map(noise(xoff3, yoff3), 0, 1, -this.amplitude * 0.1, this.amplitude * 0.1);

                    let breathingMod = sin(breathingPhase) * 0.08 + 1;
                    let totalDeformation = (deform1 + deform2 + deform3) * breathingMod;
                    let distance = currentRadius + totalDeformation;

                    let x = cos(angle) * distance;
                    let y = sin(angle) * distance;
                    vertex(x, y);
                    outlineVertices.push({ x: x, y: y, angle: angle }); // Store for cilia
                }
                endShape(CLOSE); // Closes the inner membrane layer.

                // Draws the hair-like projections (cilia/pseudopods) along the blob's perimeter with natural colors.
                // Enhanced with wave-like motion that propagates around the cell membrane.
                for (let i = 0; i < outlineVertices.length; i += this.hairDensity) {
                    let v = outlineVertices[i]; // Gets a specific vertex from the blob's outline.
                    let angle = v.angle; // The angle of this vertex relative to the blob's center.

                    // Create wave-like propagation around the membrane
                    let wavePhase = angle * 3 + this.timeOffset * 8; // Traveling wave around circumference
                    let wavePulse = sin(wavePhase) * 0.5 + 0.5; // 0 to 1 range

                    // Secondary wave for more complex motion
                    let wave2Phase = angle * 5 - this.timeOffset * 6;
                    let wave2Pulse = sin(wave2Phase) * 0.3 + 0.7;

                    // Combine waves with Perlin noise for organic variability
                    let noiseInfluence = noise(v.x * 0.01 + this.timeOffset * 5, v.y * 0.01);
                    let hair_len = this.hairLength * wavePulse * wave2Pulse * map(noiseInfluence, 0, 1, 0.4, 1.3);

                    // Wave-based angle offset creates coordinated swimming motion
                    let baseAngleOffset = sin(angle * 2 + this.timeOffset * 7) * 0.4;
                    let noiseAngleOffset = map(noise(v.x * 0.05 + this.timeOffset * 10, v.y * 0.05), 0, 1, -0.2, 0.2);
                    let hair_angle_offset = baseAngleOffset + noiseAngleOffset;

                    // Enhanced cilia colors with higher contrast for better visibility
                    let ciliaHue = (this.currentHue + random(-12, 12)) % 360; // Controlled hue variation
                    let ciliaSat = constrain(this.currentSat + random(-8, 18), 60, 95); // More saturated for visibility
                    let ciliaBright = constrain(this.currentBright + random(-3, 15), 75, 100); // Brighter for maximum contrast

                    stroke(ciliaHue, ciliaSat, ciliaBright, 0.45); // More translucent cilia for ethereal effect.
                    strokeWeight(1.2); // Thicker stroke for better visibility.
                    // Draws a line extending outwards from the outline vertex, with modulated length and angle.
                    line(v.x, v.y, v.x + cos(angle + hair_angle_offset) * hair_len, v.y + sin(angle + hair_angle_offset) * hair_len);
                }
                pop(); // Restores the previous drawing style settings and transformations, ensuring they don't affect other elements.
            }
        }
    </script>
</body>
</html>