<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Binary Flow</title>
    <style>
        :root {
            --bg-color: #f5f5f0;
            --text-color: #2a2a2a;
            --control-bg: rgba(245, 245, 240, 0.9);
            --control-border: #2a2a2a;
            --button-bg: #e8e8e0;
            --button-disabled-bg: #d0d0c8;
            --text-shadow-color: rgba(42, 42, 42, 0.3);
        }
        
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none; /* Prevent default browser gestures */
        }
        
        body {
            background: var(--bg-color);
            font-family: monospace;
            color: var(--text-color);
            position: relative;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            background: var(--control-bg);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--control-border);
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        .controls.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        
        .file-label {
            cursor: pointer;
            padding: 10px 20px;
            background: var(--button-bg);
            border: 1px solid var(--control-border);
            border-radius: 4px;
            color: var(--text-color);
        }
        
        input[type="file"] {
            display: none;
        }
        
        button {
            padding: 10px 20px;
            background: var(--button-bg);
            border: 1px solid var(--control-border);
            border-radius: 4px;
            color: var(--text-color);
            cursor: pointer;
            font-family: monospace;
        }
        
        button:disabled {
            background: var(--button-disabled-bg);
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        select {
            padding: 8px 15px;
            background: var(--button-bg);
            border: 1px solid var(--control-border);
            border-radius: 4px;
            color: var(--text-color);
            font-family: monospace;
            cursor: pointer;
            font-size: 14px;
        }
        
        select:focus {
            outline: none;
            border-color: var(--control-border);
        }
        
        #canvas {
            line-height: 1;
            letter-spacing: 0;
            color: var(--text-color);
            text-shadow: 0 0 2px var(--text-shadow-color);
            white-space: pre;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
            border: 0;
            overflow: hidden;
            font-family: monospace;
            box-sizing: border-box;
        }
        
        .gesture-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--control-bg);
            padding: 20px 40px;
            border-radius: 8px;
            border: 2px solid var(--control-border);
            color: var(--text-color);
            font-size: 24px;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }
        
        .gesture-feedback.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="controls">
        <label class="file-label">
            Choisir un fichier MP3
            <input type="file" id="fileInput" accept="audio/*">
        </label>
        <div id="filename"></div>
        <div>
            <button id="playBtn" disabled>Play</button>
            <button id="stopBtn" disabled>Stop</button>
        </div>
        <button id="fullscreenBtn">Fullscreen</button>
        <button id="screenshotBtn">Screenshot</button>
        <div>
            <label for="animationSelect" style="color: var(--text-color); font-size: 12px; margin-bottom: 5px; display: block;">Animation Style:</label>
            <select id="animationSelect">
                <option value="hybrid">Hybrid Layered</option>
                <option value="matrix">Matrix Streams</option>
                <option value="ripple">Ripple Waves</option>
                <option value="spiral">Spiral Vortex</option>
                <option value="spectrum">Spectrum Bars</option>
                <option value="starfield">Starfield</option>
                <option value="waveform">Waveform</option>
                <option value="kaleidoscope">Kaleidoscope</option>
                <option value="particles">Particle Explosion</option>
            </select>
        </div>
        <div>
            <label for="themeSelect" style="color: var(--text-color); font-size: 12px; margin-bottom: 5px; display: block;">Theme:</label>
            <select id="themeSelect">
                <option value="default">Default</option>
                <option value="dark">Dark</option>
                <option value="neon">Neon</option>
                <option value="warm">Warm</option>
            </select>
        </div>
    </div>
    <div id="canvas"></div>
    <canvas id="webglCanvas" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 1;"></canvas>
    <div id="gestureFeedback" class="gesture-feedback"></div>
    
    <script src="webgl-renderer.js"></script>

    <script>
        var fileInput = document.getElementById('fileInput');
        var filename = document.getElementById('filename');
        var playBtn = document.getElementById('playBtn');
        var stopBtn = document.getElementById('stopBtn');
        var fullscreenBtn = document.getElementById('fullscreenBtn');
        var screenshotBtn = document.getElementById('screenshotBtn');
        var animationSelect = document.getElementById('animationSelect');
        var themeSelect = document.getElementById('themeSelect');
        var canvas = document.getElementById('canvas');
        var webglCanvas = document.getElementById('webglCanvas');
        var controls = document.querySelector('.controls');
        var gestureFeedback = document.getElementById('gestureFeedback');
        
        var currentAnimationStyle = 'hybrid'; // Default animation style
        var currentTheme = 'default'; // Default theme
        
        // WebGL renderer for particle systems
        var webglRenderer = null;
        var useWebGL = false;
        
        // Initialize WebGL renderer
        if (webglCanvas && typeof WebGLRenderer !== 'undefined') {
            try {
                webglRenderer = new WebGLRenderer(webglCanvas);
                useWebGL = webglRenderer.isAvailable();
                if (!useWebGL) {
                    webglCanvas.style.display = 'none';
                } else {
                    // Set initial canvas size
                    webglCanvas.width = WIDTH;
                    webglCanvas.height = HEIGHT;
                }
            } catch (e) {
                console.warn('WebGL renderer initialization failed:', e);
                useWebGL = false;
                if (webglCanvas) {
                    webglCanvas.style.display = 'none';
                }
            }
        } else {
            useWebGL = false;
            if (webglCanvas) {
                webglCanvas.style.display = 'none';
            }
        }
        
        // Animation blending state
        var blending = {
            active: false,
            from: null,
            to: null,
            progress: 0,
            duration: 1000 // 1 second transition
        };
        
        // Character intensity mapping for blending
        var charIntensityMap = {
            ' ': 0, '.': 0.1, ':': 0.2, '·': 0.25, "'": 0.3, '`': 0.35,
            '-': 0.4, '_': 0.45, '=': 0.5, '~': 0.55, '≈': 0.6, '≋': 0.65,
            '/': 0.7, '\\': 0.72, '|': 0.74, '+': 0.76, '*': 0.78, 'o': 0.8,
            'O': 0.82, '○': 0.84, '●': 0.86, '@': 0.88, '#': 0.9, '█': 0.92,
            '▓': 0.94, '▒': 0.96, '░': 0.98, '^': 0.85, 'v': 0.85, '<': 0.7,
            '>': 0.7, '▄': 0.93, '▀': 0.93, '▌': 0.95, '▐': 0.95
        };
        
        // Reverse mapping: intensity to character
        var intensityCharMap = Object.keys(charIntensityMap).sort(function(a, b) {
            return charIntensityMap[a] - charIntensityMap[b];
        });
        
        // Theme definitions
        var themes = {
            'default': {
                bg: '#f5f5f0',
                text: '#2a2a2a',
                controlBg: 'rgba(245, 245, 240, 0.9)',
                border: '#2a2a2a',
                buttonBg: '#e8e8e0',
                buttonDisabledBg: '#d0d0c8',
                textShadow: 'rgba(42, 42, 42, 0.3)'
            },
            'dark': {
                bg: '#1a1a1a',
                text: '#e0e0e0',
                controlBg: 'rgba(26, 26, 26, 0.9)',
                border: '#e0e0e0',
                buttonBg: '#2a2a2a',
                buttonDisabledBg: '#1a1a1a',
                textShadow: 'rgba(224, 224, 224, 0.5)'
            },
            'neon': {
                bg: '#000000',
                text: '#00ffff',
                controlBg: 'rgba(0, 0, 0, 0.9)',
                border: '#00ffff',
                buttonBg: '#001122',
                buttonDisabledBg: '#000011',
                textShadow: 'rgba(0, 255, 255, 0.8)'
            },
            'warm': {
                bg: '#2a1810',
                text: '#ffaa55',
                controlBg: 'rgba(42, 24, 16, 0.9)',
                border: '#ffaa55',
                buttonBg: '#3a2818',
                buttonDisabledBg: '#2a1810',
                textShadow: 'rgba(255, 170, 85, 0.6)'
            }
        };
        
        // Apply theme function
        function applyTheme(themeName) {
            var theme = themes[themeName] || themes['default'];
            currentTheme = themeName;
            
            document.documentElement.style.setProperty('--bg-color', theme.bg);
            document.documentElement.style.setProperty('--text-color', theme.text);
            document.documentElement.style.setProperty('--control-bg', theme.controlBg);
            document.documentElement.style.setProperty('--control-border', theme.border);
            document.documentElement.style.setProperty('--button-bg', theme.buttonBg);
            document.documentElement.style.setProperty('--button-disabled-bg', theme.buttonDisabledBg);
            document.documentElement.style.setProperty('--text-shadow-color', theme.textShadow);
            
            // Store theme preference
            try {
                localStorage.setItem('audioVisualizerTheme', themeName);
            } catch (e) {
                // localStorage not available
            }
        }
        
        // Load saved theme
        try {
            var savedTheme = localStorage.getItem('audioVisualizerTheme');
            if (savedTheme && themes[savedTheme]) {
                currentTheme = savedTheme;
                themeSelect.value = savedTheme;
                applyTheme(savedTheme);
            }
        } catch (e) {
            // localStorage not available
        }
        
        // Theme selector handler
        themeSelect.addEventListener('change', function(e) {
            applyTheme(e.target.value);
        });

        var audioFile = null;
        var audioContext = null;
        var analyser = null;
        var source = null;
        var frequencyData = null;
        var isPlaying = false;
        var audioBuffer = null; // Store buffer for looping
        var shouldLoop = true; // Loop flag

        // Configuration constants
        var CONFIG = {
            // Grid settings
            MIN_WIDTH: 20,
            MIN_HEIGHT: 15,
            CHAR_ASPECT_RATIO: 0.6,
            ESTIMATED_CHAR_HEIGHT: 10,
            
            // Audio analysis
            FFT_SIZE: 256,
            BASS_RANGE: 0.15,
            MID_RANGE: 0.5,
            FREQ_NORMALIZE: 255,
            
            // Animation timing
            TIME_INCREMENT: 0.1,
            
            // Controls
            CONTROLS_HIDE_DELAY: 3000,
            CONTROLS_AUTO_HIDE_DELAY: 3000,
            
            // Fullscreen
            FULLSCREEN_DELAY: 500,
            
            // Audio looping
            LOOP_DELAY: 50
        };
        
        var WIDTH = 0;
        var HEIGHT = 0;
        var grid = [];
        var time = 0; // Animation time counter
        var particles = []; // For floating particle effects
        
        // Cached values for performance
        var cachedValues = {
            centerX: 0,
            centerY: 0,
            maxDist: 0,
            canvas: null
        };
        
        // Web Worker for offloading calculations
        var worker = null;
        var useWorker = false;
        var workerReady = false;
        
        // Initialize Web Worker if available
        if (typeof Worker !== 'undefined') {
            try {
                worker = new Worker('worker.js');
                worker.onmessage = function(e) {
                    if (e.data.type === 'grid') {
                        // Verify grid structure before using
                        if (e.data.grid && Array.isArray(e.data.grid) && e.data.grid.length === HEIGHT) {
                            grid = e.data.grid;
                            render();
                        } else {
                            // Grid structure invalid, disable worker and recalculate
                            useWorker = false;
                            update();
                            render();
                        }
                    } else if (e.data.type === 'fallback') {
                        useWorker = false; // Fallback to main thread
                        update();
                        render();
                    }
                };
                worker.onerror = function(e) {
                    console.warn('Web Worker error, falling back to main thread:', e);
                    useWorker = false;
                };
                useWorker = true;
            } catch (e) {
                console.warn('Web Worker not available, using main thread:', e);
                useWorker = false;
            }
        }
        
        /**
         * Calculates optimal grid dimensions based on viewport size.
         * Dynamically adjusts font size to perfectly fill the screen with characters.
         * Takes into account monospace font aspect ratio (0.6x wider than tall).
         * 
         * @function calculateGridSize
         * @description Calculates WIDTH and HEIGHT grid dimensions and sets optimal font size
         * @modifies {number} WIDTH - Grid width in characters
         * @modifies {number} HEIGHT - Grid height in characters
         * @modifies {HTMLElement} canvas.style.fontSize - Font size in pixels
         */
        function calculateGridSize() {
            // Get viewport dimensions
            var vw = window.innerWidth;
            var vh = window.innerHeight;
            
            // Character aspect ratio for monospace fonts
            var charAspectRatio = CONFIG.CHAR_ASPECT_RATIO;
            
            // Calculate grid to fill 100% of the window
            var estimatedCharHeight = CONFIG.ESTIMATED_CHAR_HEIGHT;
            var estimatedCharWidth = estimatedCharHeight * charAspectRatio;
            
            // Calculate maximum grid dimensions that fit in viewport
            WIDTH = Math.floor(vw / estimatedCharWidth);
            HEIGHT = Math.floor(vh / estimatedCharHeight);
            
            // Ensure minimum size
            if (WIDTH < CONFIG.MIN_WIDTH) WIDTH = CONFIG.MIN_WIDTH;
            if (HEIGHT < CONFIG.MIN_HEIGHT) HEIGHT = CONFIG.MIN_HEIGHT;
            
            // Calculate exact font size to fill the window perfectly
            var optimalFontSizeH = vh / HEIGHT;
            var optimalFontSizeW = (vw / WIDTH) / charAspectRatio;
            var optimalFontSize = Math.min(optimalFontSizeH, optimalFontSizeW);
            
            // Update font size
            if (!cachedValues.canvas) {
                cachedValues.canvas = document.getElementById('canvas');
            }
            cachedValues.canvas.style.fontSize = optimalFontSize + 'px';
            
            // Recalculate grid with exact font size to ensure perfect fit
            var actualCharHeight = optimalFontSize;
            var actualCharWidth = optimalFontSize * charAspectRatio;
            WIDTH = Math.floor(vw / actualCharWidth);
            HEIGHT = Math.floor(vh / actualCharHeight);
            
            // Update cached values
            cachedValues.centerX = WIDTH / 2;
            cachedValues.centerY = HEIGHT / 2;
            cachedValues.maxDist = Math.sqrt(cachedValues.centerX * cachedValues.centerX + 
                                            cachedValues.centerY * cachedValues.centerY);
            
            // Update WebGL canvas size
            if (webglCanvas) {
                webglCanvas.width = WIDTH;
                webglCanvas.height = HEIGHT;
            }
        }
        
        // Initialize grid size on load and resize
        calculateGridSize();
        
        // Initialize worker with grid dimensions
        if (worker && useWorker) {
            worker.postMessage({
                type: 'init',
                WIDTH: WIDTH,
                HEIGHT: HEIGHT,
                time: time
            });
        }
        
        // Throttle resize events for better performance
        var resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                calculateGridSize();
                initGrid();
                // Update worker with new dimensions
                if (worker && useWorker) {
                    worker.postMessage({
                        type: 'init',
                        WIDTH: WIDTH,
                        HEIGHT: HEIGHT,
                        time: time
                    });
                }
            }, 100); // Throttle to 100ms
        });

        /**
         * Initializes the grid array with empty spaces.
         * Creates a 2D array (HEIGHT x WIDTH) filled with space characters.
         * 
         * @function initGrid
         * @description Creates and initializes the visualization grid
         * @modifies {Array<Array<string>>} grid - 2D array representing the character grid
         */
        function initGrid() {
            grid = [];
            for (var y = 0; y < HEIGHT; y++) {
                var row = [];
                for (var x = 0; x < WIDTH; x++) {
                    row.push(' ');
                }
                grid.push(row);
            }
        }

        /**
         * Renders the grid array as text and displays it on the canvas.
         * Converts the 2D grid array into a single string with newlines.
         * Optimized using array.join() for better performance.
         * Also handles WebGL rendering for particle systems.
         * 
         * @function render
         * @description Converts grid array to text and displays on canvas
         * @modifies {HTMLElement} canvas.textContent - The displayed text content
         */
        function render() {
            // Safety check: ensure grid is initialized and dimensions match
            if (!grid || grid.length !== HEIGHT) {
                initGrid();
            }
            
            // Render WebGL particles if using particle animations
            if (useWebGL && webglRenderer && (currentAnimationStyle === 'starfield' || currentAnimationStyle === 'particles')) {
                webglRenderer.render(time);
                // Still render ASCII background
                var lines = [];
                for (var y = 0; y < HEIGHT; y++) {
                    if (grid[y] && Array.isArray(grid[y])) {
                        lines.push(grid[y].join(''));
                    } else {
                        // Fallback: create empty row if missing
                        lines.push(' '.repeat(WIDTH));
                    }
                }
                canvas.textContent = lines.join('\n');
            } else {
                // Hide WebGL canvas for non-particle animations
                if (webglCanvas) {
                    webglCanvas.style.display = 'none';
                }
                // Render ASCII grid
                var lines = [];
                for (var y = 0; y < HEIGHT; y++) {
                    if (grid[y] && Array.isArray(grid[y])) {
                        lines.push(grid[y].join(''));
                    } else {
                        // Fallback: create empty row if missing
                        lines.push(' '.repeat(WIDTH));
                    }
                }
                canvas.textContent = lines.join('\n');
            }
            
            // Ensure canvas is positioned at top-left
            canvas.style.textAlign = 'left';
            canvas.style.textIndent = '0';
        }

        /**
         * Analyzes audio frequency data and extracts normalized values.
         * Separates audio into bass, mid, and treble frequency bands.
         * 
         * @function getAudioData
         * @description Extracts and normalizes audio frequency data from analyser
         * @returns {Object} Audio data object containing:
         *   @returns {number} bass - Normalized bass frequency (0-1)
         *   @returns {number} mid - Normalized mid frequency (0-1)
         *   @returns {number} treble - Normalized treble frequency (0-1)
         *   @returns {number} overall - Normalized overall volume (0-1)
         *   @returns {number} peakFreq - Normalized peak frequency value (0-1)
         *   @returns {number} peakIndex - Index of peak frequency bin
         *   @returns {Array<number>} freqBands - Array of normalized frequency band values (0-1)
         */
        function getAudioData() {
            var bass = 0;
            var mid = 0;
            var treble = 0;
            var overall = 0;
            var peakFreq = 0;
            var peakIndex = 0;
            var freqBands = [];
            
            if (analyser && frequencyData && isPlaying) {
                analyser.getByteFrequencyData(frequencyData);
                
                var bassEnd = Math.floor(frequencyData.length * CONFIG.BASS_RANGE);
                var midEnd = Math.floor(frequencyData.length * CONFIG.MID_RANGE);
                var freqNormalize = CONFIG.FREQ_NORMALIZE;
                
                for (var i = 0; i < frequencyData.length; i++) {
                    var freqValue = frequencyData[i];
                    if (i < bassEnd) {
                        bass += freqValue;
                    } else if (i < midEnd) {
                        mid += freqValue;
                    } else {
                        treble += freqValue;
                    }
                    overall += freqValue;
                    freqBands.push(freqValue / freqNormalize);
                    
                    // Find peak frequency
                    if (freqValue > peakFreq) {
                        peakFreq = freqValue;
                        peakIndex = i;
                    }
                }
                
                bass = bass / bassEnd / freqNormalize;
                mid = mid / (midEnd - bassEnd) / freqNormalize;
                treble = treble / (frequencyData.length - midEnd) / freqNormalize;
                overall = overall / frequencyData.length / freqNormalize;
            }
            
            return {
                bass: bass,
                mid: mid,
                treble: treble,
                overall: overall,
                peakFreq: peakFreq / 255,
                peakIndex: peakIndex,
                freqBands: freqBands
            };
        }

        /**
         * Main update function called every animation frame.
         * Clears the grid, increments time, gets audio data, and calls the selected animation style.
         * 
         * @function update
         * @description Updates the visualization grid based on current audio and animation style
         * @modifies {number} time - Animation time counter (incremented by 0.1)
         * @modifies {Array<Array<string>>} grid - Grid array populated by animation functions
         */
        // Animation registry for better maintainability
        var animationRegistry = {
            'hybrid': animateHybrid,
            'matrix': animateMatrix,
            'ripple': animateRipple,
            'spiral': animateSpiral,
            'spectrum': animateSpectrum,
            'starfield': animateStarfield,
            'waveform': animateWaveform,
            'kaleidoscope': animateKaleidoscope,
            'particles': animateParticles
        };
        
        /**
         * Helper function to calculate distance squared (avoids Math.sqrt when possible)
         * @param {number} dx - X difference
         * @param {number} dy - Y difference
         * @returns {number} Distance squared
         */
        function distSquared(dx, dy) {
            return dx * dx + dy * dy;
        }
        
        /**
         * Helper function to calculate distance
         * @param {number} dx - X difference
         * @param {number} dy - Y difference
         * @returns {number} Distance
         */
        function distance(dx, dy) {
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        /**
         * Interpolates between two characters based on blending progress
         * @param {string} charFrom - Source character
         * @param {string} charTo - Target character
         * @param {number} progress - Blending progress (0-1)
         * @returns {string} Blended character
         */
        function interpolateChar(charFrom, charTo, progress) {
            var intensityFrom = charIntensityMap[charFrom] || 0;
            var intensityTo = charIntensityMap[charTo] || 0;
            var blendedIntensity = intensityFrom * (1 - progress) + intensityTo * progress;
            
            // Find closest character to blended intensity
            var closestChar = ' ';
            var minDiff = Infinity;
            for (var i = 0; i < intensityCharMap.length; i++) {
                var char = intensityCharMap[i];
                var diff = Math.abs(charIntensityMap[char] - blendedIntensity);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestChar = char;
                }
            }
            
            // Prefer target character if progress > 0.5
            if (progress > 0.5) {
                return charTo !== ' ' ? charTo : closestChar;
            }
            return charFrom !== ' ' ? charFrom : closestChar;
        }
        
        function update() {
            time += CONFIG.TIME_INCREMENT;
            
            var audio = getAudioData();
            
            // Use Web Worker if available and not blending
            if (useWorker && worker && !blending.active && currentAnimationStyle === 'hybrid') {
                // Only send serializable values to worker (exclude DOM elements)
                worker.postMessage({
                    type: 'update',
                    WIDTH: WIDTH,
                    HEIGHT: HEIGHT,
                    time: time,
                    audio: audio,
                    style: currentAnimationStyle,
                    cachedValues: {
                        centerX: cachedValues.centerX,
                        centerY: cachedValues.centerY,
                        maxDist: cachedValues.maxDist
                        // Exclude canvas element - it can't be cloned
                    }
                });
                return; // Worker will call render() via onmessage
            }
            
            // Handle animation blending
            if (blending.active) {
                blending.progress += (1000 / 60) / blending.duration; // Assume 60 FPS
                
                if (blending.progress >= 1.0) {
                    blending.active = false;
                    blending.progress = 1.0;
                }
                
                // Calculate both animations
                initGrid();
                var fromFn = animationRegistry[blending.from] || animationRegistry['hybrid'];
                fromFn(audio);
                var blendFrom = JSON.parse(JSON.stringify(grid)); // Deep copy
                
                initGrid();
                var toFn = animationRegistry[currentAnimationStyle] || animationRegistry['hybrid'];
                toFn(audio);
                var blendTo = grid;
                
                // Blend grids
                for (var y = 0; y < HEIGHT; y++) {
                    for (var x = 0; x < WIDTH; x++) {
                        grid[y][x] = interpolateChar(blendFrom[y][x], blendTo[y][x], blending.progress);
                    }
                }
            } else {
                initGrid();
                var animationFn = animationRegistry[currentAnimationStyle] || animationRegistry['hybrid'];
                animationFn(audio);
            }
        }
        
        /**
         * Animation Style 1: Hybrid Layered (original).
         * Complex radial patterns with concentric rings, swirling segments, and spiral effects.
         * Combines multiple visualization techniques for a rich, layered experience.
         * 
         * @function animateHybrid
         * @param {Object} audio - Audio data object from getAudioData()
         * @description Creates hybrid layered visualization with radial and spiral patterns
         * @modifies {Array<Array<string>>} grid - Populates grid with hybrid pattern characters
         */
        function animateHybrid(audio) {
            var bass = audio.bass;
            var mid = audio.mid;
            var treble = audio.treble;
            var overall = audio.overall;

            var chars = ['#', '+', '*', '.', ':', ';', '=', '-', '_', '|', '/', '\\', '<', '>', '^', 'v', 'o', 'O', '@', '~', '`'];
            var maxDist = cachedValues.maxDist;
            var centerX = cachedValues.centerX;
            var centerY = cachedValues.centerY;
            
            for (var y = 0; y < HEIGHT; y++) {
                for (var x = 0; x < WIDTH; x++) {
                    var dx = x - centerX;
                    var dy = y - centerY;
                    var dist = distance(dx, dy);
                    var angle = Math.atan2(dy, dx);
                    var normalizedDist = dist / maxDist;
                    
                    var radialWave1 = Math.sin(dist * 0.15 - time * 2.5 - bass * 6);
                    var radialWave2 = Math.sin(dist * 0.25 - time * 1.8 - mid * 4);
                    var radialWave3 = Math.sin(dist * 0.35 - time * 1.2 - treble * 3);
                    
                    var ringRadius1 = (bass * 40 + time * 3) % 60;
                    var ringRadius2 = (mid * 35 + time * 2.5) % 55;
                    var ringRadius3 = (treble * 30 + time * 2) % 50;
                    var ring1 = Math.abs(dist - ringRadius1) < 2.5;
                    var ring2 = Math.abs(dist - ringRadius2) < 2;
                    var ring3 = Math.abs(dist - ringRadius3) < 1.5;
                    
                    var numSegments = 6 + Math.floor(bass * 4);
                    var segmentAngle = (2 * Math.PI) / numSegments;
                    var segmentIndex = Math.floor((angle + Math.PI) / segmentAngle);
                    var segmentAngleCenter = segmentIndex * segmentAngle - Math.PI;
                    var angleOffset = angle - segmentAngleCenter;
                    
                    var swirl = Math.sin(dist * 0.2 - angle * 3 + time * 2 + overall * 5);
                    var segmentSwirl = Math.abs(angleOffset) < segmentAngle / 2 && swirl > 0.3;
                    
                    var grain = Math.sin(dist * 0.3 + angle * 2 + time * 1.5) * 
                                Math.cos(dist * 0.2 - angle * 1.5 + time * 1.8);
                    var grainyPattern = grain > (0.4 - overall * 0.5);
                    
                    var pulsePhase = Math.sin(time * 1.5 + overall * 3);
                    var pulseDist = dist - (pulsePhase * 15 * overall);
                    var pulseWave = Math.sin(pulseDist * 0.2) > 0.5;
                    
                    var spiral1 = Math.sin(dist * 0.1 - angle * 4 + time * 2 + bass * 4);
                    var spiral2 = Math.sin(dist * 0.15 - angle * 6 + time * 1.5 + mid * 3);
                    var spiral3 = Math.sin(dist * 0.2 - angle * 8 + time * 1.2 + treble * 2);
                    
                    var radialPattern1 = radialWave1 > (0.2 - bass * 0.4);
                    var radialPattern2 = radialWave2 > (0.1 - mid * 0.3);
                    var radialPattern3 = radialWave3 > (0.0 - treble * 0.2);
                    
                    var threshold = 0.3 + overall * 0.5;
                    var random = Math.random();
                    var charIndex = Math.floor((normalizedDist + random) * chars.length) % chars.length;
                    
                    if (ring1 && bass > 0.15) {
                        grid[y][x] = chars[Math.floor(bass * chars.length)];
                    } else if (ring2 && mid > 0.15) {
                        grid[y][x] = chars[Math.floor(mid * chars.length)];
                    } else if (ring3 && treble > 0.15) {
                        grid[y][x] = chars[Math.floor(treble * chars.length)];
                    } else if (segmentSwirl && overall > 0.2 && random > threshold * 0.6) {
                        grid[y][x] = chars[charIndex];
                    } else if (radialPattern1 && bass > 0.2 && random > threshold * 0.7) {
                        grid[y][x] = '#';
                    } else if (radialPattern2 && mid > 0.2 && random > threshold * 0.75) {
                        grid[y][x] = '+';
                    } else if (radialPattern3 && treble > 0.2 && random > threshold * 0.8) {
                        grid[y][x] = '.';
                    } else if (spiral1 > 0.5 && bass > 0.15) {
                        grid[y][x] = '/';
                    } else if (spiral2 > 0.5 && mid > 0.15) {
                        grid[y][x] = '\\';
                    } else if (spiral3 > 0.5 && treble > 0.15) {
                        grid[y][x] = '|';
                    } else if (pulseWave && overall > 0.25 && random > threshold * 0.65) {
                        grid[y][x] = chars[charIndex];
                    } else if (grainyPattern && overall > 0.15 && random > threshold * 0.9) {
                        grid[y][x] = ':';
                    } else if (random > 0.88 + overall * 0.12) {
                        if (dist < 25 + overall * 20) {
                            grid[y][x] = '.';
                        }
                    }
                }
            }
        }
        
        /**
         * Animation Style 2: Matrix-style vertical streams.
         * Vertical falling streams of characters that respond to frequency bands.
         * Each column represents a different frequency range.
         * 
         * @function animateMatrix
         * @param {Object} audio - Audio data object from getAudioData()
         * @description Creates Matrix-inspired falling character streams
         * @modifies {Array<Array<string>>} grid - Populates grid with falling stream characters
         */
        function animateMatrix(audio) {
            var bass = audio.bass;
            var mid = audio.mid;
            var treble = audio.treble;
            var overall = audio.overall;
            var freqBands = audio.freqBands;
            
            // Character sets by density
            var heavyChars = ['#', '@', '█', '▓', '▒'];
            var mediumChars = ['+', '*', '░', '·', 'o'];
            var lightChars = ['.', ':', '·', "'", '`'];
            var allChars = heavyChars.concat(mediumChars).concat(lightChars);
            
            // Create vertical columns that respond to frequency bands
            var numColumns = Math.min(WIDTH, freqBands.length || 64);
            var columnWidth = WIDTH / numColumns;
            
            for (var y = 0; y < HEIGHT; y++) {
                for (var x = 0; x < WIDTH; x++) {
                    var columnIndex = Math.floor(x / columnWidth);
                    var freqValue = freqBands[columnIndex] || 0;
                    
                    // Vertical position affects character selection
                    var verticalPos = y / HEIGHT;
                    var speed = 0.5 + overall * 0.5;
                    var streamPos = (y + time * speed * 20) % (HEIGHT + 20);
                    
                    // Create falling stream effect
                    var streamLength = 5 + Math.floor(freqValue * 15);
                    var inStream = streamPos < streamLength;
                    var streamIndex = Math.floor(streamPos / streamLength * streamLength);
                    
                    // Character selection based on position in stream
                    var charDensity = 1 - (streamIndex / streamLength);
                    var threshold = 0.3 + freqValue * 0.7;
                    
                    if (inStream && charDensity > threshold) {
                        // Select character based on density and frequency
                        var charSet;
                        if (freqValue > 0.6) {
                            charSet = heavyChars;
                        } else if (freqValue > 0.3) {
                            charSet = mediumChars;
                        } else {
                            charSet = lightChars;
                        }
                        var charIndex = Math.floor(charDensity * charSet.length);
                        grid[y][x] = charSet[charIndex];
                    } else if (Math.random() > 0.95 && freqValue > 0.2) {
                        // Random sparkles
                        grid[y][x] = lightChars[Math.floor(Math.random() * lightChars.length)];
                    }
                    
                    // Add horizontal wave effect based on mid frequencies
                    var waveX = x + Math.sin(y * 0.1 + time * 2 + mid * 3) * 2;
                    if (Math.abs(waveX - x) < 1 && mid > 0.3) {
                        grid[y][x] = mediumChars[Math.floor(mid * mediumChars.length)];
                    }
                }
            }
        }
        
        /**
         * Animation Style 3: Ripple/wave patterns.
         * Expanding circular ripples from multiple moving sources.
         * Creates a water-like effect that pulses with the music.
         * 
         * @function animateRipple
         * @param {Object} audio - Audio data object from getAudioData()
         * @description Creates expanding ripple wave patterns
         * @modifies {Array<Array<string>>} grid - Populates grid with ripple pattern characters
         */
        function animateRipple(audio) {
            var bass = audio.bass;
            var mid = audio.mid;
            var treble = audio.treble;
            var overall = audio.overall;
            var peakFreq = audio.peakFreq;
            
            var chars = ['o', 'O', '●', '○', '.', ':', '·', '~', '≈', '≋'];
            var centerX = cachedValues.centerX;
            var centerY = cachedValues.centerY;
            
            // Multiple ripple sources
            var numSources = 3 + Math.floor(bass * 3);
            var sources = [];
            for (var s = 0; s < numSources; s++) {
                sources.push({
                    x: centerX + Math.sin(time * 0.5 + s) * (WIDTH * 0.3),
                    y: centerY + Math.cos(time * 0.5 + s) * (HEIGHT * 0.3),
                    phase: time * 2 + s * Math.PI / numSources,
                    intensity: 0.5 + (s % 2) * 0.5
                });
            }
            
            for (var y = 0; y < HEIGHT; y++) {
                for (var x = 0; x < WIDTH; x++) {
                    var maxRipple = 0;
                    var rippleChar = ' ';
                    
                    // Calculate ripples from all sources
                    for (var s = 0; s < sources.length; s++) {
                        var source = sources[s];
                        var dx = x - source.x;
                        var dy = y - source.y;
                        var dist = distance(dx, dy);
                        
                        // Ripple wave calculation
                        var rippleRadius = dist - source.phase * 10;
                        var rippleWave = Math.sin(rippleRadius * 0.3);
                        var rippleIntensity = rippleWave * source.intensity;
                        
                        // Character selection based on ripple intensity
                        if (rippleIntensity > maxRipple) {
                            maxRipple = rippleIntensity;
                            var charIndex = Math.floor((rippleIntensity + 1) / 2 * chars.length);
                            charIndex = Math.max(0, Math.min(chars.length - 1, charIndex));
                            rippleChar = chars[charIndex];
                        }
                    }
                    
                    // Apply audio responsiveness
                    var audioBoost = 0.3 + overall * 0.7;
                    var threshold = 0.4;
                    
                    if (maxRipple * audioBoost > threshold) {
                        grid[y][x] = rippleChar;
                    } else if (Math.random() > 0.92 && overall > 0.2) {
                        // Background particles
                        grid[y][x] = '.';
                    }
                    
                    // Add expanding circles from bass hits
                    if (bass > 0.4) {
                        var dxCenter = x - centerX;
                        var dyCenter = y - centerY;
                        var distFromCenter = distance(dxCenter, dyCenter);
                        var bassRing = Math.abs(distFromCenter - (bass * 30 + time * 5 % 40)) < 2;
                        if (bassRing) {
                            grid[y][x] = '#';
                        }
                    }
                }
            }
        }
        
        /**
         * Animation Style 4: Spiral Vortex.
         * Rotating spiral patterns that create a vortex effect.
         * Multiple spiral arms respond to different frequency ranges.
         * 
         * @function animateSpiral
         * @param {Object} audio - Audio data object from getAudioData()
         * @description Creates rotating spiral vortex patterns
         * @modifies {Array<Array<string>>} grid - Populates grid with spiral pattern characters
         */
        function animateSpiral(audio) {
            var bass = audio.bass;
            var mid = audio.mid;
            var treble = audio.treble;
            var overall = audio.overall;
            
            var chars = ['/', '\\', '|', '-', '=', '+', '*', '#', '@'];
            var centerX = cachedValues.centerX;
            var centerY = cachedValues.centerY;
            
            for (var y = 0; y < HEIGHT; y++) {
                for (var x = 0; x < WIDTH; x++) {
                    var dx = x - centerX;
                    var dy = y - centerY;
                    var dist = distance(dx, dy);
                    var angle = Math.atan2(dy, dx);
                    
                    // Create spiral pattern
                    var spiralAngle = angle + dist * 0.2 - time * 2 - overall * 3;
                    var spiralWave = Math.sin(spiralAngle * 3);
                    
                    // Multiple spiral arms
                    var arm1 = Math.sin(spiralAngle * 2 + bass * 5);
                    var arm2 = Math.sin(spiralAngle * 3 + mid * 4);
                    var arm3 = Math.sin(spiralAngle * 4 + treble * 3);
                    
                    // Rotating vortex effect
                    var vortexSpeed = 1 + overall * 2;
                    var vortexAngle = angle + time * vortexSpeed;
                    var vortexDist = dist - (time * 0.5) % 50;
                    var vortexWave = Math.sin(vortexDist * 0.1 + vortexAngle * 2);
                    
                    var threshold = 0.3 + overall * 0.5;
                    var random = Math.random();
                    
                    // Character selection based on spiral position
                    var charIndex = Math.floor((spiralWave + 1) / 2 * chars.length);
                    charIndex = Math.max(0, Math.min(chars.length - 1, charIndex));
                    
                    if (spiralWave > threshold && dist < WIDTH * 0.6) {
                        grid[y][x] = chars[charIndex];
                    } else if (arm1 > 0.5 && bass > 0.2 && dist < WIDTH * 0.5) {
                        grid[y][x] = '#';
                    } else if (arm2 > 0.5 && mid > 0.2 && dist < WIDTH * 0.5) {
                        grid[y][x] = '+';
                    } else if (arm3 > 0.5 && treble > 0.2 && dist < WIDTH * 0.5) {
                        grid[y][x] = '*';
                    } else if (vortexWave > 0.4 && overall > 0.25) {
                        grid[y][x] = '.';
                    } else if (random > 0.92 && overall > 0.15) {
                        grid[y][x] = ':';
                    }
                }
            }
        }
        
        /**
         * Animation Style 5: Spectrum Bars (horizontal frequency bars).
         * Horizontal frequency bars showing the audio spectrum.
         * Classic equalizer-style visualization with peak indicators.
         * 
         * @function animateSpectrum
         * @param {Object} audio - Audio data object from getAudioData()
         * @description Creates horizontal frequency spectrum bars
         * @modifies {Array<Array<string>>} grid - Populates grid with spectrum bar characters
         */
        function animateSpectrum(audio) {
            var freqBands = audio.freqBands;
            var overall = audio.overall;
            
            var chars = ['█', '▓', '▒', '░', '▄', '▀', '▌', '▐'];
            var numBars = Math.min(WIDTH, freqBands.length || 64);
            var barWidth = WIDTH / numBars;
            
            for (var y = 0; y < HEIGHT; y++) {
                for (var x = 0; x < WIDTH; x++) {
                    var barIndex = Math.floor(x / barWidth);
                    var freqValue = freqBands[barIndex] || 0;
                    
                    // Calculate bar height based on frequency
                    var barHeight = Math.floor(freqValue * HEIGHT * 0.8);
                    var barY = HEIGHT - barHeight;
                    
                    // Position within the bar
                    var posInBar = (x % barWidth) / barWidth;
                    var yPos = HEIGHT - y - 1;
                    
                    if (yPos >= barY && yPos < HEIGHT) {
                        // Different characters for different parts of the bar
                        var charIndex;
                        var distFromTop = yPos - barY;
                        var barLength = HEIGHT - barY;
                        
                        if (barLength > 0) {
                            var normalizedPos = distFromTop / barLength;
                            if (normalizedPos < 0.1) {
                                charIndex = 0; // Top: solid
                            } else if (normalizedPos < 0.3) {
                                charIndex = 1; // Upper: heavy
                            } else if (normalizedPos < 0.6) {
                                charIndex = 2; // Middle: medium
                            } else {
                                charIndex = 3; // Lower: light
                            }
                        } else {
                            charIndex = 0;
                        }
                        
                        grid[y][x] = chars[charIndex];
                    } else if (Math.random() > 0.98 && freqValue > 0.3) {
                        // Sparkles above bars
                        grid[y][x] = '.';
                    }
                    
                    // Add peak indicators
                    if (freqValue > 0.8 && yPos === barY - 1 && yPos >= 0) {
                        grid[y][x] = '^';
                    }
                }
            }
        }
        
        /**
         * Animation Style 6: Starfield.
         * Moving stars and particles that create a 3D starfield effect.
         * Particles move toward the viewer, creating depth perception.
         * 
         * @function animateStarfield
         * @param {Object} audio - Audio data object from getAudioData()
         * @description Creates 3D starfield particle effect
         * @modifies {Array} particles - Updates particle positions and properties
         * @modifies {Array<Array<string>>} grid - Populates grid with starfield characters
         */
        function animateStarfield(audio) {
            var bass = audio.bass;
            var mid = audio.mid;
            var treble = audio.treble;
            var overall = audio.overall;
            
            var chars = ['.', '·', '*', '+', 'o', 'O', '●'];
            
            // Initialize or update star positions
            if (!particles || particles.length === 0) {
                particles = [];
                var numParticles = useWebGL ? 1000 : 200; // More particles with WebGL
                for (var i = 0; i < numParticles; i++) {
                    particles.push({
                        x: Math.random() * WIDTH,
                        y: Math.random() * HEIGHT,
                        z: Math.random() * 100,
                        speed: 0.5 + Math.random() * 1.5,
                        life: 1.0,
                        size: 1.0 + Math.random()
                    });
                }
            }
            
            // Update particle positions
            for (var i = 0; i < particles.length; i++) {
                var p = particles[i];
                p.z -= p.speed * (1 + overall * 2);
                p.life = Math.max(0, Math.min(1, 1 - (p.z / 100)));
                
                if (p.z <= 0) {
                    p.x = Math.random() * WIDTH;
                    p.y = Math.random() * HEIGHT;
                    p.z = 100;
                    p.life = 1.0;
                }
            }
            
            // Use WebGL if available
            if (useWebGL && webglRenderer) {
                webglCanvas.style.display = 'block';
                webglRenderer.updateParticles(particles, audio, WIDTH, HEIGHT);
                // Still populate grid for background/fallback
                for (var y = 0; y < HEIGHT; y++) {
                    for (var x = 0; x < WIDTH; x++) {
                        grid[y][x] = ' ';
                    }
                }
                return;
            }
            
            // Fallback to ASCII rendering
            for (var y = 0; y < HEIGHT; y++) {
                for (var x = 0; x < WIDTH; x++) {
                    var closestDist = Infinity;
                    var closestChar = ' ';
                    
                    for (var i = 0; i < particles.length; i++) {
                        var p = particles[i];
                        var scale = 200 / (p.z + 1);
                        var screenX = p.x * scale;
                        var screenY = p.y * scale;
                        
                        var dx = x - screenX;
                        var dy = y - screenY;
                        var distSq = distSquared(dx, dy);
                        
                        // Use squared distance for comparison (avoid sqrt)
                        if (distSq < 1 && p.z < closestDist) {
                            closestDist = p.z;
                            var brightness = 1 - (p.z / 100);
                            var charIndex = Math.floor(brightness * chars.length);
                            charIndex = Math.max(0, Math.min(chars.length - 1, charIndex));
                            closestChar = chars[charIndex];
                        }
                    }
                    
                    grid[y][x] = closestChar;
                    
                    // Add audio-reactive trails
                    if (overall > 0.3 && Math.random() > 0.95) {
                        grid[y][x] = '*';
                    }
                }
            }
        }
        
        /**
         * Animation Style 7: Waveform (oscilloscope style).
         * Oscilloscope-style waveform visualization.
         * Shows the audio signal as a continuous wave across the screen.
         * 
         * @function animateWaveform
         * @param {Object} audio - Audio data object from getAudioData()
         * @description Creates oscilloscope-style waveform visualization
         * @modifies {Array<Array<string>>} grid - Populates grid with waveform characters
         */
        function animateWaveform(audio) {
            var freqBands = audio.freqBands;
            var overall = audio.overall;
            var bass = audio.bass;
            var mid = audio.mid;
            var treble = audio.treble;
            
            var chars = ['_', '-', '=', '~', '^', 'v', '/', '\\', '|'];
            var centerY = HEIGHT / 2;
            
            // Create waveform from frequency data
            var waveform = [];
            var numSamples = WIDTH;
            for (var i = 0; i < numSamples; i++) {
                var freqIndex = Math.floor((i / numSamples) * freqBands.length);
                var amplitude = freqBands[freqIndex] || 0;
                waveform.push(amplitude);
            }
            
            // Add time-based wave modulation
            for (var x = 0; x < WIDTH; x++) {
                var wavePhase = (x * 0.1) + (time * 2);
                var waveMod = Math.sin(wavePhase) * overall * 0.3;
                waveform[x] = waveform[x] + waveMod;
            }
            
            for (var y = 0; y < HEIGHT; y++) {
                for (var x = 0; x < WIDTH; x++) {
                    var amplitude = waveform[x];
                    var waveY = centerY - (amplitude * HEIGHT * 0.4);
                    var dist = Math.abs(y - waveY);
                    
                    // Draw waveform line
                    if (dist < 0.5) {
                        grid[y][x] = '_';
                    } else if (dist < 1) {
                        grid[y][x] = '-';
                    } else if (dist < 2 && amplitude > 0.5) {
                        grid[y][x] = '.';
                    }
                    
                    // Add frequency bands visualization
                    var bandIndex = Math.floor((x / WIDTH) * freqBands.length);
                    var bandValue = freqBands[bandIndex] || 0;
                    
                    if (bandValue > 0.6 && Math.abs(y - (centerY - bandValue * HEIGHT * 0.3)) < 1) {
                        grid[y][x] = '#';
                    } else if (bandValue > 0.4 && Math.abs(y - (centerY - bandValue * HEIGHT * 0.3)) < 1) {
                        grid[y][x] = '+';
                    }
                    
                    // Center line
                    if (Math.abs(y - centerY) < 0.5) {
                        grid[y][x] = '-';
                    }
                }
            }
        }
        
        /**
         * Animation Style 8: Kaleidoscope (symmetric patterns).
         * Symmetric, mirrored patterns that create kaleidoscope effects.
         * Multiple segments rotate and reflect to create mesmerizing patterns.
         * 
         * @function animateKaleidoscope
         * @param {Object} audio - Audio data object from getAudioData()
         * @description Creates symmetric kaleidoscope patterns
         * @modifies {Array<Array<string>>} grid - Populates grid with kaleidoscope pattern characters
         */
        function animateKaleidoscope(audio) {
            var bass = audio.bass;
            var mid = audio.mid;
            var treble = audio.treble;
            var overall = audio.overall;
            
            var chars = ['#', '+', '*', '.', ':', 'o', 'O', '@', '~'];
            var centerX = cachedValues.centerX;
            var centerY = cachedValues.centerY;
            var numSegments = 8 + Math.floor(bass * 4); // 8-12 segments
            
            for (var y = 0; y < HEIGHT; y++) {
                for (var x = 0; x < WIDTH; x++) {
                    var dx = x - centerX;
                    var dy = y - centerY;
                    var dist = distance(dx, dy);
                    var angle = Math.atan2(dy, dx);
                    
                    // Create symmetric segments
                    var segmentAngle = (2 * Math.PI) / numSegments;
                    var normalizedAngle = (angle + Math.PI) % segmentAngle;
                    var mirroredAngle = normalizedAngle < segmentAngle / 2 
                        ? normalizedAngle 
                        : segmentAngle - normalizedAngle;
                    
                    // Radial patterns
                    var radialWave = Math.sin(dist * 0.2 - time * 2 - overall * 3);
                    var radialPattern = radialWave * Math.cos(mirroredAngle * numSegments);
                    
                    // Angular patterns
                    var angularWave = Math.sin(mirroredAngle * numSegments * 2 + time * 1.5);
                    
                    // Distance-based patterns
                    var distWave = Math.sin(dist * 0.15 - time * 1.8);
                    
                    // Combine patterns
                    var pattern = (radialPattern + angularWave + distWave) / 3;
                    var threshold = 0.2 + overall * 0.6;
                    var random = Math.random();
                    
                    if (pattern > threshold && dist < WIDTH * 0.6) {
                        var charIndex = Math.floor((pattern + 1) / 2 * chars.length);
                        charIndex = Math.max(0, Math.min(chars.length - 1, charIndex));
                        grid[y][x] = chars[charIndex];
                    } else if (radialPattern > 0.5 && bass > 0.2) {
                        grid[y][x] = '#';
                    } else if (angularWave > 0.5 && mid > 0.2) {
                        grid[y][x] = '+';
                    } else if (distWave > 0.5 && treble > 0.2) {
                        grid[y][x] = '*';
                    } else if (random > 0.94 && overall > 0.15) {
                        grid[y][x] = '.';
                    }
                }
            }
        }
        
        /**
         * Animation Style 9: Particle Explosion.
         * Exploding particles from the center that respond to bass hits.
         * Particles are attracted back to the center, creating dynamic explosions.
         * 
         * @function animateParticles
         * @param {Object} audio - Audio data object from getAudioData()
         * @description Creates particle explosion effects
         * @modifies {Array} particles - Updates particle positions, velocities, and life
         * @modifies {Array<Array<string>>} grid - Populates grid with particle characters
         */
        function animateParticles(audio) {
            var bass = audio.bass;
            var mid = audio.mid;
            var treble = audio.treble;
            var overall = audio.overall;
            
            var chars = ['*', '+', 'o', 'O', '●', '.', ':', '·'];
            var centerX = cachedValues.centerX;
            var centerY = cachedValues.centerY;
            
            // Initialize particles if needed
            if (!particles || particles.length === 0 || bass > 0.5) {
                particles = [];
                var numParticles = useWebGL ? 500 : (50 + Math.floor(bass * 100));
                for (var i = 0; i < numParticles; i++) {
                    var angle = (i / numParticles) * Math.PI * 2;
                    var speed = 0.5 + Math.random() * 2;
                    particles.push({
                        x: centerX,
                        y: centerY,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.0,
                        decay: 0.01 + Math.random() * 0.02,
                        size: Math.random() * 2 + 1
                    });
                }
            }
            
            // Update particles
            for (var i = particles.length - 1; i >= 0; i--) {
                var p = particles[i];
                p.x += p.vx * (1 + overall);
                p.y += p.vy * (1 + overall);
                p.life -= p.decay;
                
                // Apply gravity/attraction
                var dx = centerX - p.x;
                var dy = centerY - p.y;
                var distSq = distSquared(dx, dy);
                if (distSq > 0) {
                    var dist = Math.sqrt(distSq);
                    p.vx += (dx / dist) * 0.01 * mid;
                    p.vy += (dy / dist) * 0.01 * mid;
                }
                
                // Remove dead particles
                if (p.life <= 0 || p.x < 0 || p.x >= WIDTH || p.y < 0 || p.y >= HEIGHT) {
                    particles.splice(i, 1);
                }
            }
            
            // Use WebGL if available
            if (useWebGL && webglRenderer) {
                webglCanvas.style.display = 'block';
                webglRenderer.updateParticles(particles, audio, WIDTH, HEIGHT);
                // Still populate grid for background/fallback
                for (var y = 0; y < HEIGHT; y++) {
                    for (var x = 0; x < WIDTH; x++) {
                        grid[y][x] = ' ';
                    }
                }
                return;
            }
            
            // Fallback to ASCII rendering
            for (var y = 0; y < HEIGHT; y++) {
                for (var x = 0; x < WIDTH; x++) {
                    var closestDist = Infinity;
                    var closestChar = ' ';
                    
                    for (var i = 0; i < particles.length; i++) {
                        var p = particles[i];
                        var dx = x - p.x;
                        var dy = y - p.y;
                        var distSq = distSquared(dx, dy);
                        var pSizeSq = p.size * p.size;
                        
                        // Use squared distance for comparison (avoid sqrt)
                        if (distSq < pSizeSq && p.life > closestDist) {
                            closestDist = p.life;
                            var charIndex = Math.floor(p.life * chars.length);
                            charIndex = Math.max(0, Math.min(chars.length - 1, charIndex));
                            closestChar = chars[charIndex];
                        }
                    }
                    
                    grid[y][x] = closestChar;
                    
                    // Add trails
                    if (overall > 0.3 && Math.random() > 0.97) {
                        grid[y][x] = '.';
                    }
                }
            }
        }

        /**
         * Main animation loop.
         * Continuously updates and renders the visualization at ~60 FPS.
         * Uses requestAnimationFrame for smooth, browser-optimized animations.
         * 
         * @function animate
         * @description Main animation loop that updates and renders each frame
         */
        function animate() {
            update();
            render();
            requestAnimationFrame(animate);
        }

        /**
         * Loads an audio file from a URL.
         * Fetches the audio file, converts it to a File object, and auto-plays.
         * 
         * @function loadAudioFromURL
         * @param {string} url - URL path to the audio file
         * @param {string} displayName - Display name for the audio file
         * @description Fetches and loads audio file from URL, then starts playback
         * @modifies {File} audioFile - Sets the loaded audio file
         * @modifies {HTMLElement} filename.textContent - Updates displayed filename
         * @modifies {boolean} shouldLoop - Enables looping for auto-loaded files
         */
        function loadAudioFromURL(url, displayName) {
            fetch(url)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('File not found: ' + url);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Create a File-like object from the array buffer
                    var blob = new Blob([arrayBuffer], { type: 'audio/mpeg' });
                    audioFile = new File([blob], displayName || url.split('/').pop(), { type: 'audio/mpeg' });
                    filename.textContent = audioFile.name;
                    playBtn.disabled = false;
                    shouldLoop = true; // Enable looping for auto-loaded file
                    console.log('Audio file loaded:', audioFile.name);
                    // Auto-play after loading
                    playAudio();
                })
                .catch(function(error) {
                    console.error('Error loading audio file:', error);
                    filename.textContent = 'Error: Could not load ' + (displayName || url);
                });
        }

        /**
         * Attempts to auto-load an MP3 file from the current directory.
         * First checks for a file specified in URL parameters, then tries common filenames.
         * 
         * @function autoLoadMP3
         * @description Auto-detects and loads MP3 files from directory or URL parameter
         * @see loadAudioFromURL - Called when a file is found
         */
        function autoLoadMP3() {
            // First, check if there's a file specified in URL parameter
            var urlParams = new URLSearchParams(window.location.search);
            var fileParam = urlParams.get('file');
            
            if (fileParam) {
                // Load file specified in URL parameter
                loadAudioFromURL(fileParam, fileParam);
                return;
            }
            
            // Try to find and load MP3 files in current directory
            // List of potential MP3 filenames to try
            var mp3Files = [
                'ElevenLabs_2025-11-10T15_48_49_Daniel_pre_sp100_s50_sb75_se0_b_m2.mp3',
                'audio.mp3',
                'music.mp3',
                'song.mp3',
                'sound.mp3'
            ];
            
            // Try loading each file until one succeeds
            var tryNextFile = function(index) {
                if (index >= mp3Files.length) {
                    console.log('No MP3 files found in current directory');
                    return;
                }
                
                var fileName = mp3Files[index];
                fetch(fileName)
                    .then(function(response) {
                        if (response.ok) {
                            // File exists, load it
                            loadAudioFromURL(fileName, fileName);
                        } else {
                            // Try next file
                            tryNextFile(index + 1);
                        }
                    })
                    .catch(function() {
                        // Try next file
                        tryNextFile(index + 1);
                    });
            };
            
            // Start trying files
            tryNextFile(0);
        }

        /**
         * Plays the loaded audio file with Web Audio API.
         * Creates or reuses AudioContext, sets up analyser, and handles looping.
         * 
         * @function playAudio
         * @description Starts audio playback with Web Audio API analysis
         * @modifies {AudioContext} audioContext - Creates or reuses audio context
         * @modifies {AnalyserNode} analyser - Sets up frequency analyser
         * @modifies {boolean} isPlaying - Sets playback state
         * @modifies {HTMLElement} controls - Hides controls during playback
         */
        function playAudio() {
            if (!audioFile && !audioBuffer) return;

            if (source) {
                source.stop();
            }

            // Create or reuse AudioContext
            if (!audioContext) {
                var AC = window.AudioContext || window.webkitAudioContext;
                audioContext = new AC();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = CONFIG.FFT_SIZE;
                frequencyData = new Uint8Array(analyser.frequencyBinCount);
            }

            // Function to start playback with the buffer
            function startPlayback(buffer) {
                audioBuffer = buffer; // Store buffer for looping
                
                source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                source.start(0);
                
                isPlaying = true;
                playBtn.disabled = true;
                stopBtn.disabled = false;
                // Hide controls when playing
                controls.classList.add('hidden');

                source.onended = function() {
                    // If looping is enabled, restart playback
                    if (shouldLoop && audioBuffer) {
                        // Small delay before restarting for smooth loop
                        setTimeout(function() {
                            if (isPlaying) { // Only restart if still supposed to be playing
                                startPlayback(audioBuffer);
                            }
                        }, CONFIG.LOOP_DELAY);
                    } else {
                        isPlaying = false;
                        playBtn.disabled = false;
                        stopBtn.disabled = true;
                        // Show controls when audio ends (only if not looping)
                        controls.classList.remove('hidden');
                    }
                };
            }

            // If we already have the buffer, use it directly
            if (audioBuffer) {
                startPlayback(audioBuffer);
            } else {
                // Otherwise, load the file
                var reader = new FileReader();
                reader.onload = function(evt) {
                    audioContext.decodeAudioData(evt.target.result, function(buffer) {
                        startPlayback(buffer);
                    });
                };
                reader.readAsArrayBuffer(audioFile);
            }
        }

        fileInput.addEventListener('change', function(e) {
            var file = e.target.files[0];
            if (file) {
                audioFile = file;
                audioBuffer = null; // Reset buffer when new file is selected
                filename.textContent = file.name;
                playBtn.disabled = false;
                shouldLoop = true; // Enable looping for new file
                // Auto-play when file is manually selected
                playAudio();
            }
        });

        playBtn.addEventListener('click', function() {
            playAudio();
        });

        stopBtn.addEventListener('click', function() {
            if (source) {
                shouldLoop = false; // Disable looping when manually stopped
                source.stop();
                isPlaying = false;
                playBtn.disabled = false;
                stopBtn.disabled = true;
                // Show controls when stopped
                controls.classList.remove('hidden');
            }
        });

        // Animation style selector with blending
        animationSelect.addEventListener('change', function(e) {
            var newStyle = e.target.value;
            if (newStyle !== currentAnimationStyle) {
                // Start blending transition
                blending.from = currentAnimationStyle;
                blending.to = newStyle;
                blending.active = true;
                blending.progress = 0;
                
                currentAnimationStyle = newStyle;
                
                // Reset particles when switching to animations that use them
                if (currentAnimationStyle === 'starfield' || currentAnimationStyle === 'particles') {
                    particles = [];
                }
                
                // Hide WebGL canvas for non-particle animations
                if (currentAnimationStyle !== 'starfield' && currentAnimationStyle !== 'particles') {
                    if (webglCanvas) {
                        webglCanvas.style.display = 'none';
                    }
                }
            }
        });
        
        // Touch gesture handling
        var touchState = {
            startX: 0,
            startY: 0,
            startTime: 0,
            isLongPress: false,
            longPressTimer: null
        };
        
        function showGestureFeedback(text) {
            gestureFeedback.textContent = text;
            gestureFeedback.classList.add('show');
            setTimeout(function() {
                gestureFeedback.classList.remove('show');
            }, 500);
        }
        
        function getSwipeDirection(dx, dy) {
            var absX = Math.abs(dx);
            var absY = Math.abs(dy);
            var minSwipeDistance = 50;
            
            if (absX < minSwipeDistance && absY < minSwipeDistance) {
                return null;
            }
            
            if (absX > absY) {
                return dx > 0 ? 'right' : 'left';
            } else {
                return dy > 0 ? 'down' : 'up';
            }
        }
        
        function changeAnimationStyle(direction) {
            var styles = Object.keys(animationRegistry);
            var currentIndex = styles.indexOf(currentAnimationStyle);
            var newIndex;
            
            if (direction === 'left') {
                newIndex = (currentIndex - 1 + styles.length) % styles.length;
            } else {
                newIndex = (currentIndex + 1) % styles.length;
            }
            
            var newStyle = styles[newIndex];
            animationSelect.value = newStyle;
            animationSelect.dispatchEvent(new Event('change'));
            showGestureFeedback(animationSelect.options[animationSelect.selectedIndex].text);
        }
        
        document.addEventListener('touchstart', function(e) {
            if (e.touches.length === 1) {
                var touch = e.touches[0];
                touchState.startX = touch.clientX;
                touchState.startY = touch.clientY;
                touchState.startTime = Date.now();
                touchState.isLongPress = false;
                
                // Long press detection
                touchState.longPressTimer = setTimeout(function() {
                    touchState.isLongPress = true;
                    showGestureFeedback('Long Press');
                    controls.classList.toggle('hidden');
                }, 500);
            }
        }, { passive: true });
        
        document.addEventListener('touchmove', function(e) {
            if (touchState.longPressTimer) {
                clearTimeout(touchState.longPressTimer);
                touchState.longPressTimer = null;
            }
        }, { passive: true });
        
        document.addEventListener('touchend', function(e) {
            if (touchState.longPressTimer) {
                clearTimeout(touchState.longPressTimer);
                touchState.longPressTimer = null;
            }
            
            if (e.changedTouches.length === 1 && !touchState.isLongPress) {
                var touch = e.changedTouches[0];
                var dx = touch.clientX - touchState.startX;
                var dy = touch.clientY - touchState.startY;
                var dt = Date.now() - touchState.startTime;
                
                // Tap detection (quick touch with minimal movement)
                if (dt < 300 && Math.abs(dx) < 10 && Math.abs(dy) < 10) {
                    // Toggle play/pause
                    if (isPlaying) {
                        stopBtn.click();
                    } else {
                        playBtn.click();
                    }
                    return;
                }
                
                // Swipe detection
                var direction = getSwipeDirection(dx, dy);
                if (direction) {
                    switch (direction) {
                        case 'left':
                        case 'right':
                            changeAnimationStyle(direction);
                            break;
                        case 'up':
                            if (!isFullscreen()) {
                                enterFullscreen();
                                showGestureFeedback('Fullscreen');
                            }
                            break;
                        case 'down':
                            controls.classList.toggle('hidden');
                            showGestureFeedback(controls.classList.contains('hidden') ? 'Controls Hidden' : 'Controls Shown');
                            break;
                    }
                }
            }
            
            touchState.isLongPress = false;
        }, { passive: true });
        
        // Show controls on hover or when pressing 'C' key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'c' || e.key === 'C') {
                controls.classList.toggle('hidden');
            }
        });
        
        // Show controls on mouse move (temporary)
        var controlsTimeout;
        document.addEventListener('mousemove', function() {
            if (controls.classList.contains('hidden')) {
                controls.classList.remove('hidden');
                clearTimeout(controlsTimeout);
                controlsTimeout = setTimeout(function() {
                    if (isPlaying) {
                        controls.classList.add('hidden');
                    }
                }, CONFIG.CONTROLS_AUTO_HIDE_DELAY);
            }
        });

        /**
         * Enters fullscreen mode for the entire page.
         * Uses browser-specific fullscreen APIs for cross-browser compatibility.
         * 
         * @function enterFullscreen
         * @description Requests fullscreen mode for the document
         */
        function enterFullscreen() {
            var element = document.documentElement; // Full screen the entire page
            
            // Check for different browser implementations
            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.webkitRequestFullscreen) { // Safari
                element.webkitRequestFullscreen();
            } else if (element.mozRequestFullScreen) { // Firefox
                element.mozRequestFullScreen();
            } else if (element.msRequestFullscreen) { // IE/Edge
                element.msRequestFullscreen();
            }
        }

        /**
         * Exits fullscreen mode.
         * Uses browser-specific exit fullscreen APIs.
         * 
         * @function exitFullscreen
         * @description Exits fullscreen mode
         */
        function exitFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { // Safari
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) { // Firefox
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) { // IE/Edge
                document.msExitFullscreen();
            }
        }

        /**
         * Checks if the page is currently in fullscreen mode.
         * 
         * @function isFullscreen
         * @returns {boolean} True if page is in fullscreen, false otherwise
         */
        function isFullscreen() {
            return !!(document.fullscreenElement || 
                     document.webkitFullscreenElement || 
                     document.mozFullScreenElement || 
                     document.msFullscreenElement);
        }

        /**
         * Updates the fullscreen button text based on current fullscreen state.
         * 
         * @function updateFullscreenButton
         * @modifies {HTMLElement} fullscreenBtn.textContent - Updates button label
         */
        function updateFullscreenButton() {
            if (isFullscreen()) {
                fullscreenBtn.textContent = 'Exit Fullscreen';
            } else {
                fullscreenBtn.textContent = 'Fullscreen';
            }
        }

        // Toggle fullscreen on button click
        fullscreenBtn.addEventListener('click', function() {
            if (isFullscreen()) {
                exitFullscreen();
            } else {
                enterFullscreen();
            }
        });

        // Listen for fullscreen changes to update button text
        document.addEventListener('fullscreenchange', updateFullscreenButton);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
        document.addEventListener('mozfullscreenchange', updateFullscreenButton);
        document.addEventListener('msfullscreenchange', updateFullscreenButton);

        // Also support F11 key for fullscreen (common shortcut)
        document.addEventListener('keydown', function(e) {
            // F11 key or F key
            if (e.key === 'F11' || (e.key === 'f' && !e.ctrlKey && !e.metaKey && !e.altKey)) {
                e.preventDefault();
                if (isFullscreen()) {
                    exitFullscreen();
                } else {
                    enterFullscreen();
                }
            }
            // Escape key to exit fullscreen
            if (e.key === 'Escape' && isFullscreen()) {
                exitFullscreen();
            }
        });

        // Screenshot functionality
        screenshotBtn.addEventListener('click', function() {
            // Create a canvas element to draw the text
            var canvasElement = document.createElement('canvas');
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
            var ctx = canvasElement.getContext('2d');
            
            // Set canvas background (matching the page background from theme)
            var bgColor = window.getComputedStyle(document.documentElement).getPropertyValue('--bg-color').trim() || '#f5f5f0';
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);
            
            // Draw WebGL canvas if visible
            if (useWebGL && webglCanvas && webglCanvas.style.display !== 'none') {
                ctx.drawImage(webglCanvas, 0, 0);
            }
            
            // Get computed styles from the canvas element
            var computedStyle = window.getComputedStyle(canvas);
            var fontSize = computedStyle.fontSize;
            var fontFamily = computedStyle.fontFamily;
            var color = computedStyle.color;
            var textShadow = computedStyle.textShadow;
            
            // Set font properties
            ctx.font = fontSize + ' ' + fontFamily;
            ctx.fillStyle = color;
            ctx.textBaseline = 'top';
            ctx.textAlign = 'left';
            
            // Parse text shadow for glow effect
            if (textShadow && textShadow !== 'none') {
                var shadowParts = textShadow.split(' ');
                if (shadowParts.length >= 3) {
                    ctx.shadowBlur = parseFloat(shadowParts[2]) || 5;
                    ctx.shadowColor = color;
                }
            }
            
            // Draw the text
            var lines = canvas.textContent.split('\n');
            var lineHeight = parseFloat(fontSize) * 1; // line-height is 1
            var y = 0;
            
            for (var i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i], 0, y);
                y += lineHeight;
            }
            
            // Convert canvas to image and download
            canvasElement.toBlob(function(blob) {
                var url = URL.createObjectURL(blob);
                var a = document.createElement('a');
                a.href = url;
                a.download = 'audio-visualizer-' + new Date().getTime() + '.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 'image/png');
        });

        // Initialize grid after calculating size
        initGrid();
        animate();
        
        // Auto-load MP3 file on page load
        autoLoadMP3();
        
        // Hide controls after a delay (to allow animation selection)
        setTimeout(function() {
            if (isPlaying) {
                controls.classList.add('hidden');
            }
        }, CONFIG.CONTROLS_HIDE_DELAY);
        
        // Auto-enter fullscreen on page load
        // Note: Browsers may require user interaction, so we try after a short delay
        // and also on first user interaction
        function tryAutoFullscreen() {
            // Try to enter fullscreen
            if (!isFullscreen()) {
                enterFullscreen();
            }
        }
        
        // Try fullscreen after page loads (may be blocked by browser)
        window.addEventListener('load', function() {
            setTimeout(tryAutoFullscreen, CONFIG.FULLSCREEN_DELAY);
        });
        
        // Also try fullscreen on first user interaction (click, touch, keypress)
        var hasInteracted = false;
        function tryFullscreenOnInteraction() {
            if (!hasInteracted && !isFullscreen()) {
                hasInteracted = true;
                tryAutoFullscreen();
            }
        }
        
        document.addEventListener('click', tryFullscreenOnInteraction, { once: true });
        document.addEventListener('touchstart', tryFullscreenOnInteraction, { once: true });
        document.addEventListener('keydown', tryFullscreenOnInteraction, { once: true });
    </script>
</body>
</html>