<!DOCTYPE html>
<html>
<head>
  <title>ISS Tracker</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
  <style>
    .radio-ui {
      position: fixed;
      left: 12px;
      bottom: 12px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.55);
      color: #fff;
      padding: 10px 12px;
      border-radius: 10px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif;
      font-size: 13px;
      backdrop-filter: blur(4px);
      max-width: min(92vw, 360px);
    }
    .radio-ui strong { display: inline-block; margin-right: 6px; }
    .radio-ui .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .radio-ui audio { width: 100%; margin-top: 6px; }
    .radio-hint { opacity: 0.8; font-size: 12px; margin-top: 6px; }
  </style>
</head>
<body>
  <div class="radio-ui" id="radio-ui">
    <div class="row"><strong>Radio</strong><span id="station-label">Waiting for ISS location…</span></div>
    <audio id="radio-player" controls preload="none"></audio>
    <div class="radio-hint">Click Play once to enable audio. The station switches automatically as the ISS changes region.</div>
  </div>
  <script>
    let particles = [];
    const numParticles = 50;
    let continentPoints = [];
    // Radio globals
    let radioPlayer;
    let stationLabel;
    let currentRegion = null;
    const regionStations = {
      'Ocean': { name: 'SomaFM Mission Control', url: 'https://ice2.somafm.com/missioncontrol-128-mp3' },
      'North America': { name: 'KEXP 90.3 Seattle', url: 'https://kexp.streamguys1.com/kexp128.mp3' },
      'South America': { name: 'Radio Paradise World', url: 'https://stream.radioparadise.com/world-128' },
      'Europe': { name: 'Radio Swiss Pop', url: 'https://stream.srg-ssr.ch/m/rsp/mp3_128' },
      'Africa': { name: 'RFI Monde', url: 'https://rfimonde64k.ice.infomaniak.ch/rfimonde-64.mp3' },
      'Asia': { name: 'SomaFM Groove Salad', url: 'https://ice2.somafm.com/groovesalad-128-mp3' },
      'Oceania': { name: 'SomaFM Space Station Soma', url: 'https://ice2.somafm.com/spacestation-128-mp3' }
    };

    function getRegion(lat, lon) {
      // Rough continent bounding boxes; fall back to Ocean
      if (lat >= 10 && lat <= 85 && lon >= -168 && lon <= -52) return 'North America';
      if (lat >= -56 && lat <= 12 && lon >= -82 && lon <= -34) return 'South America';
      if (lat >= 36 && lat <= 72 && lon >= -10 && lon <= 40) return 'Europe';
      if (lat >= -35 && lat <= 37 && lon >= -18 && lon <= 51) return 'Africa';
      if (lat >= 5 && lat <= 77 && lon >= 26 && lon <= 180) return 'Asia';
      if (lat >= -50 && lat <= -10 && lon >= 112 && lon <= 154) return 'Oceania';
      return 'Ocean';
    }

    function setStationForRegion(region) {
      const station = regionStations[region] || regionStations['Ocean'];
      if (!radioPlayer || !station) return;
      const wasPlaying = radioPlayer && !radioPlayer.paused && !radioPlayer.ended;
      const newSrc = station.url;
      const currentSrc = radioPlayer.currentSrc || radioPlayer.src;
      const isDifferent = !currentSrc || !currentSrc.includes(newSrc);
      // Update label regardless
      stationLabel.textContent = `${station.name} — ${region}`;
      if (!isDifferent) return;
      radioPlayer.src = newSrc;
      radioPlayer.dataset.station = station.name;
      if (wasPlaying) {
        radioPlayer.play().catch(() => {/* Autoplay blocked or user paused */});
      }
    }

    function updateRadioForLocation(lat, lon) {
      const region = getRegion(lat, lon);
      if (region !== currentRegion) {
        currentRegion = region;
        setStationForRegion(region);
      }
    }

    // Simulation mode (enabled via ?debug=1)
    let simulateMode = false;
    let simIndex = 0;
    const simTrack = [
      // Ocean (mid-Pacific)
      { lat: 10, lon: -150 },
      // North America (central US)
      { lat: 39, lon: -98 },
      // Europe (Berlin)
      { lat: 52.52, lon: 13.405 },
      // Africa (Nigeria)
      { lat: 9.076, lon: 7.398 },
      // Asia (Tokyo)
      { lat: 35.676, lon: 139.65 },
      // Oceania (Sydney)
      { lat: -33.8688, lon: 151.2093 },
      // South America (São Paulo)
      { lat: -23.55, lon: -46.633 },
      // Back to Ocean (mid-Atlantic)
      { lat: 0, lon: -30 }
    ];

    function setup() {
      createCanvas(windowWidth, windowHeight);
      // Wire radio UI
      radioPlayer = document.getElementById('radio-player');
      stationLabel = document.getElementById('station-label');
      // Initial default
      setStationForRegion('Ocean');
      // Determine simulation mode from URL param
      const params = new URLSearchParams(window.location.search);
      simulateMode = params.get('debug') === '1';
      
      // Generate continent outline points
      generateContinentPoints();
      
      // Create regular particles positioned on continents
      for (let i = 0; i < numParticles; i++) {
        let point = random(continentPoints);
        particles.push(new Particle(point.x, point.y, false));
      }
      // Create ISS particle
      let iss = new Particle(width / 2, height / 2, true);
      particles.push(iss);

      // Real ISS update
      function updateISSReal() {
        fetch('https://api.wheretheiss.at/v1/satellites/25544')
          .then(response => response.json())
          .then(data => {
            let lat = data.latitude;
            let lon = data.longitude;
            let x = map(lon, -180, 180, 0, width);
            let y = map(lat, 90, -90, 0, height);
            iss.target.set(x, y);
            updateRadioForLocation(lat, lon);
          })
          .catch(() => {
            // On failure, keep last position and station
          });
      }

      // Simulated ISS update
      function updateISSSim() {
        const point = simTrack[simIndex % simTrack.length];
        simIndex += 1;
        const lat = point.lat;
        const lon = point.lon;
        const x = map(lon, -180, 180, 0, width);
        const y = map(lat, 90, -90, 0, height);
        iss.target.set(x, y);
        updateRadioForLocation(lat, lon);
      }

      if (simulateMode) {
        updateISSSim();
        setInterval(updateISSSim, 5000);
      } else {
        updateISSReal();
        setInterval(updateISSReal, 5000);
      }
    }

    function generateContinentPoints() {
      continentPoints = [];
      
      // Convert lat/lon to screen coordinates
      function latLonToXY(lat, lon) {
        let x = map(lon, -180, 180, 0, width);
        let y = map(lat, 90, -90, 0, height);
        return {x: x, y: y};
      }
      
      // North America outline (simplified)
      let northAmerica = [
        [-60, -141], [-45, -141], [-45, -52], [-25, -80], [-25, -95], 
        [-30, -117], [-48, -125], [-60, -141]
      ];
      
      // South America outline (simplified)
      let southAmerica = [
        [12, -81], [12, -34], [-20, -34], [-35, -58], [-55, -68], 
        [-22, -81], [12, -81]
      ];
      
      // Europe outline (simplified)  
      let europe = [
        [71, -10], [71, 40], [36, 40], [36, -10], [71, -10]
      ];
      
      // Africa outline (simplified)
      let africa = [
        [37, -18], [37, 51], [-35, 51], [-35, 15], [-22, -18], [37, -18]
      ];
      
      // Asia outline (simplified)
      let asia = [
        [77, 26], [77, 180], [10, 180], [10, 60], [40, 26], [77, 26]
      ];
      
      // Australia outline (simplified)
      let australia = [
        [-10, 113], [-10, 154], [-44, 154], [-44, 113], [-10, 113]
      ];
      
      let continents = [northAmerica, southAmerica, europe, africa, asia, australia];
      
      // Generate points along continent outlines
      for (let continent of continents) {
        for (let i = 0; i < continent.length - 1; i++) {
          let start = latLonToXY(continent[i][0], continent[i][1]);
          let end = latLonToXY(continent[i + 1][0], continent[i + 1][1]);
          
          // Generate points along the line between start and end
          let steps = 10;
          for (let j = 0; j <= steps; j++) {
            let t = j / steps;
            let x = lerp(start.x, end.x, t);
            let y = lerp(start.y, end.y, t);
            continentPoints.push({x: x, y: y});
          }
        }
      }
      
      // Add some inland points for more realistic distribution
      for (let i = 0; i < continentPoints.length; i += 3) {
        let point = continentPoints[i];
        let offsetX = random(-50, 50);
        let offsetY = random(-50, 50);
        continentPoints.push({
          x: constrain(point.x + offsetX, 0, width),
          y: constrain(point.y + offsetY, 0, height)
        });
      }
    }

    function draw() {
      background(0);
      
      // Optional: Draw continent outline points as tiny dots (press 'm' to toggle)
      if (keyIsPressed && key === 'm') {
        stroke(50);
        strokeWeight(1);
        for (let point of continentPoints) {
          point(point.x, point.y);
        }
      }

      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          particles[i].collides(particles[j]);
        }
      }

      for (let particle of particles) {
        particle.update();
        particle.show();
      }
    }

    class Particle {
      constructor(x, y, isIss) {
        this.pos = createVector(x, y);
        this.originalPos = createVector(x, y); // Store original continent position
        this.isIss = isIss;
        this.isMoving = isIss; // Only ISS moves initially
        this.vel = createVector(0, 0);
        this.isResetting = false; // Track if particle is resetting to original position
        this.resetProgress = 0; // Progress of reset animation (0-1)
        this.baseRadius = this.isIss ? 40 : random(10, 30); // Store base radius for size animation
        if (this.isIss) {
          this.target = createVector(x, y);
          this.vel = p5.Vector.random2D().mult(random(1, 3));
        }
        this.r = this.baseRadius;
        this.m = this.r * 0.1;
        this.color = this.isIss ? color(255, 0, 0) : color(random(255), random(255), random(255));
      }

      collides(other) {
        let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);
        let minDist = this.r + other.r;
        
        if (d < minDist && d > 0) {
          // Special handling for ISS collisions - trigger bubble reset effect
          if ((this.isIss && !other.isIss && !other.isResetting) || 
              (!this.isIss && other.isIss && !this.isResetting)) {
            let regularParticle = this.isIss ? other : this;
            // Start the bubble reset animation
            regularParticle.startReset();
            return; // Skip normal collision physics for ISS collisions
          }
          
          // Normal collision physics for non-ISS particle interactions
          if (!this.isIss && !other.isIss) {
            // If one of the colliding particles is moving, the other one starts moving too.
            if (this.isMoving || other.isMoving) {
              this.isMoving = true;
              other.isMoving = true;
            }

            // Separate overlapping particles smoothly
            let overlap = minDist - d;
            let separationX = (other.pos.x - this.pos.x) / d * overlap * 0.5;
            let separationY = (other.pos.y - this.pos.y) / d * overlap * 0.5;
            
            this.pos.x -= separationX;
            this.pos.y -= separationY;
            other.pos.x += separationX;
            other.pos.y += separationY;

            // Calculate realistic elastic collision using conservation of momentum
            let dx = other.pos.x - this.pos.x;
            let dy = other.pos.y - this.pos.y;
            let distance = sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
              // Normalize collision vector
              dx /= distance;
              dy /= distance;
              
              // Relative velocity in collision normal direction
              let relativeVelX = other.vel.x - this.vel.x;
              let relativeVelY = other.vel.y - this.vel.y;
              let speed = relativeVelX * dx + relativeVelY * dy;
              
              // Do not resolve if velocities are separating
              if (speed > 0) return;
              
              // Collision impulse with damping for smoothness
              let restitution = 0.8; // Bouncy but not perfectly elastic
              let impulse = 2 * speed * restitution / (this.m + other.m);
              
              this.vel.x += impulse * other.m * dx;
              this.vel.y += impulse * other.m * dy;
              other.vel.x -= impulse * this.m * dx;
              other.vel.y -= impulse * this.m * dy;
            }
          }
        }
      }

      startReset() {
        if (!this.isIss && !this.isResetting) {
          this.isResetting = true;
          this.resetProgress = 0;
          this.isMoving = false; // Stop normal movement
          this.vel.mult(0); // Stop velocity
        }
      }

      update() {
        if (this.isIss) {
          let desired = p5.Vector.sub(this.target, this.pos);
          desired.setMag(2);
          let steer = p5.Vector.sub(desired, this.vel);
          steer.limit(0.1);
          this.vel.add(steer);
        } else if (this.isResetting) {
          // Handle bubble reset animation
          this.resetProgress += 0.025; // Slightly faster animation speed
          
          // Smooth easing function (ease-out cubic) for natural water movement
          let easeProgress = 1 - Math.pow(1 - this.resetProgress, 3);
          
          // Interpolate position back to original with water-like flow
          let lerpAmount = map(easeProgress, 0, 1, 0.05, 0.15); // Accelerating return
          this.pos.x = lerp(this.pos.x, this.originalPos.x, lerpAmount);
          this.pos.y = lerp(this.pos.y, this.originalPos.y, lerpAmount);
          
          // Create soap bubble effect with gentle pulsing
          let pulsePhase = this.resetProgress * Math.PI * 3; // Fewer, smoother pulses
          let sizeMultiplier = 1 + sin(pulsePhase) * 0.2 * (1 - easeProgress * 0.5); // Gentler pulsing that fades
          this.r = this.baseRadius * sizeMultiplier;
          
          // Complete reset when close enough to original position or animation complete
          let distanceToOriginal = dist(this.pos.x, this.pos.y, this.originalPos.x, this.originalPos.y);
          if (this.resetProgress >= 1 || distanceToOriginal < 3) {
            this.pos.set(this.originalPos);
            this.isResetting = false;
            this.resetProgress = 0;
            this.r = this.baseRadius; // Reset to normal size
          }
        } else if (this.isMoving) {
          // Add subtle attraction to nearest continent point for non-ISS particles
          let closestPoint = this.findClosestContinentPoint();
          if (closestPoint) {
            let distance = dist(this.pos.x, this.pos.y, closestPoint.x, closestPoint.y);
            if (distance > 100) { // Only apply attraction when far from continents
              let attract = p5.Vector.sub(createVector(closestPoint.x, closestPoint.y), this.pos);
              attract.setMag(0.02); // Very gentle attraction
              this.vel.add(attract);
            }
          }
        }

        if (this.isMoving && !this.isResetting) {
            this.pos.add(this.vel);

            // Bounce off edges only for moving non-ISS particles
            if (!this.isIss) {
              if (this.pos.x < this.r || this.pos.x > width - this.r) {
                this.vel.x *= -1;
                this.pos.x = constrain(this.pos.x, this.r, width - this.r);
              }
              if (this.pos.y < this.r || this.pos.y > height - this.r) {
                this.vel.y *= -1;
                this.pos.y = constrain(this.pos.y, this.r, height - this.r);
              }
            }
        }
      }

      findClosestContinentPoint() {
        if (continentPoints.length === 0) return null;
        
        let closest = continentPoints[0];
        let minDist = dist(this.pos.x, this.pos.y, closest.x, closest.y);
        
        for (let point of continentPoints) {
          let d = dist(this.pos.x, this.pos.y, point.x, point.y);
          if (d < minDist) {
            minDist = d;
            closest = point;
          }
        }
        
        return closest;
      }

      show() {
        noStroke();
        
        if (this.isResetting) {
          // Create water/soap bubble effect with dynamic transparency
          let fadeInOut = sin(this.resetProgress * Math.PI); // Fade in then out
          let alpha = map(fadeInOut, 0, 1, 150, 220); // More subtle transparency range
          
          // Outer bubble rim effect - more pronounced during reset
          stroke(red(this.color), green(this.color), blue(this.color), alpha * 0.6);
          strokeWeight(map(this.resetProgress, 0, 1, 3, 1)); // Thicker rim at start
          noFill();
          ellipse(this.pos.x, this.pos.y, this.r * 2 + 6);
          
          // Main bubble body with gradient-like effect
          noStroke();
          fill(red(this.color), green(this.color), blue(this.color), alpha);
          ellipse(this.pos.x, this.pos.y, this.r * 2);
          
          // Inner highlight for realistic soap bubble shimmer
          let highlightAlpha = alpha * 0.4;
          fill(255, 255, 255, highlightAlpha);
          ellipse(this.pos.x - this.r * 0.2, this.pos.y - this.r * 0.2, this.r * 0.4);
          
          // Secondary smaller highlight for more realism
          fill(255, 255, 255, highlightAlpha * 0.7);
          ellipse(this.pos.x + this.r * 0.3, this.pos.y + this.r * 0.1, this.r * 0.2);
        } else if (this.isIss) {
          // Heartbeat visual for ISS (double-beat pulse)
          const periodMs = 1100;
          const t = (millis() % periodMs) / periodMs;
          const pulse1 = Math.exp(-Math.pow((t - 0.06) / 0.06, 2));
          const pulse2 = Math.exp(-Math.pow((t - 0.26) / 0.06, 2));
          const amp = pulse1 + 0.75 * pulse2;
          const drawR = this.baseRadius * (1 + 0.22 * amp);

          // Outer glow rings
          const baseAlpha = 180;
          noFill();
          stroke(255, 70, 70, baseAlpha * 0.35 * (0.6 + 0.4 * amp));
          strokeWeight(3);
          ellipse(this.pos.x, this.pos.y, drawR * 2.6);
          stroke(255, 70, 70, baseAlpha * 0.25 * (0.6 + 0.4 * amp));
          strokeWeight(6);
          ellipse(this.pos.x, this.pos.y, drawR * 3.2);

          // Core
          noStroke();
          fill(red(this.color), green(this.color), blue(this.color), 220);
          ellipse(this.pos.x, this.pos.y, drawR * 2);
        } else {
          // Normal particle rendering
          fill(this.color);
          ellipse(this.pos.x, this.pos.y, this.r * 2);
        }
      }
    }
  </script>
</body>
</html>