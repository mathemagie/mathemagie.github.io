<!DOCTYPE html>
<html>
<head>
  <title>Radio ISS</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
  <style>
    .radio-ui {
      position: fixed;
      left: 12px;
      top: 12px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 10px 14px;
      border-radius: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif;
      font-size: 12px;
      backdrop-filter: blur(8px);
      max-width: min(90vw, 320px);
      min-width: 240px;
    }
    
    .radio-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }
    
    .radio-title {
      font-size: 14px;
      font-weight: 600;
      margin: 0;
    }
    
    .station-info {
      font-size: 12px;
      opacity: 0.9;
      flex: 1;
      min-width: 140px;
    }
    
    .fullscreen-btn {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.1);
      color: #fff;
      padding: 4px 10px;
      border-radius: 8px;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }
    
    .fullscreen-btn:hover {
      background: rgba(255,255,255,0.2);
      border-color: rgba(255,255,255,0.4);
    }
    
    .audio-controls {
      background: rgba(255,255,255,0.95);
      border-radius: 8px;
      padding: 8px 12px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .play-btn {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: none;
      background: #333;
      color: #fff;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    .time-display {
      color: #333;
      font-size: 11px;
      font-weight: 500;
      white-space: nowrap;
    }
    
    .progress-container {
      flex: 1;
      height: 4px;
      background: rgba(0,0,0,0.1);
      border-radius: 2px;
      overflow: hidden;
      margin: 0 6px;
    }
    
    .progress-bar {
      height: 100%;
      background: #333;
      width: 0%;
      transition: width 0.1s ease;
    }
    
    .volume-btn, .menu-btn {
      width: 20px;
      height: 20px;
      border: none;
      background: none;
      color: #333;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .radio-hint {
      color: rgba(255,255,255,0.8);
      font-size: 11px;
      line-height: 1.3;
    }
  </style>
</head>
<body>
  <div class="radio-ui" id="radio-ui">
    <div class="radio-header">
      <h2 class="radio-title">Radio</h2>
      <span id="station-label" class="station-info">Waiting for ISS location…</span>
      <button id="fullscreen-btn" type="button" class="fullscreen-btn" aria-pressed="false">Enter Fullscreen</button>
    </div>
    
    <div class="audio-controls">
      <button id="play-btn" class="play-btn" type="button">▶</button>
      <span id="time-display" class="time-display">0:00 / 0:00</span>
      <div class="progress-container">
        <div id="progress-bar" class="progress-bar"></div>
      </div>
      <button id="volume-btn" class="volume-btn" type="button">🔊</button>
      <button id="menu-btn" class="menu-btn" type="button">⋮</button>
    </div>
    
    <div class="radio-hint">Click Play once to enable audio. The station switches automatically as the ISS changes region.</div>
    
    <audio id="radio-player" preload="none" style="display: none;"></audio>
  </div>
  <script>
    let particles = [];
    const numParticles = 50;
    let continentPoints = [];
    // Store original geographic data for particles to enable proper repositioning on resize
    let particleGeoData = [];
    let issGeoData = { lat: 0, lon: 0 }; // Current ISS geographic coordinates
    
    // Radio globals
    let radioPlayer;
    let stationLabel;
    let fullscreenBtn;
    let playBtn;
    let timeDisplay;
    let progressBar;
    let volumeBtn;
    let menuBtn;
    let currentRegion = null;
    let isPlaying = false;
    const regionStations = {
      'Ocean': { name: 'SomaFM Mission Control', url: 'https://ice2.somafm.com/missioncontrol-128-mp3' },
      'North America': { name: 'KEXP 90.3 Seattle', url: 'https://kexp.streamguys1.com/kexp128.mp3' },
      'South America': { name: 'Radio Paradise World', url: 'https://stream.radioparadise.com/world-128' },
      'Europe': { name: 'Radio Swiss Pop', url: 'https://stream.srg-ssr.ch/m/rsp/mp3_128' },
      'Africa': { name: 'RFI Monde', url: 'https://rfimonde64k.ice.infomaniak.ch/rfimonde-64.mp3' },
      'Asia': { name: 'SomaFM Groove Salad', url: 'https://ice2.somafm.com/groovesalad-128-mp3' },
      'Oceania': { name: 'SomaFM Space Station Soma', url: 'https://ice2.somafm.com/spacestation-128-mp3' }
    };

    function getRegion(lat, lon) {
      // Rough continent bounding boxes; fall back to Ocean
      if (lat >= 10 && lat <= 85 && lon >= -168 && lon <= -52) return 'North America';
      if (lat >= -56 && lat <= 12 && lon >= -82 && lon <= -34) return 'South America';
      if (lat >= 36 && lat <= 72 && lon >= -10 && lon <= 40) return 'Europe';
      if (lat >= -35 && lat <= 37 && lon >= -18 && lon <= 51) return 'Africa';
      if (lat >= 5 && lat <= 77 && lon >= 26 && lon <= 180) return 'Asia';
      if (lat >= -50 && lat <= -10 && lon >= 112 && lon <= 154) return 'Oceania';
      return 'Ocean';
    }

    function setStationForRegion(region) {
      const station = regionStations[region] || regionStations['Ocean'];
      if (!radioPlayer || !station) return;
      const wasPlaying = radioPlayer && !radioPlayer.paused && !radioPlayer.ended;
      const newSrc = station.url;
      const currentSrc = radioPlayer.currentSrc || radioPlayer.src;
      const isDifferent = !currentSrc || !currentSrc.includes(newSrc);
      // Update label regardless
      stationLabel.textContent = `${station.name} — ${region}`;
      if (!isDifferent) return;
      radioPlayer.src = newSrc;
      radioPlayer.dataset.station = station.name;
      if (wasPlaying) {
        radioPlayer.play().catch(() => {
          /* Autoplay blocked or user paused */
          isPlaying = false;
          if (playBtn) playBtn.textContent = '▶';
        });
      }
    }

    function updateRadioForLocation(lat, lon) {
      const region = getRegion(lat, lon);
      if (region !== currentRegion) {
        currentRegion = region;
        setStationForRegion(region);
      }
    }

    // Simulation mode (enabled via ?debug=1)
    let simulateMode = false;
    let simIndex = 0;
    const simTrack = [
      // Ocean (mid-Pacific)
      { lat: 10, lon: -150 },
      // North America (central US)
      { lat: 39, lon: -98 },
      // Europe (Berlin)
      { lat: 52.52, lon: 13.405 },
      // Africa (Nigeria)
      { lat: 9.076, lon: 7.398 },
      // Asia (Tokyo)
      { lat: 35.676, lon: 139.65 },
      // Oceania (Sydney)
      { lat: -33.8688, lon: 151.2093 },
      // South America (São Paulo)
      { lat: -23.55, lon: -46.633 },
      // Back to Ocean (mid-Atlantic)
      { lat: 0, lon: -30 }
    ];

    // Convert lat/lon to screen coordinates
    function latLonToXY(lat, lon) {
      let x = map(lon, -180, 180, 0, width);
      let y = map(lat, 90, -90, 0, height);
      return {x: x, y: y};
    }

    // Convert screen coordinates back to lat/lon (for reverse calculation)
    function xyToLatLon(x, y) {
      let lon = map(x, 0, width, -180, 180);
      let lat = map(y, 0, height, 90, -90);
      return {lat: lat, lon: lon};
    }

    // Reposition all particles based on their stored geographic data
    function repositionParticlesAfterResize() {
      // Regenerate continent points with new canvas dimensions
      generateContinentPoints();
      
      // Reposition continent-based particles
      for (let i = 0; i < particles.length - 1; i++) { // All particles except ISS
        let particle = particles[i];
        let geoData = particleGeoData[i];
        
        if (geoData) {
          // Convert geographic coordinates back to new screen coordinates
          let newPos = latLonToXY(geoData.lat, geoData.lon);
          particle.pos.set(newPos.x, newPos.y);
          particle.originalPos.set(newPos.x, newPos.y);
          
          // If particle was resetting, maintain reset state but update positions
          if (particle.isResetting) {
            // The reset animation will continue from the new positions
            continue;
          }
        }
      }
      
      // Reposition ISS particle
      let issParticle = particles[particles.length - 1]; // ISS is last particle
      if (issParticle && issParticle.isIss) {
        let issPos = latLonToXY(issGeoData.lat, issGeoData.lon);
        issParticle.pos.set(issPos.x, issPos.y);
        issParticle.target.set(issPos.x, issPos.y);
      }
    }

    function setup() {
      createCanvas(windowWidth, windowHeight);
      // Wire radio UI
      radioPlayer = document.getElementById('radio-player');
      stationLabel = document.getElementById('station-label');
      fullscreenBtn = document.getElementById('fullscreen-btn');
      playBtn = document.getElementById('play-btn');
      timeDisplay = document.getElementById('time-display');
      progressBar = document.getElementById('progress-bar');
      volumeBtn = document.getElementById('volume-btn');
      menuBtn = document.getElementById('menu-btn');
      
      // Set up event listeners
      if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', toggleFullscreen);
        updateFullscreenUI();
      }
      
      if (playBtn) {
        playBtn.addEventListener('click', togglePlayback);
      }
      
      if (volumeBtn) {
        volumeBtn.addEventListener('click', toggleMute);
      }
      
      if (radioPlayer) {
        radioPlayer.addEventListener('timeupdate', updateProgress);
        radioPlayer.addEventListener('loadstart', () => {
          timeDisplay.textContent = '0:00 / 0:00';
          progressBar.style.width = '0%';
        });
        radioPlayer.addEventListener('play', () => {
          isPlaying = true;
          playBtn.textContent = '⏸';
        });
        radioPlayer.addEventListener('pause', () => {
          isPlaying = false;
          playBtn.textContent = '▶';
        });
        radioPlayer.addEventListener('ended', () => {
          isPlaying = false;
          playBtn.textContent = '▶';
        });
      }
      document.addEventListener('fullscreenchange', () => {
        updateFullscreenUI();
        // Ensure canvas matches the new viewport size
        resizeCanvas(windowWidth, windowHeight);
        repositionParticlesAfterResize();
      });
      // Safari
      document.addEventListener('webkitfullscreenchange', () => {
        updateFullscreenUI();
        resizeCanvas(windowWidth, windowHeight);
        repositionParticlesAfterResize();
      });
      // Initial default
      setStationForRegion('Ocean');
      // Determine simulation mode from URL param
      const params = new URLSearchParams(window.location.search);
      simulateMode = params.get('debug') === '1';
      
      // Generate continent outline points
      generateContinentPoints();
      
      // Create regular particles positioned on continents
      particleGeoData = []; // Reset geographic data array
      for (let i = 0; i < numParticles; i++) {
        let point = random(continentPoints);
        particles.push(new Particle(point.x, point.y, false));
        
        // Store geographic coordinates for this particle
        let geoCoords = xyToLatLon(point.x, point.y);
        particleGeoData.push(geoCoords);
      }
      
      // Create ISS particle
      let iss = new Particle(width / 2, height / 2, true);
      particles.push(iss);
      
      // Initialize ISS geographic data
      issGeoData = xyToLatLon(width / 2, height / 2);

      // Real ISS update
      function updateISSReal() {
        fetch('https://api.wheretheiss.at/v1/satellites/25544')
          .then(response => response.json())
          .then(data => {
            let lat = data.latitude;
            let lon = data.longitude;
            
            // Store ISS geographic coordinates for resize handling
            issGeoData.lat = lat;
            issGeoData.lon = lon;
            
            let x = map(lon, -180, 180, 0, width);
            let y = map(lat, 90, -90, 0, height);
            iss.target.set(x, y);
            updateRadioForLocation(lat, lon);
          })
          .catch(() => {
            // On failure, keep last position and station
          });
      }

      // Simulated ISS update
      function updateISSSim() {
        const point = simTrack[simIndex % simTrack.length];
        simIndex += 1;
        const lat = point.lat;
        const lon = point.lon;
        
        // Store ISS geographic coordinates for resize handling
        issGeoData.lat = lat;
        issGeoData.lon = lon;
        
        const x = map(lon, -180, 180, 0, width);
        const y = map(lat, 90, -90, 0, height);
        iss.target.set(x, y);
        updateRadioForLocation(lat, lon);
      }

      if (simulateMode) {
        updateISSSim();
        setInterval(updateISSSim, 5000);
      } else {
        updateISSReal();
        setInterval(updateISSReal, 5000);
      }
    }

    // Enhanced resize handling - repositions all particles properly
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      repositionParticlesAfterResize();
    }

    // Keyboard shortcut for fullscreen
    function keyPressed() {
      if (key === 'f' || key === 'F') {
        toggleFullscreen();
      }
    }

    // Fullscreen helpers
    function isFullscreen() {
      return !!(document.fullscreenElement || document.webkitFullscreenElement);
    }

    function updateFullscreenUI() {
      const active = isFullscreen();
      if (fullscreenBtn) {
        fullscreenBtn.textContent = active ? 'Exit Fullscreen' : 'Enter Fullscreen';
        fullscreenBtn.setAttribute('aria-pressed', active ? 'true' : 'false');
      }
    }

    function enterFullscreen() {
      const root = document.documentElement;
      if (root.requestFullscreen) return root.requestFullscreen();
      if (root.webkitRequestFullscreen) return root.webkitRequestFullscreen();
      return Promise.resolve();
    }

    function exitFullscreen() {
      if (document.exitFullscreen) return document.exitFullscreen();
      if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
      return Promise.resolve();
    }

    function toggleFullscreen() {
      if (isFullscreen()) {
        exitFullscreen().catch(() => {});
      } else {
        enterFullscreen().catch(() => {});
      }
    }

    // Audio control functions
    function togglePlayback() {
      if (!radioPlayer) return;
      
      if (isPlaying) {
        radioPlayer.pause();
      } else {
        radioPlayer.play().catch(() => {
          console.log('Autoplay blocked - user interaction required');
        });
      }
    }
    
    function toggleMute() {
      if (!radioPlayer) return;
      
      radioPlayer.muted = !radioPlayer.muted;
      volumeBtn.textContent = radioPlayer.muted ? '🔇' : '🔊';
    }
    
    function updateProgress() {
      if (!radioPlayer || !timeDisplay || !progressBar) return;
      
      // For live streams, we'll show a simulated progress for visual feedback
      const currentTime = radioPlayer.currentTime || 0;
      const minutes = Math.floor(currentTime / 60);
      const seconds = Math.floor(currentTime % 60);
      const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      // Since most radio streams are live, we'll show current time / live
      timeDisplay.textContent = `${timeString} / Live`;
      
      // Simulate progress for live streams (cycling animation)
      if (isPlaying) {
        const progress = ((Date.now() / 1000) % 30) / 30 * 100; // 30-second cycle
        progressBar.style.width = `${progress}%`;
      }
    }

    function generateContinentPoints() {
      continentPoints = [];
      
      // North America outline (simplified)
      let northAmerica = [
        [-60, -141], [-45, -141], [-45, -52], [-25, -80], [-25, -95], 
        [-30, -117], [-48, -125], [-60, -141]
      ];
      
      // South America outline (simplified)
      let southAmerica = [
        [12, -81], [12, -34], [-20, -34], [-35, -58], [-55, -68], 
        [-22, -81], [12, -81]
      ];
      
      // Europe outline (simplified)  
      let europe = [
        [71, -10], [71, 40], [36, 40], [36, -10], [71, -10]
      ];
      
      // Africa outline (simplified)
      let africa = [
        [37, -18], [37, 51], [-35, 51], [-35, 15], [-22, -18], [37, -18]
      ];
      
      // Asia outline (simplified)
      let asia = [
        [77, 26], [77, 180], [10, 180], [10, 60], [40, 26], [77, 26]
      ];
      
      // Australia outline (simplified)
      let australia = [
        [-10, 113], [-10, 154], [-44, 154], [-44, 113], [-10, 113]
      ];
      
      let continents = [northAmerica, southAmerica, europe, africa, asia, australia];
      
      // Generate points along continent outlines
      for (let continent of continents) {
        for (let i = 0; i < continent.length - 1; i++) {
          let start = latLonToXY(continent[i][0], continent[i][1]);
          let end = latLonToXY(continent[i + 1][0], continent[i + 1][1]);
          
          // Generate points along the line between start and end
          let steps = 10;
          for (let j = 0; j <= steps; j++) {
            let t = j / steps;
            let x = lerp(start.x, end.x, t);
            let y = lerp(start.y, end.y, t);
            continentPoints.push({x: x, y: y});
          }
        }
      }
      
      // Add some inland points for more realistic distribution
      for (let i = 0; i < continentPoints.length; i += 3) {
        let point = continentPoints[i];
        let offsetX = random(-50, 50);
        let offsetY = random(-50, 50);
        continentPoints.push({
          x: constrain(point.x + offsetX, 0, width),
          y: constrain(point.y + offsetY, 0, height)
        });
      }
    }

    function draw() {
      background(0);
      
      // Optional: Draw continent outline points as tiny dots (press 'm' to toggle)
      if (keyIsPressed && key === 'm') {
        stroke(50);
        strokeWeight(1);
        for (let point of continentPoints) {
          point(point.x, point.y);
        }
      }

      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          particles[i].collides(particles[j]);
        }
      }

      for (let particle of particles) {
        particle.update();
        particle.show();
      }
    }

    class Particle {
      constructor(x, y, isIss) {
        this.pos = createVector(x, y);
        this.originalPos = createVector(x, y); // Store original continent position
        this.isIss = isIss;
        this.isMoving = isIss; // Only ISS moves initially
        this.vel = createVector(0, 0);
        this.isResetting = false; // Track if particle is resetting to original position
        this.resetProgress = 0; // Progress of reset animation (0-1)
        this.baseRadius = this.isIss ? 40 : random(10, 30); // Store base radius for size animation
        if (this.isIss) {
          this.target = createVector(x, y);
          this.vel = p5.Vector.random2D().mult(random(1, 3));
        }
        this.r = this.baseRadius;
        this.m = this.r * 0.1;
        this.color = this.isIss ? color(255, 0, 0) : color(random(255), random(255), random(255));
      }

      collides(other) {
        let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);
        let minDist = this.r + other.r;
        
        if (d < minDist && d > 0) {
          // Special handling for ISS collisions - trigger bubble reset effect
          if ((this.isIss && !other.isIss && !other.isResetting) || 
              (!this.isIss && other.isIss && !this.isResetting)) {
            let regularParticle = this.isIss ? other : this;
            // Start the bubble reset animation
            regularParticle.startReset();
            return; // Skip normal collision physics for ISS collisions
          }
          
          // Normal collision physics for non-ISS particle interactions
          if (!this.isIss && !other.isIss) {
            // If one of the colliding particles is moving, the other one starts moving too.
            if (this.isMoving || other.isMoving) {
              this.isMoving = true;
              other.isMoving = true;
            }

            // Separate overlapping particles smoothly
            let overlap = minDist - d;
            let separationX = (other.pos.x - this.pos.x) / d * overlap * 0.5;
            let separationY = (other.pos.y - this.pos.y) / d * overlap * 0.5;
            
            this.pos.x -= separationX;
            this.pos.y -= separationY;
            other.pos.x += separationX;
            other.pos.y += separationY;

            // Calculate realistic elastic collision using conservation of momentum
            let dx = other.pos.x - this.pos.x;
            let dy = other.pos.y - this.pos.y;
            let distance = sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
              // Normalize collision vector
              dx /= distance;
              dy /= distance;
              
              // Relative velocity in collision normal direction
              let relativeVelX = other.vel.x - this.vel.x;
              let relativeVelY = other.vel.y - this.vel.y;
              let speed = relativeVelX * dx + relativeVelY * dy;
              
              // Do not resolve if velocities are separating
              if (speed > 0) return;
              
              // Collision impulse with damping for smoothness
              let restitution = 0.8; // Bouncy but not perfectly elastic
              let impulse = 2 * speed * restitution / (this.m + other.m);
              
              this.vel.x += impulse * other.m * dx;
              this.vel.y += impulse * other.m * dy;
              other.vel.x -= impulse * this.m * dx;
              other.vel.y -= impulse * this.m * dy;
            }
          }
        }
      }

      startReset() {
        if (!this.isIss && !this.isResetting) {
          this.isResetting = true;
          this.resetProgress = 0;
          this.isMoving = false; // Stop normal movement
          this.vel.mult(0); // Stop velocity
        }
      }

      update() {
        if (this.isIss) {
          let desired = p5.Vector.sub(this.target, this.pos);
          desired.setMag(2);
          let steer = p5.Vector.sub(desired, this.vel);
          steer.limit(0.1);
          this.vel.add(steer);
        } else if (this.isResetting) {
          // Handle bubble reset animation
          this.resetProgress += 0.025; // Slightly faster animation speed
          
          // Smooth easing function (ease-out cubic) for natural water movement
          let easeProgress = 1 - Math.pow(1 - this.resetProgress, 3);
          
          // Interpolate position back to original with water-like flow
          let lerpAmount = map(easeProgress, 0, 1, 0.05, 0.15); // Accelerating return
          this.pos.x = lerp(this.pos.x, this.originalPos.x, lerpAmount);
          this.pos.y = lerp(this.pos.y, this.originalPos.y, lerpAmount);
          
          // Create soap bubble effect with gentle pulsing
          let pulsePhase = this.resetProgress * Math.PI * 3; // Fewer, smoother pulses
          let sizeMultiplier = 1 + sin(pulsePhase) * 0.2 * (1 - easeProgress * 0.5); // Gentler pulsing that fades
          this.r = this.baseRadius * sizeMultiplier;
          
          // Complete reset when close enough to original position or animation complete
          let distanceToOriginal = dist(this.pos.x, this.pos.y, this.originalPos.x, this.originalPos.y);
          if (this.resetProgress >= 1 || distanceToOriginal < 3) {
            this.pos.set(this.originalPos);
            this.isResetting = false;
            this.resetProgress = 0;
            this.r = this.baseRadius; // Reset to normal size
          }
        } else if (this.isMoving) {
          // Add subtle attraction to nearest continent point for non-ISS particles
          let closestPoint = this.findClosestContinentPoint();
          if (closestPoint) {
            let distance = dist(this.pos.x, this.pos.y, closestPoint.x, closestPoint.y);
            if (distance > 100) { // Only apply attraction when far from continents
              let attract = p5.Vector.sub(createVector(closestPoint.x, closestPoint.y), this.pos);
              attract.setMag(0.02); // Very gentle attraction
              this.vel.add(attract);
            }
          }
        }

        if (this.isMoving && !this.isResetting) {
            this.pos.add(this.vel);

            // Bounce off edges only for moving non-ISS particles
            if (!this.isIss) {
              if (this.pos.x < this.r || this.pos.x > width - this.r) {
                this.vel.x *= -1;
                this.pos.x = constrain(this.pos.x, this.r, width - this.r);
              }
              if (this.pos.y < this.r || this.pos.y > height - this.r) {
                this.vel.y *= -1;
                this.pos.y = constrain(this.pos.y, this.r, height - this.r);
              }
            }
        }
      }

      findClosestContinentPoint() {
        if (continentPoints.length === 0) return null;
        
        let closest = continentPoints[0];
        let minDist = dist(this.pos.x, this.pos.y, closest.x, closest.y);
        
        for (let point of continentPoints) {
          let d = dist(this.pos.x, this.pos.y, point.x, point.y);
          if (d < minDist) {
            minDist = d;
            closest = point;
          }
        }
        
        return closest;
      }

      show() {
        noStroke();
        
        if (this.isResetting) {
          // Create water/soap bubble effect with dynamic transparency
          let fadeInOut = sin(this.resetProgress * Math.PI); // Fade in then out
          let alpha = map(fadeInOut, 0, 1, 150, 220); // More subtle transparency range
          
          // Outer bubble rim effect - more pronounced during reset
          stroke(red(this.color), green(this.color), blue(this.color), alpha * 0.6);
          strokeWeight(map(this.resetProgress, 0, 1, 3, 1)); // Thicker rim at start
          noFill();
          ellipse(this.pos.x, this.pos.y, this.r * 2 + 6);
          
          // Main bubble body with gradient-like effect
          noStroke();
          fill(red(this.color), green(this.color), blue(this.color), alpha);
          ellipse(this.pos.x, this.pos.y, this.r * 2);
          
          // Inner highlight for realistic soap bubble shimmer
          let highlightAlpha = alpha * 0.4;
          fill(255, 255, 255, highlightAlpha);
          ellipse(this.pos.x - this.r * 0.2, this.pos.y - this.r * 0.2, this.r * 0.4);
          
          // Secondary smaller highlight for more realism
          fill(255, 255, 255, highlightAlpha * 0.7);
          ellipse(this.pos.x + this.r * 0.3, this.pos.y + this.r * 0.1, this.r * 0.2);
        } else if (this.isIss) {
          // Heartbeat visual for ISS (double-beat pulse)
          const periodMs = 1100;
          const t = (millis() % periodMs) / periodMs;
          const pulse1 = Math.exp(-Math.pow((t - 0.06) / 0.06, 2));
          const pulse2 = Math.exp(-Math.pow((t - 0.26) / 0.06, 2));
          const amp = pulse1 + 0.75 * pulse2;
          const drawR = this.baseRadius * (1 + 0.22 * amp);

          // Outer glow rings
          const baseAlpha = 180;
          noFill();
          stroke(255, 70, 70, baseAlpha * 0.35 * (0.6 + 0.4 * amp));
          strokeWeight(3);
          ellipse(this.pos.x, this.pos.y, drawR * 2.6);
          stroke(255, 70, 70, baseAlpha * 0.25 * (0.6 + 0.4 * amp));
          strokeWeight(6);
          ellipse(this.pos.x, this.pos.y, drawR * 3.2);

          // Core
          noStroke();
          fill(red(this.color), green(this.color), blue(this.color), 220);
          ellipse(this.pos.x, this.pos.y, drawR * 2);
        } else {
          // Normal particle rendering
          fill(this.color);
          ellipse(this.pos.x, this.pos.y, this.r * 2);
        }
      }
    }
  </script>
</body>
</html>
