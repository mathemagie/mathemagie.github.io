<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lampe √† Lave - WebGL Shaders</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }
        
        canvas {
            display: block;
            cursor: none;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: #fff;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: opacity 0.3s;
            max-width: 280px;
        }
        
        #controls:hover {
            opacity: 1;
        }
        
        #controls h3 {
            margin-bottom: 10px;
            color: #ff6b6b;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }
        
        .control-group {
            margin: 10px 0;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        .color-input {
            width: 50px;
            height: 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            vertical-align: middle;
            margin-left: 10px;
        }
        
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 11px;
        }
    </style>
</head>
<body>
    <canvas id="lavaCanvas"></canvas>
    
    <div id="controls">
        <h3>üî• Param√®tres Lampe √† Lave</h3>
        
        <div class="control-group">
            <label>Nombre de bulles: <span id="blobCountValue">3</span></label>
            <input type="range" id="blobCount" min="3" max="20" value="3" step="1">
        </div>
        
        <div class="control-group">
            <label>Vitesse: <span id="speedValue">1.0</span></label>
            <input type="range" id="speed" min="0.1" max="3.0" value="1.0" step="0.1">
        </div>
        
        <div class="control-group">
            <label>Viscosit√©: <span id="viscosityValue">0.5</span></label>
            <input type="range" id="viscosity" min="0.1" max="1.0" value="0.5" step="0.05">
        </div>
        
        <div class="control-group">
            <label>Taille des bulles: <span id="blobSizeValue">0.05</span></label>
            <input type="range" id="blobSize" min="0.05" max="0.3" value="0.05" step="0.01">
        </div>
        
        <div class="control-group">
            <label>Couleur bulles: 
                <input type="color" id="blobColor" class="color-input" value="#ff4466">
            </label>
        </div>
        
        <div class="control-group">
            <label>Couleur liquide: 
                <input type="color" id="liquidColor" class="color-input" value="#1a0033">
            </label>
        </div>
        
        <div class="control-group">
            <label>Intensit√© lumi√®re: <span id="lightIntensityValue">2.0</span></label>
            <input type="range" id="lightIntensity" min="0.5" max="4.0" value="2.0" step="0.1">
        </div>
    </div>
    
    <div id="info">
        Clic pour masquer/afficher les contr√¥les | FPS: <span id="fps">60</span>
    </div>

    <script>
        // V√©rification du param√®tre debug dans l'URL
        function getUrlParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }
        
        // Afficher les contr√¥les uniquement si debug=1 est dans l'URL
        const isDebugMode = getUrlParameter('debug') === '1';
        if (!isDebugMode) {
            document.getElementById('controls').style.display = 'none';
            document.getElementById('info').style.display = 'none';
        }
        
        // Configuration WebGL et contexte
        const canvas = document.getElementById('lavaCanvas');
        const gl = canvas.getContext('webgl2', {
            antialias: true,
            powerPreference: 'high-performance'
        });
        
        if (!gl) {
            alert('WebGL 2 n\'est pas support√© par votre navigateur');
        }
        
        // Variables globales
        let shaderProgram;
        let vertexBuffer;
        let time = 0;
        let mouseX = 0.5;
        let mouseY = 0.5;
        let frameCount = 0;
        let lastTime = 0;
        let controlsVisible = true;
        
        // Param√®tres ajustables
        const params = {
            blobCount: 3,
            speed: 1.0,
            viscosity: 0.5,
            blobSize: 0.05,
            blobColor: [1.0, 0.267, 0.4],
            liquidColor: [0.102, 0.0, 0.2],
            lightIntensity: 2.0
        };
        
        // Vertex Shader - G√©om√©trie simple plein √©cran
        const vertexShaderSource = `#version 300 es
            in vec2 position;
            out vec2 fragCoord;
            
            void main() {
                fragCoord = position * 0.5 + 0.5;
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;
        
        // Fragment Shader - Simulation de lampe √† lave avec metaballs
        const fragmentShaderSource = `#version 300 es
            precision highp float;
            
            in vec2 fragCoord;
            out vec4 fragColor;
            
            uniform float time;
            uniform vec2 resolution;
            uniform vec2 mouse;
            uniform int blobCount;
            uniform float speed;
            uniform float viscosity;
            uniform float blobSize;
            uniform vec3 blobColor;
            uniform vec3 liquidColor;
            uniform float lightIntensity;
            
            // Fonction de bruit simplex pour mouvements organiques
            vec3 mod289(vec3 x) {
                return x - floor(x * (1.0 / 289.0)) * 289.0;
            }
            
            vec2 mod289(vec2 x) {
                return x - floor(x * (1.0 / 289.0)) * 289.0;
            }
            
            vec3 permute(vec3 x) {
                return mod289(((x*34.0)+1.0)*x);
            }
            
            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187,
                                    0.366025403784439,
                                    -0.577350269189626,
                                    0.024390243902439);
                vec2 i = floor(v + dot(v, C.yy));
                vec2 x0 = v - i + dot(i, C.xx);
                vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod289(i);
                vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
                    + i.x + vec3(0.0, i1.x, 1.0));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                m = m*m;
                m = m*m;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
                vec3 g;
                g.x = a0.x * x0.x + h.x * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }
            
            // Fonction metaball avec distance sign√©e
            float metaball(vec2 p, vec2 center, float radius) {
                float d = length(p - center);
                return radius / (d * d + 0.001);
            }
            
            // Fonction pour cr√©er des mouvements de convection
            vec2 convectionFlow(vec2 pos, float t) {
                float noiseX = snoise(vec2(pos.y * 3.0, t * 0.3)) * 0.1;
                float noiseY = snoise(vec2(pos.x * 3.0, t * 0.2)) * 0.15;
                
                // Convection thermique: mont√©e au centre, descente sur les bords
                float centerDist = length(pos - vec2(0.5, 0.5));
                float convection = (0.5 - centerDist) * 0.3;
                
                return vec2(noiseX, noiseY + convection);
            }
            
            // Fonction principale de rendu
            void main() {
                vec2 uv = fragCoord;
                vec2 aspect = vec2(resolution.x / resolution.y, 1.0);
                vec2 p = (uv - 0.5) * aspect + 0.5;
                
                // Temps ajust√© par la vitesse
                float t = time * speed;
                
                // Accumulation des metaballs
                float metaballValue = 0.0;
                float glowValue = 0.0;
                
                for(int i = 0; i < 20; i++) {
                    if(i >= blobCount) break;
                    
                    float fi = float(i);
                    float phase = fi * 1.618; // Nombre d'or pour distribution
                    
                    // Position de base avec mouvement sinuso√Ødal
                    vec2 basePos = vec2(
                        0.5 + sin(t * 0.7 + phase) * 0.3,
                        0.5 + cos(t * 0.5 + phase * 1.3) * 0.35
                    );
                    
                    // Ajout de mouvements de convection
                    basePos += convectionFlow(basePos, t + fi) * viscosity;
                    
                    // Perturbation par bruit
                    basePos.x += snoise(vec2(t * 0.3, fi * 10.0)) * 0.1 * viscosity;
                    basePos.y += snoise(vec2(t * 0.4, fi * 20.0)) * 0.15 * viscosity;
                    
                    // Influence de la souris
                    vec2 mouseInfluence = (mouse - 0.5) * 0.2;
                    basePos += mouseInfluence * (1.0 - length(basePos - mouse)) * 0.5;
                    
                    // Taille variable des bulles
                    float size = blobSize * (1.0 + sin(t * 1.5 + fi * 2.0) * 0.3);
                    
                    // Accumulation des metaballs
                    float mb = metaball(p, basePos, size);
                    metaballValue += mb;
                    
                    // Glow effect
                    float glow = exp(-length(p - basePos) * 5.0 / size) * 0.5;
                    glowValue += glow;
                }
                
                // Seuil pour cr√©er des formes lisses
                float threshold = 1.2;
                float smoothness = 0.1;
                float blob = smoothstep(threshold - smoothness, threshold + smoothness, metaballValue);
                
                // Effets de bord pour simuler la tension de surface
                float edgeFactor = 1.0 - smoothstep(threshold, threshold + 0.5, metaballValue);
                
                // Gradient radial pour l'√©clairage de base
                vec2 lampCenter = vec2(0.5, 0.9);
                float baseLightDist = length(uv - lampCenter);
                float baseLight = 1.0 - baseLightDist * 0.7;
                baseLight = pow(baseLight, 2.0) * lightIntensity;
                
                // Couleurs avec effets de transparence
                vec3 blobCol = blobColor * (1.0 + edgeFactor * 0.5);
                vec3 liquidCol = liquidColor;
                
                // M√©lange des couleurs avec effets de r√©fraction
                vec3 color = mix(liquidCol, blobCol, blob);
                
                // Ajout du glow
                color += glowValue * blobColor * 0.3;
                
                // Application de l'√©clairage
                color *= baseLight;
                
                // Effets de r√©flexion et highlights
                float highlight = pow(max(0.0, blob * edgeFactor), 3.0) * 2.0;
                color += vec3(highlight) * lightIntensity * 0.5;
                
                // Aberration chromatique l√©g√®re sur les bords
                float chromatic = edgeFactor * blob * 0.02;
                color.r += chromatic;
                color.b -= chromatic;
                
                // Vignette effect
                float vignette = 1.0 - length(uv - 0.5) * 0.5;
                color *= vignette;
                
                // Correction gamma et saturation
                color = pow(color, vec3(0.9));
                float luminance = dot(color, vec3(0.299, 0.587, 0.114));
                color = mix(vec3(luminance), color, 1.2);
                
                fragColor = vec4(color, 1.0);
            }
        `;
        
        // Compilation des shaders
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Erreur de compilation shader:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        // Cr√©ation du programme shader
        function createShaderProgram() {
            const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Erreur de liaison du programme:', gl.getProgramInfoLog(program));
                return null;
            }
            
            return program;
        }
        
        // Initialisation
        function init() {
            // Cr√©ation du programme shader
            shaderProgram = createShaderProgram();
            gl.useProgram(shaderProgram);
            
            // Cr√©ation du buffer de vertices (quad plein √©cran)
            const vertices = new Float32Array([
                -1.0, -1.0,
                1.0, -1.0,
                -1.0, 1.0,
                1.0, 1.0
            ]);
            
            vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            // Configuration des attributs
            const positionLocation = gl.getAttribLocation(shaderProgram, 'position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            
            // Redimensionnement initial
            resizeCanvas();
            
            // Event listeners
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousemove', handleMouseMove);
            
            // Ajouter le gestionnaire de clic uniquement en mode debug
            if (isDebugMode) {
                canvas.addEventListener('click', toggleControls);
            }
            
            // Contr√¥les UI
            setupControls();
        }
        
        // Redimensionnement du canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        // Gestion de la souris
        function handleMouseMove(e) {
            mouseX = e.clientX / canvas.width;
            mouseY = 1.0 - (e.clientY / canvas.height);
        }
        
        // Toggle des contr√¥les (uniquement en mode debug)
        function toggleControls() {
            if (!isDebugMode) return;
            controlsVisible = !controlsVisible;
            document.getElementById('controls').style.opacity = controlsVisible ? '1' : '0.1';
        }
        
        // Configuration des contr√¥les UI
        function setupControls() {
            // Nombre de bulles
            const blobCountSlider = document.getElementById('blobCount');
            blobCountSlider.addEventListener('input', (e) => {
                params.blobCount = parseInt(e.target.value);
                document.getElementById('blobCountValue').textContent = e.target.value;
            });
            
            // Vitesse
            const speedSlider = document.getElementById('speed');
            speedSlider.addEventListener('input', (e) => {
                params.speed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = e.target.value;
            });
            
            // Viscosit√©
            const viscositySlider = document.getElementById('viscosity');
            viscositySlider.addEventListener('input', (e) => {
                params.viscosity = parseFloat(e.target.value);
                document.getElementById('viscosityValue').textContent = e.target.value;
            });
            
            // Taille des bulles
            const blobSizeSlider = document.getElementById('blobSize');
            blobSizeSlider.addEventListener('input', (e) => {
                params.blobSize = parseFloat(e.target.value);
                document.getElementById('blobSizeValue').textContent = e.target.value;
            });
            
            // Couleur des bulles
            const blobColorPicker = document.getElementById('blobColor');
            blobColorPicker.addEventListener('input', (e) => {
                const hex = e.target.value;
                params.blobColor = hexToRgb(hex);
            });
            
            // Couleur du liquide
            const liquidColorPicker = document.getElementById('liquidColor');
            liquidColorPicker.addEventListener('input', (e) => {
                const hex = e.target.value;
                params.liquidColor = hexToRgb(hex);
            });
            
            // Intensit√© lumineuse
            const lightIntensitySlider = document.getElementById('lightIntensity');
            lightIntensitySlider.addEventListener('input', (e) => {
                params.lightIntensity = parseFloat(e.target.value);
                document.getElementById('lightIntensityValue').textContent = e.target.value;
            });
        }
        
        // Conversion hexad√©cimal vers RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16) / 255,
                parseInt(result[2], 16) / 255,
                parseInt(result[3], 16) / 255
            ] : [1, 1, 1];
        }
        
        // Boucle d'animation
        function animate(currentTime) {
            // Calcul du FPS
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            // Mise √† jour du temps
            time = currentTime * 0.001;
            
            // Mise √† jour des uniforms
            const timeLocation = gl.getUniformLocation(shaderProgram, 'time');
            gl.uniform1f(timeLocation, time);
            
            const resolutionLocation = gl.getUniformLocation(shaderProgram, 'resolution');
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            
            const mouseLocation = gl.getUniformLocation(shaderProgram, 'mouse');
            gl.uniform2f(mouseLocation, mouseX, mouseY);
            
            const blobCountLocation = gl.getUniformLocation(shaderProgram, 'blobCount');
            gl.uniform1i(blobCountLocation, params.blobCount);
            
            const speedLocation = gl.getUniformLocation(shaderProgram, 'speed');
            gl.uniform1f(speedLocation, params.speed);
            
            const viscosityLocation = gl.getUniformLocation(shaderProgram, 'viscosity');
            gl.uniform1f(viscosityLocation, params.viscosity);
            
            const blobSizeLocation = gl.getUniformLocation(shaderProgram, 'blobSize');
            gl.uniform1f(blobSizeLocation, params.blobSize);
            
            const blobColorLocation = gl.getUniformLocation(shaderProgram, 'blobColor');
            gl.uniform3fv(blobColorLocation, params.blobColor);
            
            const liquidColorLocation = gl.getUniformLocation(shaderProgram, 'liquidColor');
            gl.uniform3fv(liquidColorLocation, params.liquidColor);
            
            const lightIntensityLocation = gl.getUniformLocation(shaderProgram, 'lightIntensity');
            gl.uniform1f(lightIntensityLocation, params.lightIntensity);
            
            // Rendu
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(animate);
        }
        
        // Lancement de l'application
        init();
        animate(0);
    </script>
</body>
</html>