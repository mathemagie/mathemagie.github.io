<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Specimen LV-47 | Thermal Convection Analysis</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=IBM+Plex+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Color System - Vintage NASA Warmth */
            --amber-glow: #FF4500;
            --deep-teal: #2A0505;
            --warm-copper: #CC7A4A;
            --cream-white: #F5E6D3;
            --charcoal: #1A1A1A;
            --neon-orange: #FF6B35;

            /* Typography */
            --font-display: 'Orbitron', sans-serif;
            --font-mono: 'IBM Plex Mono', monospace;

            /* Spacing */
            --space-xs: 0.5rem;
            --space-sm: 1rem;
            --space-md: 1.5rem;
            --space-lg: 2rem;
            --space-xl: 3rem;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: radial-gradient(circle at 50% 80%,
                rgba(42, 5, 5, 0.3) 0%,
                rgba(26, 26, 26, 0.8) 50%,
                var(--charcoal) 100%
            );
            font-family: var(--font-mono);
            position: relative;
        }

        /* Film grain texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            z-index: 1;
            pointer-events: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><filter id="noise"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" /></filter><rect width="200" height="200" filter="url(%23noise)" opacity="0.5"/></svg>');
            animation: grain 8s steps(10) infinite;
        }

        @keyframes grain {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-5%, -10%); }
            20% { transform: translate(-15%, 5%); }
            30% { transform: translate(7%, -25%); }
            40% { transform: translate(-5%, 25%); }
            50% { transform: translate(-15%, 10%); }
            60% { transform: translate(15%, 0%); }
            70% { transform: translate(0%, 15%); }
            80% { transform: translate(3%, 35%); }
            90% { transform: translate(-10%, 10%); }
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            animation: fadeIn 1s ease-out forwards;
            animation-delay: 0.2s;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        /* Control Panel */
        #controls {
            position: fixed;
            top: 2rem;
            right: 2rem;
            width: 320px;
            background: rgba(10, 20, 25, 0.75);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 184, 77, 0.2);
            border-radius: 12px;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 184, 77, 0.1),
                0 0 40px rgba(255, 184, 77, 0.05);
            z-index: 100;
        }

        #controls h3 {
            font-family: var(--font-display);
            font-weight: 700;
            font-size: 0.75rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: var(--amber-glow);
            text-shadow: 0 0 20px rgba(255, 184, 77, 0.5);
            padding: var(--space-md) var(--space-md) var(--space-sm);
            border-bottom: 1px solid rgba(255, 184, 77, 0.15);
            margin-bottom: var(--space-md);
        }

        #controls h3 .specimen-id {
            display: block;
            font-size: 1.1rem;
            font-weight: 900;
            margin-top: 0.25rem;
            color: var(--cream-white);
        }

        .control-group {
            padding: 0 var(--space-md) var(--space-md);
        }

        .control-group label {
            display: block;
            font-family: var(--font-mono);
            font-size: 0.7rem;
            font-weight: 500;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            color: rgba(245, 230, 211, 0.7);
            margin-bottom: var(--space-xs);
        }

        .control-value {
            font-family: var(--font-mono);
            font-weight: 600;
            color: var(--amber-glow);
            text-shadow: 0 0 10px rgba(255, 184, 77, 0.3);
            margin-left: var(--space-xs);
        }

        /* Custom Range Inputs */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: linear-gradient(
                to right,
                rgba(255, 184, 77, 0.2) 0%,
                rgba(255, 184, 77, 0.05) 100%
            );
            border-radius: 3px;
            outline: none;
            margin: var(--space-xs) 0;
            transition: all 0.3s ease;
            position: relative;
        }

        input[type="range"]:hover {
            background: linear-gradient(
                to right,
                rgba(255, 184, 77, 0.3) 0%,
                rgba(255, 184, 77, 0.1) 100%
            );
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: radial-gradient(circle, var(--amber-glow) 0%, var(--warm-copper) 100%);
            border: 2px solid rgba(245, 230, 211, 0.3);
            border-radius: 50%;
            cursor: pointer;
            box-shadow:
                0 0 10px rgba(255, 184, 77, 0.5),
                0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease-out;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow:
                0 0 20px rgba(255, 184, 77, 0.8),
                0 4px 12px rgba(0, 0, 0, 0.4);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: radial-gradient(circle, var(--amber-glow) 0%, var(--warm-copper) 100%);
            border: 2px solid rgba(245, 230, 211, 0.3);
            border-radius: 50%;
            cursor: pointer;
            box-shadow:
                0 0 10px rgba(255, 184, 77, 0.5),
                0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease-out;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.15);
            box-shadow:
                0 0 20px rgba(255, 184, 77, 0.8),
                0 4px 12px rgba(0, 0, 0, 0.4);
        }

        /* Color Pickers */
        .color-input-wrapper {
            display: inline-block;
            position: relative;
            margin-left: var(--space-sm);
        }

        .color-input {
            -webkit-appearance: none;
            appearance: none;
            width: 50px;
            height: 32px;
            border: 2px solid rgba(255, 184, 77, 0.3);
            border-radius: 6px;
            cursor: pointer;
            background: transparent;
            transition: all 0.2s ease-out;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .color-input::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-input::-webkit-color-swatch {
            border: none;
            border-radius: 4px;
        }

        .color-input::-moz-color-swatch {
            border: none;
            border-radius: 4px;
        }

        .color-input:hover {
            transform: scale(1.05);
            border-color: rgba(255, 184, 77, 0.6);
            box-shadow:
                0 0 15px rgba(255, 184, 77, 0.3),
                0 4px 12px rgba(0, 0, 0, 0.3);
        }

        /* Info Panel */
        #info {
            position: fixed;
            bottom: 1.5rem;
            left: 1.5rem;
            font-family: var(--font-mono);
            font-size: 0.65rem;
            font-weight: 400;
            color: rgba(245, 230, 211, 0.3);
            letter-spacing: 0.05em;
            z-index: 100;
        }

        #fps {
            font-family: var(--font-mono);
            font-weight: 600;
            color: var(--amber-glow);
            text-shadow: 0 0 8px rgba(255, 184, 77, 0.4);
            letter-spacing: 0.1em;
        }

        /* Decorative corner elements */
        .corner-decoration {
            position: fixed;
            font-family: var(--font-mono);
            font-size: 0.6rem;
            color: rgba(255, 184, 77, 0.15);
            letter-spacing: 0.1em;
            z-index: 50;
        }

        .corner-decoration.top-left {
            top: 1.5rem;
            left: 1.5rem;
        }

        .corner-decoration.bottom-right {
            bottom: 1.5rem;
            right: 1.5rem;
            text-align: right;
        }

        /* Responsive */
        @media (max-width: 768px) {
            #controls {
                width: calc(100% - 2rem);
                right: 1rem;
                top: 1rem;
            }

            .corner-decoration {
                display: none;
            }
        }
    </style>
</head>
<body>
    <canvas id="lavaCanvas"></canvas>

    <!-- Decorative Corner Elements -->
    <div class="corner-decoration top-left">
        LAB-PROTO-v2.7<br>
        EST. 1972
    </div>
    <div class="corner-decoration bottom-right">
        THERMAL ANALYSIS<br>
        ACTIVE
    </div>

    <div id="controls">
        <h3>
            Thermal Control
            <span class="specimen-id">SPECIMEN LV-47</span>
        </h3>

        <div class="control-group">
            <label>Blob Count: <span class="control-value" id="blobCountValue">5</span></label>
            <input type="range" id="blobCount" min="3" max="20" value="5" step="1">
        </div>

        <div class="control-group">
            <label>Flow Speed: <span class="control-value" id="speedValue">0.7</span></label>
            <input type="range" id="speed" min="0.1" max="3.0" value="0.7" step="0.1">
        </div>

        <div class="control-group">
            <label>Viscosity: <span class="control-value" id="viscosityValue">0.3</span></label>
            <input type="range" id="viscosity" min="0.1" max="1.0" value="0.3" step="0.05">
        </div>

        <div class="control-group">
            <label>Blob Radius: <span class="control-value" id="blobSizeValue">0.05</span></label>
            <input type="range" id="blobSize" min="0.05" max="0.3" value="0.05" step="0.01">
        </div>

        <div class="control-group">
            <label>
                Blob Spectrum:
                <span class="color-input-wrapper">
                    <input type="color" id="blobColor" class="color-input" value="#FF4500">
                </span>
            </label>
        </div>

        <div class="control-group">
            <label>
                Liquid Base:
                <span class="color-input-wrapper">
                    <input type="color" id="liquidColor" class="color-input" value="#2A0505">
                </span>
            </label>
        </div>

        <div class="control-group">
            <label>Light Power: <span class="control-value" id="lightIntensityValue">2.0</span></label>
            <input type="range" id="lightIntensity" min="0.5" max="4.0" value="2.0" step="0.1">
        </div>
    </div>

    <div id="info">
        Press H to toggle controls | Render Rate: <span id="fps">60</span> FPS
    </div>

    <script>
        // URL parameter check for debug mode
        function getUrlParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        const isDebugMode = getUrlParameter('debug') === '1';

        // Initialize controls visibility based on debug mode
        let initialControlsVisible = isDebugMode;
        if (!isDebugMode) {
            document.getElementById('controls').style.display = 'none';
            document.getElementById('info').style.display = 'none';
            document.querySelectorAll('.corner-decoration').forEach(el => el.style.display = 'none');
        }

        // WebGL Setup
        const canvas = document.getElementById('lavaCanvas');
        const gl = canvas.getContext('webgl2', {
            antialias: true,
            powerPreference: 'high-performance'
        });

        if (!gl) {
            alert('WebGL 2 is not supported in your browser');
        }

        // Global variables
        let shaderProgram;
        let vertexBuffer;
        let time = 0;
        let mouseX = 0.5;
        let mouseY = 0.5;
        let smoothMouseX = 0.5;
        let smoothMouseY = 0.5;
        let frameCount = 0;
        let lastTime = 0;
        let lastFrameTime = 0;
        let controlsVisible = isDebugMode;

        // Cached uniform locations for performance
        let uniforms = {};

        // Velocity tracking for smooth damping
        let velocities = {
            speed: 0,
            viscosity: 0,
            blobSize: 0,
            lightIntensity: 0,
            blobColor: [0, 0, 0],
            liquidColor: [0, 0, 0],
            mouseX: 0,
            mouseY: 0
        };

        // Smooth interpolation targets
        let targetParams = {
            blobCount: 5,
            speed: 0.7,
            viscosity: 0.3,
            blobSize: 0.05,
            blobColor: [1.0, 0.27, 0.0],  // Red-Orange
            liquidColor: [0.165, 0.02, 0.02],  // Dark Red
            lightIntensity: 2.0
        };

        // Current interpolated params
        const params = { ...targetParams };

        // Vertex Shader
        const vertexShaderSource = `#version 300 es
            in vec2 position;
            out vec2 fragCoord;

            void main() {
                fragCoord = position * 0.5 + 0.5;
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        // Enhanced Fragment Shader with Retro-Futuristic Effects
        const fragmentShaderSource = `#version 300 es
            precision highp float;

            in vec2 fragCoord;
            out vec4 fragColor;

            uniform float time;
            uniform vec2 resolution;
            uniform vec2 mouse;
            uniform int blobCount;
            uniform float speed;
            uniform float viscosity;
            uniform float blobSize;
            uniform vec3 blobColor;
            uniform vec3 liquidColor;
            uniform float lightIntensity;

            // Multi-octave Simplex Noise for organic movement
            vec3 mod289(vec3 x) {
                return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec2 mod289(vec2 x) {
                return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec3 permute(vec3 x) {
                return mod289(((x*34.0)+1.0)*x);
            }

            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187,
                                    0.366025403784439,
                                    -0.577350269189626,
                                    0.024390243902439);
                vec2 i = floor(v + dot(v, C.yy));
                vec2 x0 = v - i + dot(i, C.xx);
                vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod289(i);
                vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
                    + i.x + vec3(0.0, i1.x, 1.0));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                m = m*m;
                m = m*m;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
                vec3 g;
                g.x = a0.x * x0.x + h.x * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }

            // Multi-octave noise for richer organic patterns
            float fbm(vec2 p) {
                float value = 0.0;
                float amplitude = 0.5;
                float frequency = 1.0;

                for(int i = 0; i < 3; i++) {
                    value += amplitude * snoise(p * frequency);
                    frequency *= 2.0;
                    amplitude *= 0.5;
                }
                return value;
            }

            // Metaball distance field
            float metaball(vec2 p, vec2 center, float radius) {
                float d = length(p - center);
                return radius / (d * d + 0.001);
            }

            // Thermal convection flow
            vec2 convectionFlow(vec2 pos, float t) {
                float noiseX = fbm(vec2(pos.y * 2.5, t * 0.25)) * 0.08;
                float noiseY = fbm(vec2(pos.x * 2.5, t * 0.18)) * 0.12;

                float centerDist = length(pos - vec2(0.5, 0.5));
                float convection = (0.5 - centerDist) * 0.25;

                return vec2(noiseX, noiseY + convection);
            }

            // Fresnel effect for edge lighting
            float fresnel(vec3 normal, vec3 viewDir, float power) {
                return pow(1.0 - max(0.0, dot(normal, viewDir)), power);
            }

            // Simplified caustics pattern
            float caustics(vec2 uv, float time) {
                vec2 p = uv * 6.0;
                float c = 0.0;

                c += sin(p.x + time * 0.3 + sin(p.y * 1.5 + time * 0.2)) * 0.5;
                c += sin(p.y + time * 0.4 + sin(p.x * 1.3 + time * 0.3)) * 0.5;
                c += sin((p.x + p.y) * 0.7 + time * 0.25) * 0.3;

                return c * 0.15 + 0.5;
            }

            void main() {
                vec2 uv = fragCoord;
                vec2 aspect = vec2(resolution.x / resolution.y, 1.0);
                vec2 p = (uv - 0.5) * aspect + 0.5;

                float t = time * speed;

                // Metaball accumulation
                float metaballValue = 0.0;
                float glowValue = 0.0;
                vec3 normalAccum = vec3(0.0);

                for(int i = 0; i < 20; i++) {
                    if(i >= blobCount) break;

                    float fi = float(i);
                    float phase = fi * 1.618033988749; // Golden ratio for natural distribution

                    // Smoother time with multiple frequencies for organic feel
                    float slowTime = t * 0.4;
                    float medTime = t * 0.65;
                    float fastTime = t * 0.9;

                    // Multi-frequency sinusoidal motion (smoother, less mechanical)
                    float xMotion = sin(medTime + phase) * 0.22
                                  + sin(slowTime * 0.7 + phase * 2.1) * 0.08
                                  + sin(fastTime * 0.5 + phase * 0.5) * 0.04;

                    float yMotion = cos(slowTime * 0.8 + phase * 1.25) * 0.26
                                  + cos(medTime * 0.6 + phase * 1.8) * 0.08
                                  + sin(fastTime * 0.4 + phase * 0.7) * 0.05;

                    vec2 basePos = vec2(0.5 + xMotion, 0.5 + yMotion);

                    // Add convection flow with smoothed influence
                    vec2 flow = convectionFlow(basePos, t + fi) * viscosity;
                    basePos += flow * smoothstep(0.0, 0.5, viscosity);

                    // Enhanced noise perturbation with smoother transitions
                    float noiseScale = 0.06 * viscosity;
                    basePos.x += fbm(vec2(t * 0.2, fi * 8.0)) * noiseScale;
                    basePos.y += fbm(vec2(t * 0.25, fi * 15.0)) * noiseScale * 1.3;

                    // Smooth mouse influence with distance falloff
                    vec2 toMouse = mouse - basePos;
                    float mouseDist = length(toMouse);
                    float mouseStrength = smoothstep(0.8, 0.0, mouseDist) * 0.15;
                    basePos += toMouse * mouseStrength;

                    // Variable blob size with smooth breathing (multiple frequencies)
                    float breathe = sin(t * 0.8 + fi * 1.8) * 0.15
                                  + sin(t * 1.3 + fi * 2.5) * 0.08;
                    float size = blobSize * (1.0 + breathe);

                    // Metaball contribution
                    float mb = metaball(p, basePos, size);
                    metaballValue += mb;

                    // Glow and depth
                    float dist = length(p - basePos);
                    float glow = exp(-dist * 4.5 / size) * 0.4;
                    glowValue += glow;

                    // Normal approximation for lighting
                    vec2 offset = p - basePos;
                    normalAccum += vec3(offset, sqrt(max(0.0, size * size - dot(offset, offset))));
                }

                normalAccum = normalize(normalAccum);

                // Smooth blob threshold - higher value = smaller, more separated blobs
                float threshold = 4.0;
                float smoothness = 0.2;
                float blob = smoothstep(threshold - smoothness, threshold + smoothness, metaballValue);

                // Edge detection
                float edgeFactor = 1.0 - smoothstep(threshold, threshold + 0.4, metaballValue);

                // Depth-based color shifting (warmer at top, cooler at bottom)
                vec3 depthBlobColor = mix(
                    blobColor * 1.15,
                    blobColor * vec3(0.95, 0.85, 0.7),
                    uv.y * 0.5
                );

                vec3 depthLiquidColor = mix(
                    liquidColor * 0.8,
                    liquidColor * 1.2,
                    uv.y * 0.7
                );

                // Enhanced lighting with Fresnel
                vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0));
                float fresnelTerm = fresnel(normalAccum, viewDir, 3.5);

                // Light source position
                vec2 lightPos = vec2(0.5, 0.85);
                float lightDist = length(uv - lightPos);
                float baseLight = 1.0 - lightDist * 0.65;
                baseLight = pow(max(0.0, baseLight), 1.8) * lightIntensity;

                // Caustics layer for atmospheric effect
                float causticsValue = caustics(uv, t * 0.5);

                // Color mixing with subsurface approximation
                vec3 subsurface = depthBlobColor * 1.3 * blob * (1.0 - edgeFactor);
                vec3 blobCol = mix(depthBlobColor, depthBlobColor * 1.4, edgeFactor * 0.6);
                blobCol += subsurface * 0.3;

                vec3 color = mix(depthLiquidColor, blobCol, blob);

                // Add caustics to liquid
                color += depthLiquidColor * causticsValue * (1.0 - blob) * 0.15;

                // Glow enhancement
                color += glowValue * depthBlobColor * 0.35;

                // Fresnel edge glow
                color += vec3(fresnelTerm) * blobColor * blob * 0.6;

                // Apply lighting
                color *= baseLight * 1.1;

                // Specular highlights
                float specular = pow(max(0.0, blob * edgeFactor), 4.0) * 2.2;
                color += vec3(specular) * vec3(1.0, 0.95, 0.85) * lightIntensity * 0.4;

                // Subtle chromatic aberration on edges
                float chromatic = edgeFactor * blob * 0.015;
                color.r += chromatic;
                color.b -= chromatic * 0.8;

                // Enhanced vignette
                float vignette = 1.0 - length(uv - 0.5) * 0.6;
                vignette = pow(vignette, 1.2);
                color *= vignette;

                // Atmospheric fog for depth
                float fog = smoothstep(0.0, 1.0, uv.y) * 0.1;
                color = mix(color, depthLiquidColor * 0.5, fog * (1.0 - blob));

                // Color grading: vintage warmth
                color = pow(color, vec3(0.88));
                float luminance = dot(color, vec3(0.299, 0.587, 0.114));
                color = mix(vec3(luminance), color, 1.25);

                // Subtle amber tint for retro feel
                color *= vec3(1.02, 0.98, 0.94);

                fragColor = vec4(color, 1.0);
            }
        `;

        // Shader compilation
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        function createShaderProgram() {
            const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return null;
            }

            return program;
        }

        // Initialization
        function init() {
            shaderProgram = createShaderProgram();
            gl.useProgram(shaderProgram);

            // Cache uniform locations for performance
            uniforms = {
                time: gl.getUniformLocation(shaderProgram, 'time'),
                resolution: gl.getUniformLocation(shaderProgram, 'resolution'),
                mouse: gl.getUniformLocation(shaderProgram, 'mouse'),
                blobCount: gl.getUniformLocation(shaderProgram, 'blobCount'),
                speed: gl.getUniformLocation(shaderProgram, 'speed'),
                viscosity: gl.getUniformLocation(shaderProgram, 'viscosity'),
                blobSize: gl.getUniformLocation(shaderProgram, 'blobSize'),
                blobColor: gl.getUniformLocation(shaderProgram, 'blobColor'),
                liquidColor: gl.getUniformLocation(shaderProgram, 'liquidColor'),
                lightIntensity: gl.getUniformLocation(shaderProgram, 'lightIntensity')
            };

            // Fullscreen quad
            const vertices = new Float32Array([
                -1.0, -1.0,
                 1.0, -1.0,
                -1.0,  1.0,
                 1.0,  1.0
            ]);

            vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(shaderProgram, 'position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            resizeCanvas();

            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('keydown', handleKeyPress);

            if (isDebugMode) {
                canvas.addEventListener('click', toggleControls);
            }

            setupControls();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        function handleMouseMove(e) {
            mouseX = e.clientX / canvas.width;
            mouseY = 1.0 - (e.clientY / canvas.height);
        }

        function handleKeyPress(e) {
            // Toggle controls with H key
            if (e.key === 'h' || e.key === 'H') {
                toggleControls();
            }
        }

        function toggleControls() {
            controlsVisible = !controlsVisible;
            const controls = document.getElementById('controls');
            const decorations = document.querySelectorAll('.corner-decoration');
            const info = document.getElementById('info');
            const display = controlsVisible ? 'block' : 'none';

            controls.style.display = display;
            info.style.display = display;
            decorations.forEach(el => el.style.display = display);
        }

        // Smooth interpolation helper
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }

        function lerpColor(start, end, t) {
            return [
                lerp(start[0], end[0], t),
                lerp(start[1], end[1], t),
                lerp(start[2], end[2], t)
            ];
        }

        // Smooth damp - physics-based smoothing (like Unity's SmoothDamp)
        // Returns { value, velocity } for continued smoothing
        function smoothDamp(current, target, velocity, smoothTime, deltaTime) {
            // Prevent division by zero
            smoothTime = Math.max(0.0001, smoothTime);
            const omega = 2.0 / smoothTime;
            const x = omega * deltaTime;
            const exp = 1.0 / (1.0 + x + 0.48 * x * x + 0.235 * x * x * x);
            const change = current - target;
            const temp = (velocity + omega * change) * deltaTime;
            const newVelocity = (velocity - omega * temp) * exp;
            let newValue = target + (change + temp) * exp;

            // Prevent overshooting
            if ((target - current > 0) === (newValue > target)) {
                newValue = target;
                return { value: newValue, velocity: 0 };
            }

            return { value: newValue, velocity: newVelocity };
        }

        // Smooth damp for color arrays
        function smoothDampColor(current, target, velocity, smoothTime, deltaTime) {
            const result = { value: [], velocity: [] };
            for (let i = 0; i < 3; i++) {
                const damped = smoothDamp(current[i], target[i], velocity[i], smoothTime, deltaTime);
                result.value[i] = damped.value;
                result.velocity[i] = damped.velocity;
            }
            return result;
        }

        // Control setup with smooth transitions
        function setupControls() {
            const blobCountSlider = document.getElementById('blobCount');
            blobCountSlider.addEventListener('input', (e) => {
                targetParams.blobCount = parseInt(e.target.value);
                document.getElementById('blobCountValue').textContent = e.target.value;
            });

            const speedSlider = document.getElementById('speed');
            speedSlider.addEventListener('input', (e) => {
                targetParams.speed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = e.target.value;
            });

            const viscositySlider = document.getElementById('viscosity');
            viscositySlider.addEventListener('input', (e) => {
                targetParams.viscosity = parseFloat(e.target.value);
                document.getElementById('viscosityValue').textContent = e.target.value;
            });

            const blobSizeSlider = document.getElementById('blobSize');
            blobSizeSlider.addEventListener('input', (e) => {
                targetParams.blobSize = parseFloat(e.target.value);
                document.getElementById('blobSizeValue').textContent = e.target.value;
            });

            const blobColorPicker = document.getElementById('blobColor');
            blobColorPicker.addEventListener('input', (e) => {
                targetParams.blobColor = hexToRgb(e.target.value);
            });

            const liquidColorPicker = document.getElementById('liquidColor');
            liquidColorPicker.addEventListener('input', (e) => {
                targetParams.liquidColor = hexToRgb(e.target.value);
            });

            const lightIntensitySlider = document.getElementById('lightIntensity');
            lightIntensitySlider.addEventListener('input', (e) => {
                targetParams.lightIntensity = parseFloat(e.target.value);
                document.getElementById('lightIntensityValue').textContent = e.target.value;
            });
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16) / 255,
                parseInt(result[2], 16) / 255,
                parseInt(result[3], 16) / 255
            ] : [1, 1, 1];
        }

        // Animation loop with smooth interpolation
        function animate(currentTime) {
            // Calculate delta time for frame-rate independent animation
            const deltaTime = Math.min((currentTime - lastFrameTime) / 1000, 0.1); // Cap at 100ms to prevent jumps
            lastFrameTime = currentTime;

            // FPS calculation
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }

            time = currentTime * 0.001;

            // Smooth time for consistent animation feel
            const paramSmoothTime = 0.15; // seconds to reach target
            const mouseSmoothTime = 0.08; // faster response for mouse

            // Frame-rate independent mouse smoothing
            const mouseResult = {
                x: smoothDamp(smoothMouseX, mouseX, velocities.mouseX, mouseSmoothTime, deltaTime),
                y: smoothDamp(smoothMouseY, mouseY, velocities.mouseY, mouseSmoothTime, deltaTime)
            };
            smoothMouseX = mouseResult.x.value;
            smoothMouseY = mouseResult.y.value;
            velocities.mouseX = mouseResult.x.velocity;
            velocities.mouseY = mouseResult.y.velocity;

            // Frame-rate independent parameter smoothing using smooth damp
            const speedResult = smoothDamp(params.speed, targetParams.speed, velocities.speed, paramSmoothTime, deltaTime);
            params.speed = speedResult.value;
            velocities.speed = speedResult.velocity;

            const viscosityResult = smoothDamp(params.viscosity, targetParams.viscosity, velocities.viscosity, paramSmoothTime, deltaTime);
            params.viscosity = viscosityResult.value;
            velocities.viscosity = viscosityResult.velocity;

            const blobSizeResult = smoothDamp(params.blobSize, targetParams.blobSize, velocities.blobSize, paramSmoothTime, deltaTime);
            params.blobSize = blobSizeResult.value;
            velocities.blobSize = blobSizeResult.velocity;

            const lightResult = smoothDamp(params.lightIntensity, targetParams.lightIntensity, velocities.lightIntensity, paramSmoothTime, deltaTime);
            params.lightIntensity = lightResult.value;
            velocities.lightIntensity = lightResult.velocity;

            // Smooth color transitions
            const blobColorResult = smoothDampColor(params.blobColor, targetParams.blobColor, velocities.blobColor, paramSmoothTime, deltaTime);
            params.blobColor = blobColorResult.value;
            velocities.blobColor = blobColorResult.velocity;

            const liquidColorResult = smoothDampColor(params.liquidColor, targetParams.liquidColor, velocities.liquidColor, paramSmoothTime, deltaTime);
            params.liquidColor = liquidColorResult.value;
            velocities.liquidColor = liquidColorResult.velocity;

            // Blob count uses simple lerp (integer value)
            const blobCountSmooth = 1 - Math.pow(0.001, deltaTime);
            params.blobCount = Math.round(lerp(params.blobCount, targetParams.blobCount, blobCountSmooth));

            // Update uniforms using cached locations
            gl.uniform1f(uniforms.time, time);
            gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
            gl.uniform2f(uniforms.mouse, smoothMouseX, smoothMouseY);
            gl.uniform1i(uniforms.blobCount, params.blobCount);
            gl.uniform1f(uniforms.speed, params.speed);
            gl.uniform1f(uniforms.viscosity, params.viscosity);
            gl.uniform1f(uniforms.blobSize, params.blobSize);
            gl.uniform3fv(uniforms.blobColor, params.blobColor);
            gl.uniform3fv(uniforms.liquidColor, params.liquidColor);
            gl.uniform1f(uniforms.lightIntensity, params.lightIntensity);

            // Render
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(animate);
        }

        // Launch
        init();
        animate(0);
    </script>
</body>
</html>
