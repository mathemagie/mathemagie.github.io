<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Lines with p5.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            overflow: hidden; /* Prevent scrollbars */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script>
        // Define the maximum number of lines we want on the screen
        const maxLines = 100; // Renamed from maxDots
        let drawSpeed = 0.2; // Control the speed of adding new lines
        let lines = []; // Array to store line data (Renamed from dots)
        const removalRadius = 50; // Radius around the mouse to remove lines
        let lastFrameTime = 0; // For tracking time between frames
        let targetFrameRate = 60; // Target frames per second
        let frameInterval = 1000 / targetFrameRate; // Milliseconds per frame
        let deltaTime = 0; // Time since last frame
        let animationFrameId; // For storing the requestAnimationFrame ID
        let customFrameCount = 0; // Custom frame counter for consistent timing

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 1); // Use HSB color mode
            strokeWeight(2); // Adjust stroke weight for lines (made thinner)
            
            // Disable auto looping from p5.js
            noLoop();
            
            // Start our custom animation loop
            lastFrameTime = performance.now();
            animationLoop();
        }
        
        // Custom animation loop using requestAnimationFrame
        function animationLoop(currentTime) {
            // Calculate time since last frame
            if (!currentTime) currentTime = performance.now();
            deltaTime = currentTime - lastFrameTime;
            
            // Only render if enough time has passed for our target frame rate
            if (deltaTime >= frameInterval) {
                // Update our custom frame counter
                customFrameCount++;
                
                // Update the last frame time, accounting for the actual time passed
                lastFrameTime = currentTime - (deltaTime % frameInterval);
                
                // Call our draw function
                draw();
            }
            
            // Request the next frame
            animationFrameId = requestAnimationFrame(animationLoop);
        }

        function draw() {
            background(0, 0, 0, 1); // Solid black background
            manageLines(); // Renamed from manageDots
            removeLinesNearMouse(); // Add this call
            drawLines();   // Renamed from drawDots

            // Draw the eraser (gomme) if left mouse is pressed
            if (mouseIsPressed && mouseButton === LEFT) {
                drawEraser(mouseX, mouseY, removalRadius);
            }
        }

        // Function to draw an eraser shape
        function drawEraser(x, y, radius) {
            push(); // Isolate drawing style changes
            translate(x, y); // Move to mouse position
            rectMode(CENTER); // Draw rectangles from their center
            
            // Main eraser body (pink rectangle)
            fill(340, 60, 95); // Pink color
            stroke(340, 80, 70);
            strokeWeight(2);
            rect(0, 0, radius * 1.5, radius * 0.8, 5); // Rounded rectangle
            
            // White eraser bottom (rubber part)
            fill(0, 0, 100); // White
            stroke(0, 0, 70);
            rect(0, radius * 0.2, radius * 1.5, radius * 0.4, 3); // Bottom part
            
            // Small decorative lines
            stroke(340, 80, 50);
            line(-radius * 0.65, -radius * 0.3, -radius * 0.65, radius * 0.3);
            line(-radius * 0.4, -radius * 0.3, -radius * 0.4, radius * 0.3);
            line(-radius * 0.15, -radius * 0.3, -radius * 0.15, radius * 0.3);
            line(radius * 0.1, -radius * 0.3, radius * 0.1, radius * 0.3);
            line(radius * 0.35, -radius * 0.3, radius * 0.35, radius * 0.3);
            line(radius * 0.6, -radius * 0.3, radius * 0.6, radius * 0.3);
            
            pop(); // Restore original drawing styles
        }

        // Function to manage adding/removing lines
        function manageLines() {
            // Add a new line at the specified speed
            if (customFrameCount % Math.floor(1/drawSpeed) === 0) {
                // Generate random start and end points for the line
                let startX = random(width);
                let startY = random(height);
                let endX = random(width);
                let endY = random(height);
                // Generate color properties
                let hue = random(360); // Random color hue
                let saturation = 80;
                let brightness = 90;
                let alpha = 0.8; // Keep alpha slightly transparent

                // Create an object to store the line's data
                let newLine = {
                    startX: startX,
                    startY: startY,
                    endX: endX,
                    endY: endY,
                    hue: hue,
                    saturation: saturation,
                    brightness: brightness,
                    alpha: alpha
                };

                // Add the new line to the end of the array
                lines.push(newLine);

                // If we have more lines than the maximum allowed,
                // remove the oldest one (from the beginning of the array).
                if (lines.length > maxLines) {
                    lines.shift(); // shift() removes the first element
                }
            }
        }

        // Helper function to calculate the squared distance between two points
        function distSq(x1, y1, x2, y2) {
            let dx = x2 - x1;
            let dy = y2 - y1;
            return dx * dx + dy * dy;
        }

        // Helper function to calculate the shortest distance between a point and a line segment
        function pointSegmentDistance(px, py, x1, y1, x2, y2) {
            let l2 = distSq(x1, y1, x2, y2);
            if (l2 === 0) return dist(px, py, x1, y1); // Handle case where segment is a point

            // Calculate the projection parameter t
            let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
            // Clamp t to the range [0, 1] to stay within the segment
            t = Math.max(0, Math.min(1, t));

            // Calculate the closest point on the segment
            let closestX = x1 + t * (x2 - x1);
            let closestY = y1 + t * (y2 - y1);

            // Return the distance from the point to the closest point on the segment
            return dist(px, py, closestX, closestY);
        }

        // Function to remove lines near the mouse cursor
        function removeLinesNearMouse() {
            // Only remove lines if the left mouse button is pressed
            if (mouseIsPressed && mouseButton === LEFT) {
                lines = lines.filter(lineData => {
                    // Calculate the shortest distance from the mouse cursor to the line segment
                    let distanceToSegment = pointSegmentDistance(
                        mouseX, mouseY,
                        lineData.startX, lineData.startY,
                        lineData.endX, lineData.endY
                    );

                    // Keep the line only if the distance is greater than the removal radius
                    return distanceToSegment > removalRadius;
                });
            }
        }

        // Function to draw all stored lines
        function drawLines() {
            // Draw all stored lines
            for (let i = 0; i < lines.length; i++) {
                let lineData = lines[i];
                // Set the color for this specific line
                stroke(lineData.hue, lineData.saturation, lineData.brightness, lineData.alpha);
                // Draw the line using its stored start and end points
                line(lineData.startX, lineData.startY, lineData.endX, lineData.endY);
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            // We don't need to call loop() since we're using our own animation loop
        }
        
        // Function to clean up when the page is closed or refreshed
        window.addEventListener('beforeunload', () => {
            // Cancel the animation frame to prevent memory leaks
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });
    </script>
</body>
</html>
