<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISS Tracker</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
    <!-- CSS styles for layout and appearance -->
    <style>
        /* Remove default margins and center everything */
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            background: #000;
            color: #DAA520; /* Changed to gold color */
            font-family: 'Space Grotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow: hidden; /* Prevent scrollbars from starfield */
            padding-top: 80px; /* Space for info panel */
        }
        /* Add a subtle border to the canvas */
        canvas {
            border: 2px solid #00FF00; /* Changed to neon green */
            box-shadow:
                0 0 20px rgba(0, 255, 0, 0.4),
                0 0 40px rgba(0, 255, 0, 0.2),
                inset 0 0 20px rgba(0, 255, 0, 0.1);
            max-width: 100%;
            height: auto;
            border-radius: 4px;
        }
        /* Info display panel */
        #info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            padding: 12px 24px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            box-shadow:
                0 0 20px rgba(0, 255, 0, 0.1),
                inset 0 0 20px rgba(0, 255, 0, 0.05);
            z-index: 1000;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            align-items: center;
            gap: 16px;
            max-width: 95vw;
        }

        #info .title {
            font-size: 16px;
            font-weight: 600;
            color: #00FF00;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-right: 8px;
            white-space: nowrap;
        }

        #info .data-row {
            display: flex;
            align-items: baseline;
            gap: 8px;
            font-size: 12px;
            white-space: nowrap;
        }

        #info .label {
            color: rgba(218, 165, 32, 0.8);
            font-weight: 400;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-size: 10px;
        }

        #info .value {
            font-family: 'JetBrains Mono', monospace;
            color: #DAA520;
            font-weight: 400;
            font-size: 13px;
            letter-spacing: 0.5px;
        }

        .separator {
            color: #00FF00; /* Changed to neon green */
            margin: 0 10px;
        }
        /* Add loading and error states */
        .loading {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .error {
            color: #FF4444;
        }
        
        /* Add tooltip style */
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(10px);
            color: #DAA520;
            padding: 12px 16px;
            border-radius: 6px;
            border: 1px solid rgba(0, 255, 0, 0.4);
            box-shadow:
                0 4px 12px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(0, 255, 0, 0.2);
            display: none;
            z-index: 2000;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            line-height: 1.6;
            pointer-events: none;
        }

        .tooltip-label {
            color: rgba(218, 165, 32, 0.7);
            font-size: 10px;
            text-transform: uppercase;
        }

        .tooltip-value {
            color: #00FF00;
            font-weight: 600;
        }
        /* Add starfield container */
        #starfield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }
        .star {
            position: absolute;
            background: #FFF;
            border-radius: 50%;
            animation: twinkle var(--duration) infinite;
            box-shadow: 0 0 2px rgba(255, 255, 255, 0.8);
        }

        @keyframes twinkle {
            0%, 100% {
                opacity: 0.2;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        .star.blue {
            background: #64C8FF;
            box-shadow: 0 0 3px rgba(100, 200, 255, 0.8);
        }

        .star.gold {
            background: #DAA520;
            box-shadow: 0 0 3px rgba(218, 165, 32, 0.8);
        }

        /* Mobile-specific enhancements */
        @media (max-width: 768px) {
            /* CRT scanline effect overlay */
            body::before {
                content: '';
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: repeating-linear-gradient(
                    0deg,
                    rgba(0, 0, 0, 0.1),
                    rgba(0, 0, 0, 0.1) 1px,
                    transparent 1px,
                    transparent 2px
                );
                pointer-events: none;
                z-index: 9999;
                opacity: 0.2;
            }

            /* Subtle vignette for depth */
            body::after {
                content: '';
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: radial-gradient(
                    ellipse at center,
                    transparent 0%,
                    transparent 60%,
                    rgba(0, 0, 0, 0.3) 100%
                );
                pointer-events: none;
                z-index: 9998;
            }

            /* Audio indicator pulse */
            #info::before {
                content: '‚óè';
                position: absolute;
                top: 14px;
                right: 16px;
                color: #00FF00;
                font-size: 8px;
                animation: audioPulse 2s ease-in-out infinite;
                text-shadow: 0 0 8px rgba(0, 255, 0, 0.8);
            }

            @keyframes audioPulse {
                0%, 100% {
                    opacity: 0.4;
                    transform: scale(1);
                }
                50% {
                    opacity: 1;
                    transform: scale(1.2);
                }
            }

            /* Enhanced touch feedback for canvas */
            canvas {
                -webkit-tap-highlight-color: rgba(0, 255, 0, 0.1);
                touch-action: pan-y;
            }

            /* Improve tooltip for mobile */
            #tooltip {
                font-size: 11px;
                padding: 10px 14px;
                backdrop-filter: blur(15px);
                border-width: 2px;
            }

            /* Mobile status footer */
            #mobile-status {
                display: flex;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: linear-gradient(0deg, rgba(0, 0, 0, 0.95) 0%, rgba(0, 0, 0, 0.88) 100%);
                backdrop-filter: blur(10px);
                padding: 10px 16px;
                justify-content: space-between;
                align-items: center;
                border-top: 1px solid rgba(0, 255, 0, 0.2);
                box-shadow: 0 -4px 20px rgba(0, 255, 0, 0.1);
                z-index: 1000;
            }

            .status-item {
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 9px;
                letter-spacing: 1.5px;
                font-weight: 600;
                color: #DAA520;
            }

            .status-dot {
                width: 6px;
                height: 6px;
                border-radius: 50%;
                background: #00FF00;
                box-shadow: 0 0 8px rgba(0, 255, 0, 0.8);
                animation: statusBlink 2s ease-in-out infinite;
            }

            .status-icon {
                font-size: 12px;
                filter: grayscale(0.3);
                opacity: 0.9;
            }

            .status-label {
                text-transform: uppercase;
                color: rgba(218, 165, 32, 0.7);
            }

            @keyframes statusBlink {
                0%, 100% {
                    opacity: 1;
                }
                50% {
                    opacity: 0.3;
                }
            }
        }

        /* Hide mobile status on desktop */
        #mobile-status {
            display: none;
        }

        /* Responsive breakpoints */
        @media (max-width: 768px) {
            body {
                padding-top: 0;
                padding-bottom: 50px;
            }

            #info {
                top: 0;
                left: 0;
                right: 0;
                transform: none;
                max-width: 100%;
                border-radius: 0 0 16px 16px;
                border-top: none;
                border-left: none;
                border-right: none;
                padding: 12px 16px 10px;
                gap: 6px;
                background: linear-gradient(180deg, rgba(0, 0, 0, 0.96) 0%, rgba(0, 0, 0, 0.90) 100%);
                box-shadow:
                    0 6px 24px rgba(0, 255, 0, 0.18),
                    inset 0 -1px 0 rgba(0, 255, 0, 0.35);
                flex-direction: column;
            }

            #info .title {
                font-size: 9px;
                letter-spacing: 3.5px;
                font-weight: 700;
                color: #00FF00;
                width: 100%;
                padding-bottom: 6px;
                border-bottom: 1px solid rgba(0, 255, 0, 0.25);
                margin: 0 0 6px 0;
                text-shadow: 0 0 12px rgba(0, 255, 0, 0.6);
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            #info .data-row {
                font-size: 10px;
                display: grid;
                grid-template-columns: 80px 1fr;
                gap: 12px;
                align-items: baseline;
                padding: 3px 0;
            }

            #info .label {
                font-size: 8px;
                letter-spacing: 1.2px;
                color: rgba(218, 165, 32, 0.55);
                font-weight: 600;
                text-transform: uppercase;
            }

            #info .value {
                font-size: 14px;
                letter-spacing: 0.3px;
                font-weight: 600;
                color: #DAA520;
                text-shadow: 0 0 10px rgba(218, 165, 32, 0.5);
                font-variant-numeric: tabular-nums;
                text-align: right;
            }

            canvas {
                border-width: 2px;
                border-radius: 8px;
                box-shadow:
                    0 0 15px rgba(0, 255, 0, 0.35),
                    0 0 30px rgba(0, 255, 0, 0.15),
                    inset 0 0 30px rgba(0, 255, 0, 0.08);
                margin-top: 140px;
                width: 95vw !important;
                height: auto !important;
                max-height: calc(100vh - 240px);
            }
        }

        @media (max-width: 480px) {
            body {
                padding-top: 0;
                padding-bottom: 46px;
            }

            #info {
                padding: 10px 14px 8px;
                gap: 5px;
            }

            #info .title {
                font-size: 8px;
                letter-spacing: 3px;
                padding-bottom: 5px;
                margin-bottom: 5px;
            }

            #info .data-row {
                font-size: 9px;
                grid-template-columns: 70px 1fr;
                gap: 10px;
                padding: 2px 0;
            }

            #info .label {
                font-size: 7px;
                letter-spacing: 1px;
            }

            #info .value {
                font-size: 13px;
                letter-spacing: 0.2px;
            }

            canvas {
                margin-top: 106px;
                width: 94vw !important;
                max-height: calc(100vh - 200px);
            }
        }

        @media (max-width: 768px) and (orientation: landscape) {
            body {
                padding-top: 0;
                padding-left: 0;
                padding-bottom: 10px;
            }

            #info {
                top: 0;
                left: 0;
                right: auto;
                transform: none;
                padding: 10px 14px 8px;
                min-width: auto;
                max-width: 42vw;
                border-radius: 0 0 14px 0;
                flex-direction: column;
                gap: 4px;
            }

            #info .title {
                font-size: 8px;
                letter-spacing: 2.5px;
                padding-bottom: 4px;
                margin-bottom: 4px;
            }

            #info .data-row {
                grid-template-columns: 65px 1fr;
                gap: 8px;
                font-size: 9px;
                padding: 2px 0;
            }

            #info .label {
                font-size: 7px;
                letter-spacing: 0.8px;
            }

            #info .value {
                font-size: 11px;
                letter-spacing: 0.2px;
            }

            canvas {
                margin-top: 16px;
                margin-left: calc(42vw + 16px);
                max-width: calc(58vw - 32px);
                width: calc(58vw - 32px) !important;
                height: auto !important;
                max-height: calc(100vh - 32px);
            }

            /* Hide status footer in landscape */
            #mobile-status {
                display: none;
            }

            /* Reduce scanlines in landscape */
            body::before {
                opacity: 0.1;
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            .star {
                animation: none !important;
                opacity: 0.6;
            }

            .loading {
                animation: none !important;
            }
        }

        @media (prefers-contrast: high) {
            #info {
                border: 2px solid #00FF00;
                background: rgba(0, 0, 0, 0.95);
            }
            canvas { border-width: 3px; }
            .value { color: #FFD700; }
        }
    </style>
</head>
<body>
    <div id="tooltip" role="tooltip" aria-hidden="true"></div>
    <!-- Add starfield container -->
    <div id="starfield"></div>
    <!-- Add title div -->

    <!-- Display area for ISS coordinates -->
    <div id="info" role="region" aria-label="ISS Position Information" aria-live="polite">ISS Position: Loading...</div>

    <!-- Mobile status footer -->
    <div id="mobile-status" role="status" aria-live="polite">
        <span class="status-item">
            <span class="status-dot"></span>
            <span class="status-label">TRACKING</span>
        </span>
        <span class="status-item audio-status">
            <span class="status-icon">üéß</span>
            <span class="status-label">3D AUDIO</span>
        </span>
    </div>

    <!-- Include p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    
    <script>
        // Remove star-related global variables
        let issData = { latitude: 0, longitude: 0, altitude: 0, velocity: 0 };
        let particle;
        let lastFetchTime = 0;
        const FETCH_INTERVAL = 10000; // 10 seconds in milliseconds
        let pulseSize = 0;
        let isPulsing = false;
        let worldMap;
        let audioContext;
        let stars = []; // Add stars array for background
        let audioListener;  // Web Audio API listener for 3D audio
        let activePanner;   // Current active PannerNode for spatial positioning
        let audioScale;     // Coordinate conversion scale factor for 3D audio space

        // Add new global variables
        let loading = true;
        let error = null;
        let lastUpdate = null;
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Function to create ping sound with 3D spatial positioning
        function createPingSound(particleX, particleY) {
            // Create new audio context if it doesn't exist
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            // Create audio nodes
            const oscillator1 = audioContext.createOscillator(); // Main oscillator
            const oscillator2 = audioContext.createOscillator(); // For sub-bass
            const gainNode = audioContext.createGain();
            const delayNode = audioContext.createDelay();
            const filter = audioContext.createBiquadFilter();
            const subFilter = audioContext.createBiquadFilter(); // Additional filter for sub frequencies
            
            // Configure main oscillator (deep sonar style)
            oscillator1.type = 'sine'; // Pure sine wave for sonar feel
            oscillator1.frequency.setValueAtTime(220, audioContext.currentTime); // A3 note
            oscillator1.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.5); // Down to A2
            
            // Configure sub oscillator for depth
            oscillator2.type = 'sine';
            oscillator2.frequency.setValueAtTime(55, audioContext.currentTime); // A1 note
            oscillator2.frequency.exponentialRampToValueAtTime(27.5, audioContext.currentTime + 0.5); // Down to A0
            
            // Configure main filter for sonar character
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(220, audioContext.currentTime);
            filter.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.5);
            filter.Q.value = 2; // Less resonance for smoother sound
            
            // Configure sub filter
            subFilter.type = 'lowpass';
            subFilter.frequency.value = 200;
            subFilter.Q.value = 1;
            
            // Configure multiple delays for deep echo effect
            const delayTimes = [0.2, 0.4, 0.6];
            const delayNodes = delayTimes.map(time => {
                const delay = audioContext.createDelay();
                delay.delayTime.value = time;
                return delay;
            });
            
            // Configure gain (volume) with sonar characteristics
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            // Slow attack
            gainNode.gain.linearRampToValueAtTime(0.7, audioContext.currentTime + 0.1);
            // Long decay
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.5);
            
            // Create feedback loops for delays
            const feedbackGains = delayNodes.map(() => {
                const gain = audioContext.createGain();
                gain.gain.value = 0.4;
                return gain;
            });
            
            // Connect main oscillator chain
            oscillator1.connect(filter);
            filter.connect(gainNode);
            
            // Connect sub oscillator chain
            oscillator2.connect(subFilter);
            subFilter.connect(gainNode);
            
            // Connect delay network
            delayNodes.forEach((delay, i) => {
                filter.connect(delay);
                delay.connect(feedbackGains[i]);
                feedbackGains[i].connect(delay);
                delay.connect(gainNode);
            });

            // Create and configure 3D panner node for spatial audio
            const pannerNode = audioContext.createPanner();
            pannerNode.panningModel = 'HRTF';              // Head-Related Transfer Function for realistic 3D
            pannerNode.distanceModel = 'inverse';          // Natural volume attenuation with distance
            pannerNode.refDistance = 1;                    // Reference distance for attenuation
            pannerNode.maxDistance = 100;                  // Maximum distance before silence
            pannerNode.rolloffFactor = 1;                  // Attenuation curve steepness
            pannerNode.coneInnerAngle = 360;               // Omnidirectional sound
            pannerNode.coneOuterAngle = 0;
            pannerNode.coneOuterGain = 0;

            // Calculate 3D position from screen coordinates
            // Center of screen = listener position (0, 0, 0)
            const audioX = (particleX - width / 2) * audioScale;
            const audioY = -(particleY - height / 2) * audioScale;  // Invert Y (screen Y+ is down, audio Y+ is up)
            const audioZ = -10;  // Fixed depth into screen (in front of listener)

            // Set panner position in 3D space
            pannerNode.positionX.setValueAtTime(audioX, audioContext.currentTime);
            pannerNode.positionY.setValueAtTime(audioY, audioContext.currentTime);
            pannerNode.positionZ.setValueAtTime(audioZ, audioContext.currentTime);

            // Connect audio graph: gainNode ‚Üí pannerNode ‚Üí destination
            gainNode.connect(pannerNode);
            pannerNode.connect(audioContext.destination);

            // Store reference to active panner for position updates
            activePanner = pannerNode;

            // Start and stop the sound
            oscillator1.start();
            oscillator2.start();
            oscillator1.stop(audioContext.currentTime + 2.0);
            oscillator2.stop(audioContext.currentTime + 2.0);
        }

        // Function to initialize 3D spatial audio
        function initializeSpatialAudio() {
            // Create audio context if it doesn't exist
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            // Set up audio listener at screen center
            audioListener = audioContext.listener;

            // Position listener at origin (screen center)
            audioListener.positionX.value = 0;
            audioListener.positionY.value = 0;
            audioListener.positionZ.value = 0;

            // Set listener orientation (forward into screen, up is positive Y)
            audioListener.forwardX.value = 0;
            audioListener.forwardY.value = 0;
            audioListener.forwardZ.value = -1;  // facing into screen (away from user)
            audioListener.upX.value = 0;
            audioListener.upY.value = 1;        // up direction
            audioListener.upZ.value = 0;

            // Calculate audio scale based on screen size
            // This normalizes screen coordinates to audio 3D space
            audioScale = 100 / (width / 2);
        }

        // Function to update panner position based on particle location
        function updatePannerPosition() {
            // Only update if we have an active panner and particle
            if (!activePanner || !particle) return;

            // Convert 2D screen coordinates to 3D audio space
            // Center of screen (width/2, height/2) = audio origin (0, 0, 0)
            const audioX = (particle.x - width / 2) * audioScale;
            const audioY = -(particle.y - height / 2) * audioScale;  // Invert Y (screen Y+ is down, audio Y+ is up)
            const audioZ = -10;  // Fixed depth into screen (in front of listener)

            // Update panner position
            const currentTime = audioContext.currentTime;
            activePanner.positionX.setValueAtTime(audioX, currentTime);
            activePanner.positionY.setValueAtTime(audioY, currentTime);
            activePanner.positionZ.setValueAtTime(audioZ, currentTime);
        }

        // Particle class to handle visualization
        class Particle {
            constructor() {
                this.x = width / 2;
                this.y = height / 2;
                this.size = 20;
                this.color = [218, 165, 32]; // Changed default color to gold (DAA520)
                this.targetX = this.x;
                this.targetY = this.y;
                this.velocity = createVector(0, 0);
                this.acceleration = createVector(0, 0);
                this.maxSpeed = 2; // Reduced max speed
                this.trail = [];
                this.maxTrailLength = isMobile ? 50 : 100; // Reduced trail on mobile
                this.hovered = false;
            }

            // Update particle properties based on ISS position
            update(lat, lon) {
                // Map longitude (-180 to 180) to canvas width (west to east)
                let x = map(lon, -180, 180, 0, width);
                // Map latitude (-90 to 90) to canvas height (north to south)
                let y = map(lat, 90, -90, 0, height);
                
                // Handle wrapping around the map
                if (x < 0) x = width + x;
                if (x > width) x = x - width;
                
                this.targetX = x;
                this.targetY = y;
                
                // Create attraction force towards target
                let target = createVector(this.targetX, this.targetY);
                let position = createVector(this.x, this.y);
                let force = p5.Vector.sub(target, position);
                force.setMag(0.1); // Reduced force for slower movement
                
                // Apply physics
                this.acceleration = force;
                this.velocity.add(this.acceleration);
                this.velocity.limit(this.maxSpeed);
                
                // Update position
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                
                // Update size and color as before
                this.size = map(Math.abs(lat), 0, 90, 20, 60);
                this.color = [
                    218, // R - gold
                    165, // G - gold
                    32   // B - gold
                ];
                
                // Add current position to trail
                this.trail.push(createVector(this.x, this.y));
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
            }

            // Draw the particle on the canvas
            display() {
                // Enhanced trail with gradient
                for (let i = 1; i < this.trail.length; i++) {
                    const alpha = map(i, 0, this.trail.length, 0, 180);
                    const weight = map(i, 0, this.trail.length, 0.5, 4);

                    stroke(...this.color, alpha * 0.6);
                    strokeWeight(weight);

                    // Add glow to recent trail segments
                    if (i > this.trail.length * 0.7) {
                        drawingContext.shadowBlur = 8;
                        drawingContext.shadowColor = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, 0.6)`;
                    } else {
                        drawingContext.shadowBlur = 0;
                    }

                    line(this.trail[i-1].x, this.trail[i-1].y, this.trail[i].x, this.trail[i].y);
                }

                drawingContext.shadowBlur = 0;
                noStroke();

                // Multi-layer glow
                fill(...this.color, 15);
                ellipse(this.x, this.y, this.size * 3);
                fill(...this.color, 40);
                ellipse(this.x, this.y, this.size * 2);
                fill(...this.color, 80);
                ellipse(this.x, this.y, this.size * 1.4);
                fill(...this.color, 220);
                ellipse(this.x, this.y, this.size);
                fill(255, 255, 255, 180);
                ellipse(this.x, this.y, this.size * 0.4);
                fill(0, 255, 0, 60);
                ellipse(this.x, this.y, this.size * 0.8);
            }

            // Add hover detection
            checkHover(mouseX, mouseY) {
                this.hovered = dist(mouseX, mouseY, this.x, this.y) < this.size;
                if (this.hovered) {
                    showTooltip(mouseX, mouseY);
                } else {
                    hideTooltip();
                }
            }
        }

        // p5.js setup function - runs once at start
        function setup() {
            // Make canvas responsive
            const canvasWidth = min(windowWidth * 0.9, 800);
            const canvasHeight = (canvasWidth * 0.75);
            createCanvas(canvasWidth, canvasHeight);
            particle = new Particle();

            // Limit frame rate for performance
            frameRate(30);

            // Create starfield
            createStarfield();

            // Initialize 3D spatial audio system
            initializeSpatialAudio();

            // Initial fetch
            fetchISSData();

            // Set up interval for regular fetching
            setInterval(fetchISSData, FETCH_INTERVAL);
        }

        // Function to create starfield
        function createStarfield() {
            const starfield = document.getElementById('starfield');
            const numberOfStars = 300; // Increased from 200

            for (let i = 0; i < numberOfStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';

                // Add color variation (10% chance for colored stars)
                const rand = Math.random();
                if (rand < 0.05) {
                    star.classList.add('blue');
                } else if (rand < 0.10) {
                    star.classList.add('gold');
                }

                // Variable sizes - more small stars
                const sizeRand = Math.random();
                let size;
                if (sizeRand < 0.7) size = 1 + Math.random() * 1.5; // Small
                else if (sizeRand < 0.9) size = 2 + Math.random() * 2; // Medium
                else size = 3 + Math.random() * 2; // Large

                // Random twinkle duration and delay
                const duration = 2 + Math.random() * 6;
                const delay = Math.random() * 4;

                star.style.cssText = `
                    left: ${Math.random() * 100}%;
                    top: ${Math.random() * 100}%;
                    width: ${size}px;
                    height: ${size}px;
                    --duration: ${duration}s;
                    animation-delay: ${delay}s;
                `;

                starfield.appendChild(star);
            }
        }

        // p5.js draw function - runs continuously
        function draw() {
            background(0, 60);  // Reduced from 90 for smoother trails

            // Draw world map with reduced opacity
            drawWorldMap();

            // Draw pulse effect when new data is received
            if (isPulsing) {
                // Multiple concentric rings
                for (let i = 0; i < 3; i++) {
                    const offset = i * 30;
                    const adjustedSize = pulseSize - offset;

                    if (adjustedSize > 0) {
                        const alpha = map(adjustedSize, 0, 220, 0, 200) * (1 - i * 0.3);
                        noFill();
                        stroke(0, 255, 0, alpha);
                        strokeWeight(3 - i);
                        ellipse(particle.x, particle.y, adjustedSize);

                        if (i === 0 && adjustedSize < 40) {
                            fill(0, 255, 0, alpha * 0.2);
                            ellipse(particle.x, particle.y, adjustedSize);
                        }
                    }
                }

                pulseSize += 4;
                if (pulseSize > 220) {
                    isPulsing = false;
                    pulseSize = 0;
                }
            }

            // Update and display particle
            particle.update(issData.latitude, issData.longitude);
            particle.display();

            // Update 3D audio panner position to match particle
            updatePannerPosition();
        }

        // Function to fetch ISS position data
        async function fetchISSData() {
            loading = true;
            error = null;
            updateInfoDisplay();
            
            try {
                // Using the "Where the ISS at?" API
                const response = await fetch('https://api.wheretheiss.at/v1/satellites/25544', {
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                // Update stored position data
                issData.latitude = parseFloat(data.latitude);
                issData.longitude = parseFloat(data.longitude);
                issData.altitude = parseFloat(data.altitude);
                issData.velocity = parseFloat(data.velocity);

                // Trigger pulse effect
                isPulsing = true;
                pulseSize = 0;

                // Play ping sound with spatial positioning
                createPingSound(particle.x, particle.y);

                // Add timezone calculation
                const timezone = await getTimezone(issData.latitude, issData.longitude);
                lastUpdate = new Date().toLocaleTimeString();

                // Update display with more information
                document.getElementById('info').innerHTML = `
                    <div class="title">ISS TRACKER</div>
                    <div class="data-row">
                        <span class="label">Latitude</span>
                        <span class="value">${issData.latitude.toFixed(4)}¬∞</span>
                    </div>
                    <div class="data-row">
                        <span class="label">Longitude</span>
                        <span class="value">${issData.longitude.toFixed(4)}¬∞</span>
                    </div>
                    <div class="data-row">
                        <span class="label">Altitude</span>
                        <span class="value">${issData.altitude.toFixed(2)} km</span>
                    </div>
                `;

                lastFetchTime = millis();
                loading = false;
            } catch (error) {
                error = error.message;
                console.error('Error fetching ISS data:', error);
            }
            
            updateInfoDisplay();
        }

        // Add this new function to draw the world map
        function drawWorldMap() {
            push();

            stroke(0, 255, 0, 50);
            noFill();
            strokeWeight(1.5);
            strokeCap(ROUND);
            strokeJoin(ROUND);

            const scaleX = width / 800;
            const scaleY = height / 600;

            // More refined continent shapes using curveVertex for smoother lines
            // North America
            beginShape();
            curveVertex(100 * scaleX, 100 * scaleY);
            curveVertex(100 * scaleX, 100 * scaleY);
            curveVertex(200 * scaleX, 80 * scaleY);
            curveVertex(250 * scaleX, 120 * scaleY);
            curveVertex(200 * scaleX, 180 * scaleY);
            curveVertex(150 * scaleX, 200 * scaleY);
            curveVertex(100 * scaleX, 100 * scaleY);
            curveVertex(100 * scaleX, 100 * scaleY);
            endShape(CLOSE);

            // South America
            beginShape();
            curveVertex(180 * scaleX, 250 * scaleY);
            curveVertex(180 * scaleX, 250 * scaleY);
            curveVertex(220 * scaleX, 280 * scaleY);
            curveVertex(200 * scaleX, 400 * scaleY);
            curveVertex(180 * scaleX, 450 * scaleY);
            curveVertex(160 * scaleX, 350 * scaleY);
            curveVertex(180 * scaleX, 250 * scaleY);
            curveVertex(180 * scaleX, 250 * scaleY);
            endShape(CLOSE);

            // Europe
            beginShape();
            curveVertex(350 * scaleX, 80 * scaleY);
            curveVertex(350 * scaleX, 80 * scaleY);
            curveVertex(400 * scaleX, 100 * scaleY);
            curveVertex(450 * scaleX, 120 * scaleY);
            curveVertex(400 * scaleX, 150 * scaleY);
            curveVertex(380 * scaleX, 130 * scaleY);
            curveVertex(350 * scaleX, 80 * scaleY);
            curveVertex(350 * scaleX, 80 * scaleY);
            endShape(CLOSE);

            // Africa
            beginShape();
            curveVertex(350 * scaleX, 180 * scaleY);
            curveVertex(350 * scaleX, 180 * scaleY);
            curveVertex(420 * scaleX, 200 * scaleY);
            curveVertex(450 * scaleX, 300 * scaleY);
            curveVertex(400 * scaleX, 400 * scaleY);
            curveVertex(350 * scaleX, 350 * scaleY);
            curveVertex(350 * scaleX, 180 * scaleY);
            curveVertex(350 * scaleX, 180 * scaleY);
            endShape(CLOSE);

            // Asia
            beginShape();
            curveVertex(450 * scaleX, 80 * scaleY);
            curveVertex(450 * scaleX, 80 * scaleY);
            curveVertex(600 * scaleX, 100 * scaleY);
            curveVertex(650 * scaleX, 150 * scaleY);
            curveVertex(700 * scaleX, 200 * scaleY);
            curveVertex(600 * scaleX, 250 * scaleY);
            curveVertex(500 * scaleX, 200 * scaleY);
            curveVertex(450 * scaleX, 80 * scaleY);
            curveVertex(450 * scaleX, 80 * scaleY);
            endShape(CLOSE);

            // Australia
            beginShape();
            curveVertex(600 * scaleX, 300 * scaleY);
            curveVertex(600 * scaleX, 300 * scaleY);
            curveVertex(700 * scaleX, 320 * scaleY);
            curveVertex(680 * scaleX, 380 * scaleY);
            curveVertex(600 * scaleX, 370 * scaleY);
            curveVertex(600 * scaleX, 300 * scaleY);
            curveVertex(600 * scaleX, 300 * scaleY);
            endShape(CLOSE);

            // Antarctica
            beginShape();
            curveVertex(200 * scaleX, 500 * scaleY);
            curveVertex(200 * scaleX, 500 * scaleY);
            curveVertex(300 * scaleX, 520 * scaleY);
            curveVertex(400 * scaleX, 520 * scaleY);
            curveVertex(500 * scaleX, 510 * scaleY);
            curveVertex(600 * scaleX, 500 * scaleY);
            curveVertex(400 * scaleX, 480 * scaleY);
            curveVertex(200 * scaleX, 500 * scaleY);
            curveVertex(200 * scaleX, 500 * scaleY);
            endShape(CLOSE);

            // Greenland
            beginShape();
            curveVertex(280 * scaleX, 50 * scaleY);
            curveVertex(280 * scaleX, 50 * scaleY);
            curveVertex(350 * scaleX, 40 * scaleY);
            curveVertex(320 * scaleX, 80 * scaleY);
            curveVertex(280 * scaleX, 70 * scaleY);
            curveVertex(280 * scaleX, 50 * scaleY);
            curveVertex(280 * scaleX, 50 * scaleY);
            endShape(CLOSE);

            // Draw oceans labels
            fill(0, 255, 0, 30);
            noStroke();
            textSize(12);
            textStyle(NORMAL);
            text("Pacific Ocean", 650 * scaleX, 200 * scaleY);
            text("Atlantic Ocean", 250 * scaleX, 200 * scaleY);
            text("Indian Ocean", 450 * scaleX, 250 * scaleY);
            text("Southern Ocean", 400 * scaleX, 450 * scaleY);

            // Enhanced grid with emphasis on equator and prime meridian
            strokeWeight(0.5);

            for (let y = 0; y <= height; y += height / 12) {
                if (abs(y - height/2) < 2) {
                    stroke(0, 255, 0, 60);
                    strokeWeight(1.5);
                } else {
                    stroke(0, 255, 0, 20);
                    strokeWeight(0.5);
                }
                line(0, y, width, y);
            }

            for (let x = 0; x <= width; x += width / 16) {
                if (abs(x - width/2) < 2) {
                    stroke(0, 255, 0, 60);
                    strokeWeight(1.5);
                } else {
                    stroke(0, 255, 0, 20);
                    strokeWeight(0.5);
                }
                line(x, 0, x, height);
            }

            pop();
        }

        // Add new helper functions
        function updateInfoDisplay() {
            const infoDiv = document.getElementById('info');
            //infoDiv.className = loading ? 'loading' : error ? 'error' : '';
        }
        
        async function getTimezone(lat, lon) {
            try {
                const response = await fetch(`https://api.timezonedb.com/v2.1/get-time-zone?key=YOUR_API_KEY&format=json&by=position&lat=${lat}&lng=${lon}`);
                const data = await response.json();
                return new Date().toLocaleTimeString('en-US', { timeZone: data.zoneName });
            } catch (error) {
                return 'N/A';
            }
        }
        
        function showTooltip(x, y) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'block';

            // Smart positioning to avoid edges
            let left = x + 15;
            let top = y + 15;

            if (left + 200 > windowWidth) left = x - 215;
            if (top + 80 > windowHeight) top = y - 95;

            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
            tooltip.innerHTML = `
                <div><span class="tooltip-label">Latitude:</span> <span class="tooltip-value">${issData.latitude.toFixed(6)}¬∞</span></div>
                <div><span class="tooltip-label">Longitude:</span> <span class="tooltip-value">${issData.longitude.toFixed(6)}¬∞</span></div>
                <div><span class="tooltip-label">Altitude:</span> <span class="tooltip-value">${issData.altitude ? issData.altitude.toFixed(2) : 'N/A'} km</span></div>
            `;
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        // Add window resize handler
        function windowResized() {
            const canvasWidth = min(windowWidth * 0.95, 1000);
            const canvasHeight = canvasWidth * 0.6;
            resizeCanvas(canvasWidth, canvasHeight);

            // Recalculate audio scale for new screen dimensions
            if (audioContext && audioListener) {
                audioScale = 100 / (width / 2);
            }

            // Recreate starfield
            document.getElementById('starfield').innerHTML = '';
            createStarfield();
        }

        // Add mouseMoved function
        function mouseMoved() {
            particle.checkHover(mouseX, mouseY);
        }

        // Add touch support
        function touchMoved() {
            if (touches.length > 0) {
                particle.checkHover(touches[0].x, touches[0].y);
            }
            return false;
        }

        function touchEnded() {
            hideTooltip();
            return false;
        }
    </script>
</body>
</html> 